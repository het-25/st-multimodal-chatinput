{"ast":null,"code":"import _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */\nexport var ChunkedIterator = /*#__PURE__*/function (_Symbol$iterator) {\n  function ChunkedIterator() {\n    var numChunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var getChunkIterator = arguments.length > 1 ? arguments[1] : undefined;\n    _classCallCheck(this, ChunkedIterator);\n    this.numChunks = numChunks;\n    this.getChunkIterator = getChunkIterator;\n    this.chunkIndex = 0;\n    this.chunkIterator = this.getChunkIterator(0);\n  }\n  _createClass(ChunkedIterator, [{\n    key: \"next\",\n    value: function next() {\n      while (this.chunkIndex < this.numChunks) {\n        var next = this.chunkIterator.next();\n        if (!next.done) {\n          return next;\n        }\n        if (++this.chunkIndex < this.numChunks) {\n          this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n        }\n      }\n      return {\n        done: true,\n        value: null\n      };\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this;\n    }\n  }]);\n  return ChunkedIterator;\n}(Symbol.iterator);\n/** @ignore */\nexport function computeChunkNullCounts(chunks) {\n  return chunks.reduce(function (nullCount, chunk) {\n    return nullCount + chunk.nullCount;\n  }, 0);\n}\n/** @ignore */\nexport function computeChunkOffsets(chunks) {\n  return chunks.reduce(function (offsets, chunk, index) {\n    offsets[index + 1] = offsets[index] + chunk.length;\n    return offsets;\n  }, new Uint32Array(chunks.length + 1));\n}\n/** @ignore */\nexport function sliceChunks(chunks, offsets, begin, end) {\n  var slices = [];\n  for (var i = -1, n = chunks.length; ++i < n;) {\n    var chunk = chunks[i];\n    var offset = offsets[i];\n    var length = chunk.length;\n    // Stop if the child is to the right of the slice boundary\n    if (offset >= end) {\n      break;\n    }\n    // Exclude children to the left of of the slice boundary\n    if (begin >= offset + length) {\n      continue;\n    }\n    // Include entire child if between both left and right boundaries\n    if (offset >= begin && offset + length <= end) {\n      slices.push(chunk);\n      continue;\n    }\n    // Include the child slice that overlaps one of the slice boundaries\n    var from = Math.max(0, begin - offset);\n    var to = Math.min(end - offset, length);\n    slices.push(chunk.slice(from, to - from));\n  }\n  if (slices.length === 0) {\n    slices.push(chunks[0].slice(0, 0));\n  }\n  return slices;\n}\n/** @ignore */\nexport function binarySearch(chunks, offsets, idx, fn) {\n  var lhs = 0,\n    mid = 0,\n    rhs = offsets.length - 1;\n  do {\n    if (lhs >= rhs - 1) {\n      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n    }\n    mid = lhs + Math.trunc((rhs - lhs) * .5);\n    idx < offsets[mid] ? rhs = mid : lhs = mid;\n  } while (lhs < rhs);\n}\n/** @ignore */\nexport function isChunkedValid(data, index) {\n  return data.getValid(index);\n}\n/** @ignore */\nexport function wrapChunkedCall1(fn) {\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j);\n  }\n  return function (index) {\n    var data = this.data;\n    return binarySearch(data, this._offsets, index, chunkedFn);\n  };\n}\n/** @ignore */\nexport function wrapChunkedCall2(fn) {\n  var _2;\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j, _2);\n  }\n  return function (index, value) {\n    var data = this.data;\n    _2 = value;\n    var result = binarySearch(data, this._offsets, index, chunkedFn);\n    _2 = undefined;\n    return result;\n  };\n}\n/** @ignore */\nexport function wrapChunkedIndexOf(indexOf) {\n  var _1;\n  function chunkedIndexOf(data, chunkIndex, fromIndex) {\n    var begin = fromIndex,\n      index = 0,\n      total = 0;\n    for (var i = chunkIndex - 1, n = data.length; ++i < n;) {\n      var chunk = data[i];\n      if (~(index = indexOf(chunk, _1, begin))) {\n        return total + index;\n      }\n      begin = 0;\n      total += chunk.length;\n    }\n    return -1;\n  }\n  return function (element, offset) {\n    _1 = element;\n    var data = this.data;\n    var result = typeof offset !== 'number' ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n    _1 = undefined;\n    return result;\n  };\n}","map":{"version":3,"names":["ChunkedIterator","_Symbol$iterator","numChunks","arguments","length","undefined","getChunkIterator","_classCallCheck","chunkIndex","chunkIterator","_createClass","key","value","next","done","Symbol","iterator","computeChunkNullCounts","chunks","reduce","nullCount","chunk","computeChunkOffsets","offsets","index","Uint32Array","sliceChunks","begin","end","slices","i","n","offset","push","from","Math","max","to","min","slice","binarySearch","idx","fn","lhs","mid","rhs","trunc","isChunkedValid","data","getValid","wrapChunkedCall1","chunkedFn","j","_offsets","wrapChunkedCall2","_2","result","wrapChunkedIndexOf","indexOf","_1","chunkedIndexOf","fromIndex","total","element"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/util/chunk.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data.js';\nimport { DataType } from '../type.js';\n\n/** @ignore */\nexport class ChunkedIterator<T extends DataType> implements IterableIterator<T['TValue'] | null> {\n    private chunkIndex = 0;\n    private chunkIterator: IterableIterator<T['TValue'] | null>;\n\n    constructor(\n        private numChunks: number = 0,\n        private getChunkIterator: (chunkIndex: number) => IterableIterator<T['TValue'] | null>\n    ) {\n        this.chunkIterator = this.getChunkIterator(0);\n    }\n\n    next(): IteratorResult<T['TValue'] | null> {\n        while (this.chunkIndex < this.numChunks) {\n            const next = this.chunkIterator.next();\n\n            if (!next.done) {\n                return next;\n            }\n\n            if (++this.chunkIndex < this.numChunks) {\n                this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n            }\n        }\n\n        return { done: true, value: null };\n    }\n\n    [Symbol.iterator]() {\n        return this;\n    }\n}\n\n/** @ignore */\nexport function computeChunkNullCounts<T extends DataType>(chunks: ReadonlyArray<Data<T>>) {\n    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\n\n/** @ignore */\nexport function computeChunkOffsets<T extends DataType>(chunks: ReadonlyArray<Data<T>>) {\n    return chunks.reduce((offsets, chunk, index) => {\n        offsets[index + 1] = offsets[index] + chunk.length;\n        return offsets;\n    }, new Uint32Array(chunks.length + 1));\n}\n\n/** @ignore */\nexport function sliceChunks<T extends DataType>(chunks: ReadonlyArray<Data<T>>, offsets: Uint32Array | Array<number>, begin: number, end: number) {\n    const slices: Data<T>[] = [];\n    for (let i = -1, n = chunks.length; ++i < n;) {\n        const chunk = chunks[i];\n        const offset = offsets[i];\n        const { length } = chunk;\n        // Stop if the child is to the right of the slice boundary\n        if (offset >= end) { break; }\n        // Exclude children to the left of of the slice boundary\n        if (begin >= offset + length) { continue; }\n        // Include entire child if between both left and right boundaries\n        if (offset >= begin && (offset + length) <= end) {\n            slices.push(chunk);\n            continue;\n        }\n        // Include the child slice that overlaps one of the slice boundaries\n        const from = Math.max(0, begin - offset);\n        const to = Math.min(end - offset, length);\n        slices.push(chunk.slice(from, to - from));\n    }\n    if (slices.length === 0) {\n        slices.push(chunks[0].slice(0, 0));\n    }\n    return slices;\n}\n\n/** @ignore */\nexport function binarySearch<\n    T extends DataType,\n    F extends (chunks: ReadonlyArray<Data<T>>, _1: number, _2: number) => any\n>(chunks: ReadonlyArray<Data<T>>, offsets: Uint32Array | number[], idx: number, fn: F) {\n    let lhs = 0, mid = 0, rhs = offsets.length - 1;\n    do {\n        if (lhs >= rhs - 1) {\n            return (idx < offsets[rhs]) ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n        }\n        mid = lhs + (Math.trunc((rhs - lhs) * .5));\n        idx < offsets[mid] ? (rhs = mid) : (lhs = mid);\n    } while (lhs < rhs);\n}\n\n/** @ignore */\nexport function isChunkedValid<T extends DataType>(data: Data<T>, index: number): boolean {\n    return data.getValid(index);\n}\n\n/** @ignore */\nexport function wrapChunkedCall1<T extends DataType>(fn: (c: Data<T>, _1: number) => any) {\n    function chunkedFn(chunks: ReadonlyArray<Data<T>>, i: number, j: number) { return fn(chunks[i], j); }\n    return function (this: any, index: number) {\n        const data = this.data as ReadonlyArray<Data<T>>;\n        return binarySearch(data, this._offsets, index, chunkedFn);\n    };\n}\n\n/** @ignore */\nexport function wrapChunkedCall2<T extends DataType>(fn: (c: Data<T>, _1: number, _2: any) => any) {\n    let _2: any;\n    function chunkedFn(chunks: ReadonlyArray<Data<T>>, i: number, j: number) { return fn(chunks[i], j, _2); }\n    return function (this: any, index: number, value: any) {\n        const data = this.data as ReadonlyArray<Data<T>>;\n        _2 = value;\n        const result = binarySearch(data, this._offsets, index, chunkedFn);\n        _2 = undefined;\n        return result;\n    };\n}\n\n/** @ignore */\nexport function wrapChunkedIndexOf<T extends DataType>(indexOf: (c: Data<T>, e: T['TValue'], o?: number) => any) {\n    let _1: any;\n    function chunkedIndexOf(data: ReadonlyArray<Data<T>>, chunkIndex: number, fromIndex: number) {\n        let begin = fromIndex, index = 0, total = 0;\n        for (let i = chunkIndex - 1, n = data.length; ++i < n;) {\n            const chunk = data[i];\n            if (~(index = indexOf(chunk, _1, begin))) {\n                return total + index;\n            }\n            begin = 0;\n            total += chunk.length;\n        }\n        return -1;\n    }\n    return function (this: any, element: T['TValue'], offset?: number) {\n        _1 = element;\n        const data = this.data as ReadonlyArray<Data<T>>;\n        const result = typeof offset !== 'number'\n            ? chunkedIndexOf(data, 0, 0)\n            : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n        _1 = undefined;\n        return result;\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}