{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncGenerator, __await, __awaiter } from \"tslib\";\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer.mjs';\n/** @ignore */\nexport default {\n  fromIterable(source) {\n    return pump(fromIterable(source));\n  },\n  fromAsyncIterable(source) {\n    return pump(fromAsyncIterable(source));\n  },\n  fromDOMStream(source) {\n    return pump(fromDOMStream(source));\n  },\n  fromNodeStream(stream) {\n    return pump(fromNodeStream(stream));\n  },\n  // @ts-ignore\n  toDOMStream(source, options) {\n    throw new Error(`\"toDOMStream\" not available in this environment`);\n  },\n  // @ts-ignore\n  toNodeStream(source, options) {\n    throw new Error(`\"toNodeStream\" not available in this environment`);\n  }\n};\n/** @ignore */\nconst pump = iterator => {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\nfunction* fromIterable(source) {\n  let done,\n    threw = false;\n  let buffers = [],\n    buffer;\n  let cmd,\n    size,\n    bufferLength = 0;\n  function byteRange() {\n    if (cmd === 'peek') {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  }\n  // Yield so the caller can inject the read command before creating the source Iterator\n  ({\n    cmd,\n    size\n  } = yield null);\n  // initialize the iterator\n  const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n  try {\n    do {\n      // read the next value\n      ({\n        done,\n        value: buffer\n      } = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength));\n      // if chunk is not null or empty, push it onto the queue\n      if (!done && buffer.byteLength > 0) {\n        buffers.push(buffer);\n        bufferLength += buffer.byteLength;\n      }\n      // If we have enough bytes in our buffer, yield chunks until we don't\n      if (done || size <= bufferLength) {\n        do {\n          ({\n            cmd,\n            size\n          } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } catch (e) {\n    (threw = true) && typeof it.throw === 'function' && it.throw(e);\n  } finally {\n    threw === false && typeof it.return === 'function' && it.return(null);\n  }\n  return null;\n}\n/** @ignore */\nfunction fromAsyncIterable(source) {\n  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {\n    let done,\n      threw = false;\n    let buffers = [],\n      buffer;\n    let cmd,\n      size,\n      bufferLength = 0;\n    function byteRange() {\n      if (cmd === 'peek') {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({\n      cmd,\n      size\n    } = yield yield __await(null));\n    // initialize the iterator\n    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n    try {\n      do {\n        // read the next value\n        ({\n          done,\n          value: buffer\n        } = Number.isNaN(size - bufferLength) ? yield __await(it.next()) : yield __await(it.next(size - bufferLength)));\n        // if chunk is not null or empty, push it onto the queue\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n        // If we have enough bytes in our buffer, yield chunks until we don't\n        if (done || size <= bufferLength) {\n          do {\n            ({\n              cmd,\n              size\n            } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && typeof it.throw === 'function' && (yield __await(it.throw(e)));\n    } finally {\n      threw === false && typeof it.return === 'function' && (yield __await(it.return(new Uint8Array(0))));\n    }\n    return yield __await(null);\n  });\n}\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nfunction fromDOMStream(source) {\n  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {\n    let done = false,\n      threw = false;\n    let buffers = [],\n      buffer;\n    let cmd,\n      size,\n      bufferLength = 0;\n    function byteRange() {\n      if (cmd === 'peek') {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({\n      cmd,\n      size\n    } = yield yield __await(null));\n    // initialize the reader and lock the stream\n    const it = new AdaptiveByteReader(source);\n    try {\n      do {\n        // read the next value\n        ({\n          done,\n          value: buffer\n        } = Number.isNaN(size - bufferLength) ? yield __await(it['read']()) : yield __await(it['read'](size - bufferLength)));\n        // if chunk is not null or empty, push it onto the queue\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(toUint8Array(buffer));\n          bufferLength += buffer.byteLength;\n        }\n        // If we have enough bytes in our buffer, yield chunks until we don't\n        if (done || size <= bufferLength) {\n          do {\n            ({\n              cmd,\n              size\n            } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } catch (e) {\n      (threw = true) && (yield __await(it['cancel'](e)));\n    } finally {\n      threw === false ? yield __await(it['cancel']()) : source['locked'] && it.releaseLock();\n    }\n    return yield __await(null);\n  });\n}\n/** @ignore */\nclass AdaptiveByteReader {\n  constructor(source) {\n    this.source = source;\n    this.reader = null;\n    this.reader = this.source['getReader']();\n    // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n    // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n    // about why these errors are raised, but I'm sure there's some important spec reason that\n    // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n    // only solution in this case :/\n    this.reader['closed'].catch(() => {});\n  }\n  get closed() {\n    return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n  }\n  releaseLock() {\n    if (this.reader) {\n      this.reader.releaseLock();\n    }\n    this.reader = null;\n  }\n  cancel(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        reader,\n        source\n      } = this;\n      reader && (yield reader['cancel'](reason).catch(() => {}));\n      source && source['locked'] && this.releaseLock();\n    });\n  }\n  read(size) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (size === 0) {\n        return {\n          done: this.reader == null,\n          value: new Uint8Array(0)\n        };\n      }\n      const result = yield this.reader.read();\n      !result.done && (result.value = toUint8Array(result));\n      return result;\n    });\n  }\n}\n/** @ignore */\nconst onEvent = (stream, event) => {\n  const handler = _ => resolve([event, _]);\n  let resolve;\n  return [event, handler, new Promise(r => (resolve = r) && stream['once'](event, handler))];\n};\n/** @ignore */\nfunction fromNodeStream(stream) {\n  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {\n    const events = [];\n    let event = 'error';\n    let done = false,\n      err = null;\n    let cmd,\n      size,\n      bufferLength = 0;\n    let buffers = [],\n      buffer;\n    function byteRange() {\n      if (cmd === 'peek') {\n        return joinUint8Arrays(buffers, size)[0];\n      }\n      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n      return buffer;\n    }\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({\n      cmd,\n      size\n    } = yield yield __await(null));\n    // ignore stdin if it's a TTY\n    if (stream['isTTY']) {\n      yield yield __await(new Uint8Array(0));\n      return yield __await(null);\n    }\n    try {\n      // initialize the stream event handlers\n      events[0] = onEvent(stream, 'end');\n      events[1] = onEvent(stream, 'error');\n      do {\n        events[2] = onEvent(stream, 'readable');\n        // wait on the first message event from the stream\n        [event, err] = yield __await(Promise.race(events.map(x => x[2])));\n        // if the stream emitted an Error, rethrow it\n        if (event === 'error') {\n          break;\n        }\n        if (!(done = event === 'end')) {\n          // If the size is NaN, request to read everything in the stream's internal buffer\n          if (!Number.isFinite(size - bufferLength)) {\n            buffer = toUint8Array(stream['read']());\n          } else {\n            buffer = toUint8Array(stream['read'](size - bufferLength));\n            // If the byteLength is 0, then the requested amount is more than the stream has\n            // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n            // continue emitting readable events, so request to read everything the stream\n            // has in its internal buffer right now.\n            if (buffer.byteLength < size - bufferLength) {\n              buffer = toUint8Array(stream['read']());\n            }\n          }\n          // if chunk is not null or empty, push it onto the queue\n          if (buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n        }\n        // If we have enough bytes in our buffer, yield chunks until we don't\n        if (done || size <= bufferLength) {\n          do {\n            ({\n              cmd,\n              size\n            } = yield yield __await(byteRange()));\n          } while (size < bufferLength);\n        }\n      } while (!done);\n    } finally {\n      yield __await(cleanup(events, event === 'error' ? err : null));\n    }\n    return yield __await(null);\n    function cleanup(events, err) {\n      buffer = buffers = null;\n      return new Promise((resolve, reject) => {\n        for (const [evt, fn] of events) {\n          stream['off'](evt, fn);\n        }\n        try {\n          // Some stream implementations don't call the destroy callback,\n          // because it's really a node-internal API. Just calling `destroy`\n          // here should be enough to conform to the ReadableStream contract\n          const destroy = stream['destroy'];\n          destroy && destroy.call(stream, err);\n          err = undefined;\n        } catch (e) {\n          err = e || err;\n        } finally {\n          err != null ? reject(err) : resolve();\n        }\n      });\n    }\n  });\n}","map":{"version":3,"names":["toUint8Array","joinUint8Arrays","toUint8ArrayIterator","toUint8ArrayAsyncIterator","fromIterable","source","pump","fromAsyncIterable","fromDOMStream","fromNodeStream","stream","toDOMStream","options","Error","toNodeStream","iterator","next","done","threw","buffers","buffer","cmd","size","bufferLength","byteRange","it","Symbol","value","Number","isNaN","byteLength","push","e","throw","return","__await","asyncIterator","Uint8Array","AdaptiveByteReader","releaseLock","constructor","reader","catch","closed","Promise","resolve","cancel","reason","read","result","onEvent","event","handler","_","r","events","err","race","map","x","isFinite","cleanup","reject","evt","fn","destroy","call","undefined"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/io/adapters.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer.js';\n\nimport { ReadableDOMStreamOptions } from './interfaces.js';\n\ntype Uint8ArrayGenerator = Generator<Uint8Array, null, { cmd: 'peek' | 'read'; size: number }>;\ntype AsyncUint8ArrayGenerator = AsyncGenerator<Uint8Array, null, { cmd: 'peek' | 'read'; size: number }>;\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): Uint8ArrayGenerator {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncUint8ArrayGenerator {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncUint8ArrayGenerator {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncUint8ArrayGenerator {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Uint8ArrayGenerator | AsyncUint8ArrayGenerator>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): Uint8ArrayGenerator {\n\n    let done: boolean | undefined, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any>null);\n\n    // initialize the iterator\n    const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ?\n                it.next() : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return(null!));\n    }\n    return null;\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncUint8ArrayGenerator {\n\n    let done: boolean | undefined, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = (yield <any>null)!);\n\n    // initialize the iterator\n    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                ? await it.next()\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return(new Uint8Array(0)));\n    }\n    return null;\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncUint8ArrayGenerator {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any>null);\n\n    // initialize the reader and lock the stream\n    const it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                ? await it['read']()\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n    return null;\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private reader: ReadableStreamDefaultReader<T> | null = null;\n\n    constructor(private source: ReadableStream<T>) {\n        this.reader = this.source['getReader']();\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.reader['closed'].catch(() => { });\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => { }) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => { }));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadValueResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) } as ReadableStreamReadValueResult<Uint8Array>;\n        }\n        const result = await this.reader!.read() as ReadableStreamReadValueResult<any>;\n        !result.done && (result.value = toUint8Array(result));\n        return result;\n    }\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    const handler = (_: any) => resolve([event, _]);\n    let resolve: (value: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncUint8ArrayGenerator {\n\n    const events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any>null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) {\n        yield new Uint8Array(0);\n        return null;\n    }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!Number.isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read']());\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if ((buffer as Uint8Array).byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read']());\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if ((buffer as Uint8Array).byteLength > 0) {\n                    buffers.push(buffer as Uint8Array);\n                    bufferLength += (buffer as Uint8Array).byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    return null;\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any>null;\n        return new Promise<void>((resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e as T || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}