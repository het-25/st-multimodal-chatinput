{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(_fromIterable);\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncGenerator, __await, __awaiter } from \"tslib\";\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer.mjs';\n/** @ignore */\nexport default {\n  fromIterable: function fromIterable(source) {\n    return pump(_fromIterable(source));\n  },\n  fromAsyncIterable: function fromAsyncIterable(source) {\n    return pump(_fromAsyncIterable(source));\n  },\n  fromDOMStream: function fromDOMStream(source) {\n    return pump(_fromDOMStream(source));\n  },\n  fromNodeStream: function fromNodeStream(stream) {\n    return pump(_fromNodeStream(stream));\n  },\n  // @ts-ignore\n  toDOMStream: function toDOMStream(source, options) {\n    throw new Error(\"\\\"toDOMStream\\\" not available in this environment\");\n  },\n  // @ts-ignore\n  toNodeStream: function toNodeStream(source, options) {\n    throw new Error(\"\\\"toNodeStream\\\" not available in this environment\");\n  }\n};\n/** @ignore */\nvar pump = function pump(iterator) {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\nfunction _fromIterable(source) {\n  var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield, it, _ref, _yield$byteRange;\n  return _regeneratorRuntime().wrap(function _fromIterable$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        byteRange = function _byteRange() {\n          if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n          }\n          var _joinUint8Arrays = joinUint8Arrays(buffers, size);\n          var _joinUint8Arrays2 = _slicedToArray(_joinUint8Arrays, 3);\n          buffer = _joinUint8Arrays2[0];\n          buffers = _joinUint8Arrays2[1];\n          bufferLength = _joinUint8Arrays2[2];\n          return buffer;\n        };\n        threw = false;\n        buffers = [];\n        bufferLength = 0;\n        _context.next = 6;\n        return null;\n      case 6:\n        _yield = _context.sent;\n        cmd = _yield.cmd;\n        size = _yield.size;\n        // initialize the iterator\n        it = toUint8ArrayIterator(source)[Symbol.iterator]();\n        _context.prev = 10;\n      case 11:\n        // read the next value\n        // if chunk is not null or empty, push it onto the queue\n        _ref = Number.isNaN(size - bufferLength) ? it.next() : it.next(size - bufferLength);\n        done = _ref.done;\n        buffer = _ref.value;\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n        // If we have enough bytes in our buffer, yield chunks until we don't\n        if (!(done || size <= bufferLength)) {\n          _context.next = 22;\n          break;\n        }\n      case 16:\n        _context.next = 18;\n        return byteRange();\n      case 18:\n        _yield$byteRange = _context.sent;\n        cmd = _yield$byteRange.cmd;\n        size = _yield$byteRange.size;\n      case 21:\n        if (size < bufferLength) {\n          _context.next = 16;\n          break;\n        }\n      case 22:\n        if (!done) {\n          _context.next = 11;\n          break;\n        }\n      case 23:\n        _context.next = 28;\n        break;\n      case 25:\n        _context.prev = 25;\n        _context.t0 = _context[\"catch\"](10);\n        (threw = true) && typeof it.throw === 'function' && it.throw(_context.t0);\n      case 28:\n        _context.prev = 28;\n        threw === false && typeof it.return === 'function' && it.return(null);\n        return _context.finish(28);\n      case 31:\n        return _context.abrupt(\"return\", null);\n      case 32:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[10, 25, 28, 31]]);\n}\n/** @ignore */\nfunction _fromAsyncIterable(source) {\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function fromAsyncIterable_1() {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield$yield$__await, it, _ref2, _yield$yield$__await2;\n    return _regeneratorRuntime().wrap(function fromAsyncIterable_1$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          byteRange = function _byteRange2() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays3 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays4 = _slicedToArray(_joinUint8Arrays3, 3);\n            buffer = _joinUint8Arrays4[0];\n            buffers = _joinUint8Arrays4[1];\n            bufferLength = _joinUint8Arrays4[2];\n            return buffer;\n          };\n          threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context2.next = 6;\n          return __await(null);\n        case 6:\n          _context2.next = 8;\n          return _context2.sent;\n        case 8:\n          _yield$yield$__await = _context2.sent;\n          cmd = _yield$yield$__await.cmd;\n          size = _yield$yield$__await.size;\n          // initialize the iterator\n          it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n          _context2.prev = 12;\n        case 13:\n          if (!Number.isNaN(size - bufferLength)) {\n            _context2.next = 19;\n            break;\n          }\n          _context2.next = 16;\n          return __await(it.next());\n        case 16:\n          _context2.t0 = _context2.sent;\n          _context2.next = 22;\n          break;\n        case 19:\n          _context2.next = 21;\n          return __await(it.next(size - bufferLength));\n        case 21:\n          _context2.t0 = _context2.sent;\n        case 22:\n          _ref2 = _context2.t0;\n          done = _ref2.done;\n          buffer = _ref2.value;\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context2.next = 35;\n            break;\n          }\n        case 27:\n          _context2.next = 29;\n          return __await(byteRange());\n        case 29:\n          _context2.next = 31;\n          return _context2.sent;\n        case 31:\n          _yield$yield$__await2 = _context2.sent;\n          cmd = _yield$yield$__await2.cmd;\n          size = _yield$yield$__await2.size;\n        case 34:\n          if (size < bufferLength) {\n            _context2.next = 27;\n            break;\n          }\n        case 35:\n          if (!done) {\n            _context2.next = 13;\n            break;\n          }\n        case 36:\n          _context2.next = 44;\n          break;\n        case 38:\n          _context2.prev = 38;\n          _context2.t1 = _context2[\"catch\"](12);\n          _context2.t2 = (threw = true) && typeof it.throw === 'function';\n          if (!_context2.t2) {\n            _context2.next = 44;\n            break;\n          }\n          _context2.next = 44;\n          return __await(it.throw(_context2.t1));\n        case 44:\n          _context2.prev = 44;\n          _context2.t3 = threw === false && typeof it.return === 'function';\n          if (!_context2.t3) {\n            _context2.next = 49;\n            break;\n          }\n          _context2.next = 49;\n          return __await(it.return(new Uint8Array(0)));\n        case 49:\n          return _context2.finish(44);\n        case 50:\n          _context2.next = 52;\n          return __await(null);\n        case 52:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 53:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, fromAsyncIterable_1, null, [[12, 38, 44, 50]]);\n  }));\n}\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nfunction _fromDOMStream(source) {\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function fromDOMStream_1() {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield$yield$__await3, it, _ref3, _yield$yield$__await4;\n    return _regeneratorRuntime().wrap(function fromDOMStream_1$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          byteRange = function _byteRange3() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays5 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays6 = _slicedToArray(_joinUint8Arrays5, 3);\n            buffer = _joinUint8Arrays6[0];\n            buffers = _joinUint8Arrays6[1];\n            bufferLength = _joinUint8Arrays6[2];\n            return buffer;\n          };\n          done = false, threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context3.next = 6;\n          return __await(null);\n        case 6:\n          _context3.next = 8;\n          return _context3.sent;\n        case 8:\n          _yield$yield$__await3 = _context3.sent;\n          cmd = _yield$yield$__await3.cmd;\n          size = _yield$yield$__await3.size;\n          // initialize the reader and lock the stream\n          it = new AdaptiveByteReader(source);\n          _context3.prev = 12;\n        case 13:\n          if (!Number.isNaN(size - bufferLength)) {\n            _context3.next = 19;\n            break;\n          }\n          _context3.next = 16;\n          return __await(it['read']());\n        case 16:\n          _context3.t0 = _context3.sent;\n          _context3.next = 22;\n          break;\n        case 19:\n          _context3.next = 21;\n          return __await(it['read'](size - bufferLength));\n        case 21:\n          _context3.t0 = _context3.sent;\n        case 22:\n          _ref3 = _context3.t0;\n          done = _ref3.done;\n          buffer = _ref3.value;\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(toUint8Array(buffer));\n            bufferLength += buffer.byteLength;\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context3.next = 35;\n            break;\n          }\n        case 27:\n          _context3.next = 29;\n          return __await(byteRange());\n        case 29:\n          _context3.next = 31;\n          return _context3.sent;\n        case 31:\n          _yield$yield$__await4 = _context3.sent;\n          cmd = _yield$yield$__await4.cmd;\n          size = _yield$yield$__await4.size;\n        case 34:\n          if (size < bufferLength) {\n            _context3.next = 27;\n            break;\n          }\n        case 35:\n          if (!done) {\n            _context3.next = 13;\n            break;\n          }\n        case 36:\n          _context3.next = 44;\n          break;\n        case 38:\n          _context3.prev = 38;\n          _context3.t1 = _context3[\"catch\"](12);\n          _context3.t2 = threw = true;\n          if (!_context3.t2) {\n            _context3.next = 44;\n            break;\n          }\n          _context3.next = 44;\n          return __await(it['cancel'](_context3.t1));\n        case 44:\n          _context3.prev = 44;\n          if (!(threw === false)) {\n            _context3.next = 50;\n            break;\n          }\n          _context3.next = 48;\n          return __await(it['cancel']());\n        case 48:\n          _context3.next = 51;\n          break;\n        case 50:\n          source['locked'] && it.releaseLock();\n        case 51:\n          return _context3.finish(44);\n        case 52:\n          _context3.next = 54;\n          return __await(null);\n        case 54:\n          return _context3.abrupt(\"return\", _context3.sent);\n        case 55:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, fromDOMStream_1, null, [[12, 38, 44, 52]]);\n  }));\n}\n/** @ignore */\nvar AdaptiveByteReader = /*#__PURE__*/function () {\n  function AdaptiveByteReader(source) {\n    _classCallCheck(this, AdaptiveByteReader);\n    this.source = source;\n    this.reader = null;\n    this.reader = this.source['getReader']();\n    // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n    // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n    // about why these errors are raised, but I'm sure there's some important spec reason that\n    // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n    // only solution in this case :/\n    this.reader['closed'].catch(function () {});\n  }\n  _createClass(AdaptiveByteReader, [{\n    key: \"closed\",\n    get: function get() {\n      return this.reader ? this.reader['closed'].catch(function () {}) : Promise.resolve();\n    }\n  }, {\n    key: \"releaseLock\",\n    value: function releaseLock() {\n      if (this.reader) {\n        this.reader.releaseLock();\n      }\n      this.reader = null;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var reader, source;\n        return _regeneratorRuntime().wrap(function _callee$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              reader = this.reader, source = this.source;\n              _context4.t0 = reader;\n              if (!_context4.t0) {\n                _context4.next = 5;\n                break;\n              }\n              _context4.next = 5;\n              return reader['cancel'](reason).catch(function () {});\n            case 5:\n              source && source['locked'] && this.releaseLock();\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"read\",\n    value: function read(size) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(size === 0)) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                done: this.reader == null,\n                value: new Uint8Array(0)\n              });\n            case 2:\n              _context5.next = 4;\n              return this.reader.read();\n            case 4:\n              result = _context5.sent;\n              !result.done && (result.value = toUint8Array(result));\n              return _context5.abrupt(\"return\", result);\n            case 7:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n  }]);\n  return AdaptiveByteReader;\n}();\n/** @ignore */\nvar onEvent = function onEvent(stream, event) {\n  var handler = function handler(_) {\n    return resolve([event, _]);\n  };\n  var resolve;\n  return [event, handler, new Promise(function (r) {\n    return (resolve = r) && stream['once'](event, handler);\n  })];\n};\n/** @ignore */\nfunction _fromNodeStream(stream) {\n  return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function fromNodeStream_1() {\n    var events, event, done, err, cmd, size, bufferLength, buffers, buffer, byteRange, _yield$yield$__await5, _yield$__await, _yield$__await2, _yield$yield$__await6, cleanup;\n    return _regeneratorRuntime().wrap(function fromNodeStream_1$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          cleanup = function _cleanup(events, err) {\n            buffer = buffers = null;\n            return new Promise(function (resolve, reject) {\n              var _iterator = _createForOfIteratorHelper(events),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var _step$value = _slicedToArray(_step.value, 2),\n                    evt = _step$value[0],\n                    fn = _step$value[1];\n                  stream['off'](evt, fn);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                var destroy = stream['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n              } catch (e) {\n                err = e || err;\n              } finally {\n                err != null ? reject(err) : resolve();\n              }\n            });\n          };\n          byteRange = function _byteRange4() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays7 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays8 = _slicedToArray(_joinUint8Arrays7, 3);\n            buffer = _joinUint8Arrays8[0];\n            buffers = _joinUint8Arrays8[1];\n            bufferLength = _joinUint8Arrays8[2];\n            return buffer;\n          };\n          events = [];\n          event = 'error';\n          done = false, err = null;\n          bufferLength = 0;\n          buffers = [];\n          _context6.next = 9;\n          return __await(null);\n        case 9:\n          _context6.next = 11;\n          return _context6.sent;\n        case 11:\n          _yield$yield$__await5 = _context6.sent;\n          cmd = _yield$yield$__await5.cmd;\n          size = _yield$yield$__await5.size;\n          if (!stream['isTTY']) {\n            _context6.next = 22;\n            break;\n          }\n          _context6.next = 17;\n          return __await(new Uint8Array(0));\n        case 17:\n          _context6.next = 19;\n          return _context6.sent;\n        case 19:\n          _context6.next = 21;\n          return __await(null);\n        case 21:\n          return _context6.abrupt(\"return\", _context6.sent);\n        case 22:\n          _context6.prev = 22;\n          // initialize the stream event handlers\n          events[0] = onEvent(stream, 'end');\n          events[1] = onEvent(stream, 'error');\n        case 25:\n          events[2] = onEvent(stream, 'readable');\n          // wait on the first message event from the stream\n          _context6.next = 28;\n          return __await(Promise.race(events.map(function (x) {\n            return x[2];\n          })));\n        case 28:\n          _yield$__await = _context6.sent;\n          _yield$__await2 = _slicedToArray(_yield$__await, 2);\n          event = _yield$__await2[0];\n          err = _yield$__await2[1];\n          if (!(event === 'error')) {\n            _context6.next = 34;\n            break;\n          }\n          return _context6.abrupt(\"break\", 45);\n        case 34:\n          if (!(done = event === 'end')) {\n            // If the size is NaN, request to read everything in the stream's internal buffer\n            if (!Number.isFinite(size - bufferLength)) {\n              buffer = toUint8Array(stream['read']());\n            } else {\n              buffer = toUint8Array(stream['read'](size - bufferLength));\n              // If the byteLength is 0, then the requested amount is more than the stream has\n              // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n              // continue emitting readable events, so request to read everything the stream\n              // has in its internal buffer right now.\n              if (buffer.byteLength < size - bufferLength) {\n                buffer = toUint8Array(stream['read']());\n              }\n            }\n            // if chunk is not null or empty, push it onto the queue\n            if (buffer.byteLength > 0) {\n              buffers.push(buffer);\n              bufferLength += buffer.byteLength;\n            }\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context6.next = 44;\n            break;\n          }\n        case 36:\n          _context6.next = 38;\n          return __await(byteRange());\n        case 38:\n          _context6.next = 40;\n          return _context6.sent;\n        case 40:\n          _yield$yield$__await6 = _context6.sent;\n          cmd = _yield$yield$__await6.cmd;\n          size = _yield$yield$__await6.size;\n        case 43:\n          if (size < bufferLength) {\n            _context6.next = 36;\n            break;\n          }\n        case 44:\n          if (!done) {\n            _context6.next = 25;\n            break;\n          }\n        case 45:\n          _context6.prev = 45;\n          _context6.next = 48;\n          return __await(cleanup(events, event === 'error' ? err : null));\n        case 48:\n          return _context6.finish(45);\n        case 49:\n          _context6.next = 51;\n          return __await(null);\n        case 51:\n          return _context6.abrupt(\"return\", _context6.sent);\n        case 52:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, fromNodeStream_1, null, [[22,, 45, 49]]);\n  }));\n}","map":{"version":3,"names":["fromIterable","toUint8Array","joinUint8Arrays","toUint8ArrayIterator","toUint8ArrayAsyncIterator","source","pump","fromAsyncIterable","fromDOMStream","fromNodeStream","stream","toDOMStream","options","Error","toNodeStream","iterator","next","done","threw","buffers","buffer","cmd","size","bufferLength","byteRange","_yield","it","_ref","_yield$byteRange","_regeneratorRuntime","wrap","_fromIterable$","_context","prev","_byteRange","_joinUint8Arrays","_joinUint8Arrays2","_slicedToArray","sent","Symbol","Number","isNaN","value","byteLength","push","t0","throw","return","finish","abrupt","stop","_marked","_yield$yield$__await","_ref2","_yield$yield$__await2","fromAsyncIterable_1$","_context2","_byteRange2","_joinUint8Arrays3","_joinUint8Arrays4","__await","asyncIterator","t1","t2","t3","Uint8Array","_yield$yield$__await3","_ref3","_yield$yield$__await4","fromDOMStream_1$","_context3","_byteRange3","_joinUint8Arrays5","_joinUint8Arrays6","AdaptiveByteReader","releaseLock","_classCallCheck","reader","catch","_createClass","key","get","Promise","resolve","cancel","reason","_context4","_callee","read","_context5","result","_callee2","onEvent","event","handler","_","r","_yield$yield$__await5","_yield$__await","_yield$__await2","_yield$yield$__await6","cleanup","fromNodeStream_1$","_context6","_cleanup","events","err","reject","_iterator","_createForOfIteratorHelper","_step","s","n","_step$value","evt","fn","e","f","destroy","call","undefined","_byteRange4","_joinUint8Arrays7","_joinUint8Arrays8","race","map","x","isFinite"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/io/adapters.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer.js';\n\nimport { ReadableDOMStreamOptions } from './interfaces.js';\n\ntype Uint8ArrayGenerator = Generator<Uint8Array, null, { cmd: 'peek' | 'read'; size: number }>;\ntype AsyncUint8ArrayGenerator = AsyncGenerator<Uint8Array, null, { cmd: 'peek' | 'read'; size: number }>;\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): Uint8ArrayGenerator {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncUint8ArrayGenerator {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncUint8ArrayGenerator {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncUint8ArrayGenerator {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Uint8ArrayGenerator | AsyncUint8ArrayGenerator>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): Uint8ArrayGenerator {\n\n    let done: boolean | undefined, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any>null);\n\n    // initialize the iterator\n    const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ?\n                it.next() : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return(null!));\n    }\n    return null;\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncUint8ArrayGenerator {\n\n    let done: boolean | undefined, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = (yield <any>null)!);\n\n    // initialize the iterator\n    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                ? await it.next()\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return(new Uint8Array(0)));\n    }\n    return null;\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncUint8ArrayGenerator {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any>null);\n\n    // initialize the reader and lock the stream\n    const it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                ? await it['read']()\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n    return null;\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private reader: ReadableStreamDefaultReader<T> | null = null;\n\n    constructor(private source: ReadableStream<T>) {\n        this.reader = this.source['getReader']();\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.reader['closed'].catch(() => { });\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => { }) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => { }));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadValueResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) } as ReadableStreamReadValueResult<Uint8Array>;\n        }\n        const result = await this.reader!.read() as ReadableStreamReadValueResult<any>;\n        !result.done && (result.value = toUint8Array(result));\n        return result;\n    }\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    const handler = (_: any) => resolve([event, _]);\n    let resolve: (value: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncUint8ArrayGenerator {\n\n    const events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any>null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) {\n        yield new Uint8Array(0);\n        return null;\n    }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!Number.isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read']());\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if ((buffer as Uint8Array).byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read']());\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if ((buffer as Uint8Array).byteLength > 0) {\n                    buffers.push(buffer as Uint8Array);\n                    bufferLength += (buffer as Uint8Array).byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    return null;\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any>null;\n        return new Promise<void>((resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e as T || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}