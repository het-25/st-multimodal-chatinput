{"ast":null,"code":"import _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { UnionMode } from '../enum.mjs';\nimport { RecordBatch } from '../recordbatch.mjs';\nimport { rebaseValueOffsets } from '../util/buffer.mjs';\nimport { packBools, truncateBitmap } from '../util/bit.mjs';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message.mjs';\nimport { DataType } from '../type.mjs';\n/** @ignore */\nexport var VectorAssembler = /*#__PURE__*/function (_Visitor) {\n  _inherits(VectorAssembler, _Visitor);\n  var _super = _createSuper(VectorAssembler);\n  function VectorAssembler() {\n    var _this;\n    _classCallCheck(this, VectorAssembler);\n    _this = _super.call(this);\n    _this._byteLength = 0;\n    _this._nodes = [];\n    _this._buffers = [];\n    _this._bufferRegions = [];\n    return _this;\n  }\n  /** @nocollapse */\n  _createClass(VectorAssembler, [{\n    key: \"visit\",\n    value: function visit(data) {\n      if (data instanceof Vector) {\n        this.visitMany(data.data);\n        return this;\n      }\n      var type = data.type;\n      if (!DataType.isDictionary(type)) {\n        var length = data.length,\n          nullCount = data.nullCount;\n        if (length > 2147483647) {\n          /* istanbul ignore next */\n          throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n        }\n        if (!DataType.isNull(type)) {\n          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) // placeholder validity buffer\n          : truncateBitmap(data.offset, length, data.nullBitmap));\n        }\n        this.nodes.push(new FieldNode(length, nullCount));\n      }\n      return _get(_getPrototypeOf(VectorAssembler.prototype), \"visit\", this).call(this, data);\n    }\n  }, {\n    key: \"visitNull\",\n    value: function visitNull(_null) {\n      return this;\n    }\n  }, {\n    key: \"visitDictionary\",\n    value: function visitDictionary(data) {\n      // Assemble the indices here, Dictionary assembled separately.\n      return this.visit(data.clone(data.type.indices));\n    }\n  }, {\n    key: \"nodes\",\n    get: function get() {\n      return this._nodes;\n    }\n  }, {\n    key: \"buffers\",\n    get: function get() {\n      return this._buffers;\n    }\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      return this._byteLength;\n    }\n  }, {\n    key: \"bufferRegions\",\n    get: function get() {\n      return this._bufferRegions;\n    }\n  }], [{\n    key: \"assemble\",\n    value: function assemble() {\n      var unwrap = function unwrap(nodes) {\n        return nodes.flatMap(function (node) {\n          return Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data;\n        });\n      };\n      var assembler = new VectorAssembler();\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      assembler.visitMany(unwrap(args));\n      return assembler;\n    }\n  }]);\n  return VectorAssembler;\n}(Visitor);\n/** @ignore */\nfunction addBuffer(values) {\n  var byteLength = values.byteLength + 7 & ~7; // Round up to a multiple of 8\n  this.buffers.push(values);\n  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n  this._byteLength += byteLength;\n  return this;\n}\n/** @ignore */\nfunction assembleUnion(data) {\n  var type = data.type,\n    length = data.length,\n    typeIds = data.typeIds,\n    valueOffsets = data.valueOffsets;\n  // All Union Vectors have a typeIds buffer\n  addBuffer.call(this, typeIds);\n  // If this is a Sparse Union, treat it like all other Nested types\n  if (type.mode === UnionMode.Sparse) {\n    return assembleNestedVector.call(this, data);\n  } else if (type.mode === UnionMode.Dense) {\n    // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n    if (data.offset <= 0) {\n      // If the Vector hasn't been sliced, write the existing valueOffsets\n      addBuffer.call(this, valueOffsets);\n      // We can treat this like all other Nested types\n      return assembleNestedVector.call(this, data);\n    } else {\n      // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n      // each child vector, we need to \"rebase\" the valueOffsets for each child\n      // Union typeIds are not necessary 0-indexed\n      var maxChildTypeId = typeIds.reduce(function (x, y) {\n        return Math.max(x, y);\n      }, typeIds[0]);\n      var childLengths = new Int32Array(maxChildTypeId + 1);\n      // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\n      var childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n      var shiftedOffsets = new Int32Array(length);\n      // If we have a non-zero offset, then the value offsets do not start at\n      // zero. We must a) create a new offsets array with shifted offsets and\n      // b) slice the values array accordingly\n      var unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\n      for (var typeId, shift, index = -1; ++index < length;) {\n        if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\n          shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n        }\n        shiftedOffsets[index] = unshiftedOffsets[index] - shift;\n        ++childLengths[typeId];\n      }\n      addBuffer.call(this, shiftedOffsets);\n      // Slice and visit children accordingly\n      for (var child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\n        if (child = data.children[childIndex]) {\n          var _typeId = type.typeIds[childIndex];\n          var childLength = Math.min(length, childLengths[_typeId]);\n          this.visit(child.slice(childOffsets[_typeId], childLength));\n        }\n      }\n    }\n  }\n  return this;\n}\n/** @ignore */\nfunction assembleBoolVector(data) {\n  // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n  var values;\n  if (data.nullCount >= data.length) {\n    // If all values are null, just insert a placeholder empty data buffer (fastest path)\n    return addBuffer.call(this, new Uint8Array(0));\n  } else if ((values = data.values) instanceof Uint8Array) {\n    // If values is already a Uint8Array, slice the bitmap (fast path)\n    return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));\n  }\n  // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n  // values as bools and re-pack them into a Uint8Array. This code isn't\n  // reachable unless you're trying to manipulate the Data internals,\n  // we're only doing this for safety.\n  /* istanbul ignore next */\n  return addBuffer.call(this, packBools(data.values));\n}\n/** @ignore */\nfunction assembleFlatVector(data) {\n  return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\n/** @ignore */\nfunction assembleFlatListVector(data) {\n  var length = data.length,\n    values = data.values,\n    valueOffsets = data.valueOffsets;\n  var firstOffset = valueOffsets[0];\n  var lastOffset = valueOffsets[length];\n  var byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\n  // Push in the order FlatList types read their buffers\n  addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\n  addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\n  return this;\n}\n/** @ignore */\nfunction assembleListVector(data) {\n  var length = data.length,\n    valueOffsets = data.valueOffsets;\n  // If we have valueOffsets (MapVector, ListVector), push that buffer first\n  if (valueOffsets) {\n    addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\n  }\n  // Then insert the List's values child\n  return this.visit(data.children[0]);\n}\n/** @ignore */\nfunction assembleNestedVector(data) {\n  return this.visitMany(data.type.children.map(function (_, i) {\n    return data.children[i];\n  }).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;","map":{"version":3,"names":["Vector","Visitor","UnionMode","RecordBatch","rebaseValueOffsets","packBools","truncateBitmap","BufferRegion","FieldNode","DataType","VectorAssembler","_Visitor","_inherits","_super","_createSuper","_this","_classCallCheck","call","_byteLength","_nodes","_buffers","_bufferRegions","_createClass","key","value","visit","data","visitMany","type","isDictionary","length","nullCount","RangeError","isNull","addBuffer","Uint8Array","offset","nullBitmap","nodes","push","_get","_getPrototypeOf","prototype","visitNull","_null","visitDictionary","clone","indices","get","assemble","unwrap","flatMap","node","Array","isArray","children","assembler","_len","arguments","args","_key","values","byteLength","buffers","bufferRegions","assembleUnion","typeIds","valueOffsets","mode","Sparse","assembleNestedVector","Dense","maxChildTypeId","reduce","x","y","Math","max","childLengths","Int32Array","childOffsets","fill","shiftedOffsets","unshiftedOffsets","typeId","shift","index","child","childIndex","numChildren","childLength","min","slice","assembleBoolVector","assembleFlatVector","subarray","stride","assembleFlatListVector","firstOffset","lastOffset","assembleListVector","map","_","i","filter","Boolean","visitBool","visitInt","visitFloat","visitUtf8","visitBinary","visitFixedSizeBinary","visitDate","visitTimestamp","visitTime","visitDecimal","visitList","visitStruct","visitUnion","visitInterval","visitFixedSizeList","visitMap"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/visitor/vectorassembler.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data.js';\nimport { Vector } from '../vector.js';\nimport { Visitor } from '../visitor.js';\nimport { Type, UnionMode } from '../enum.js';\nimport { RecordBatch } from '../recordbatch.js';\nimport { TypeToDataType } from '../interfaces.js';\nimport { rebaseValueOffsets } from '../util/buffer.js';\nimport { packBools, truncateBitmap } from '../util/bit.js';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message.js';\nimport {\n    DataType, Dictionary,\n    Float, Int, Date_, Interval, Time, Timestamp, Union,\n    Bool, Null, Utf8, Binary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct,\n} from '../type.js';\n\n/** @ignore */\nexport interface VectorAssembler extends Visitor {\n    visit<T extends DataType>(node: Vector<T> | Data<T>): this;\n    visitMany<T extends DataType>(nodes: readonly Data<T>[]): this[];\n    getVisitFn<T extends Type>(node: T): (data: Data<TypeToDataType<T>>) => this;\n    getVisitFn<T extends DataType>(node: Vector<T> | Data<T> | T): (data: Data<T>) => this;\n\n    visitBool<T extends Bool>(data: Data<T>): this;\n    visitInt<T extends Int>(data: Data<T>): this;\n    visitFloat<T extends Float>(data: Data<T>): this;\n    visitUtf8<T extends Utf8>(data: Data<T>): this;\n    visitBinary<T extends Binary>(data: Data<T>): this;\n    visitFixedSizeBinary<T extends FixedSizeBinary>(data: Data<T>): this;\n    visitDate<T extends Date_>(data: Data<T>): this;\n    visitTimestamp<T extends Timestamp>(data: Data<T>): this;\n    visitTime<T extends Time>(data: Data<T>): this;\n    visitDecimal<T extends Decimal>(data: Data<T>): this;\n    visitList<T extends List>(data: Data<T>): this;\n    visitStruct<T extends Struct>(data: Data<T>): this;\n    visitUnion<T extends Union>(data: Data<T>): this;\n    visitInterval<T extends Interval>(data: Data<T>): this;\n    visitFixedSizeList<T extends FixedSizeList>(data: Data<T>): this;\n    visitMap<T extends Map_>(data: Data<T>): this;\n}\n\n/** @ignore */\nexport class VectorAssembler extends Visitor {\n\n    /** @nocollapse */\n    public static assemble<T extends Vector | RecordBatch>(...args: (T | T[])[]) {\n        const unwrap = (nodes: (T | T[])[]): Data[] =>\n            nodes.flatMap((node: T | T[]) => Array.isArray(node) ? unwrap(node) :\n                (node instanceof RecordBatch) ? node.data.children : node.data);\n        const assembler = new VectorAssembler();\n        assembler.visitMany(unwrap(args));\n        return assembler;\n    }\n\n    private constructor() { super(); }\n\n    public visit<T extends DataType>(data: Vector<T> | Data<T>): this {\n        if (data instanceof Vector) {\n            this.visitMany(data.data);\n            return this;\n        }\n        const { type } = data;\n        if (!DataType.isDictionary(type)) {\n            const { length, nullCount } = data;\n            if (length > 2147483647) {\n                /* istanbul ignore next */\n                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n            }\n            if (!DataType.isNull(type)) {\n                addBuffer.call(this, nullCount <= 0\n                    ? new Uint8Array(0) // placeholder validity buffer\n                    : truncateBitmap(data.offset, length, data.nullBitmap)\n                );\n            }\n            this.nodes.push(new FieldNode(length, nullCount));\n        }\n        return super.visit(data);\n    }\n\n    public visitNull<T extends Null>(_null: Data<T>) {\n        return this;\n    }\n\n    public visitDictionary<T extends Dictionary>(data: Data<T>) {\n        // Assemble the indices here, Dictionary assembled separately.\n        return this.visit(data.clone(data.type.indices));\n    }\n\n    public get nodes() { return this._nodes; }\n    public get buffers() { return this._buffers; }\n    public get byteLength() { return this._byteLength; }\n    public get bufferRegions() { return this._bufferRegions; }\n\n    protected _byteLength = 0;\n    protected _nodes: FieldNode[] = [];\n    protected _buffers: ArrayBufferView[] = [];\n    protected _bufferRegions: BufferRegion[] = [];\n}\n\n/** @ignore */\nfunction addBuffer(this: VectorAssembler, values: ArrayBufferView) {\n    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8\n    this.buffers.push(values);\n    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n    this._byteLength += byteLength;\n    return this;\n}\n\n/** @ignore */\nfunction assembleUnion<T extends Union>(this: VectorAssembler, data: Data<T>) {\n    const { type, length, typeIds, valueOffsets } = data;\n    // All Union Vectors have a typeIds buffer\n    addBuffer.call(this, typeIds);\n    // If this is a Sparse Union, treat it like all other Nested types\n    if (type.mode === UnionMode.Sparse) {\n        return assembleNestedVector.call(this, data);\n    } else if (type.mode === UnionMode.Dense) {\n        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n        if (data.offset <= 0) {\n            // If the Vector hasn't been sliced, write the existing valueOffsets\n            addBuffer.call(this, valueOffsets);\n            // We can treat this like all other Nested types\n            return assembleNestedVector.call(this, data);\n        } else {\n            // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n            // each child vector, we need to \"rebase\" the valueOffsets for each child\n            // Union typeIds are not necessary 0-indexed\n            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);\n            const childLengths = new Int32Array(maxChildTypeId + 1);\n            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\n            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n            const shiftedOffsets = new Int32Array(length);\n            // If we have a non-zero offset, then the value offsets do not start at\n            // zero. We must a) create a new offsets array with shifted offsets and\n            // b) slice the values array accordingly\n            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\n            for (let typeId, shift, index = -1; ++index < length;) {\n                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\n                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n                }\n                shiftedOffsets[index] = unshiftedOffsets[index] - shift;\n                ++childLengths[typeId];\n            }\n            addBuffer.call(this, shiftedOffsets);\n            // Slice and visit children accordingly\n            for (let child: Data | null, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\n                if (child = data.children[childIndex]) {\n                    const typeId = type.typeIds[childIndex];\n                    const childLength = Math.min(length, childLengths[typeId]);\n                    this.visit(child.slice(childOffsets[typeId], childLength));\n                }\n            }\n        }\n    }\n    return this;\n}\n\n/** @ignore */\nfunction assembleBoolVector<T extends Bool>(this: VectorAssembler, data: Data<T>) {\n    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n    let values: Uint8Array;\n    if (data.nullCount >= data.length) {\n        // If all values are null, just insert a placeholder empty data buffer (fastest path)\n        return addBuffer.call(this, new Uint8Array(0));\n    } else if ((values = data.values) instanceof Uint8Array) {\n        // If values is already a Uint8Array, slice the bitmap (fast path)\n        return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));\n    }\n    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n    // values as bools and re-pack them into a Uint8Array. This code isn't\n    // reachable unless you're trying to manipulate the Data internals,\n    // we're only doing this for safety.\n    /* istanbul ignore next */\n    return addBuffer.call(this, packBools(data.values));\n}\n\n/** @ignore */\nfunction assembleFlatVector<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval>(this: VectorAssembler, data: Data<T>) {\n    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\n\n/** @ignore */\nfunction assembleFlatListVector<T extends Utf8 | Binary>(this: VectorAssembler, data: Data<T>) {\n    const { length, values, valueOffsets } = data;\n    const firstOffset = valueOffsets[0];\n    const lastOffset = valueOffsets[length];\n    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\n    // Push in the order FlatList types read their buffers\n    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\n    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\n    return this;\n}\n\n/** @ignore */\nfunction assembleListVector<T extends Map_ | List | FixedSizeList>(this: VectorAssembler, data: Data<T>) {\n    const { length, valueOffsets } = data;\n    // If we have valueOffsets (MapVector, ListVector), push that buffer first\n    if (valueOffsets) {\n        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\n    }\n    // Then insert the List's values child\n    return this.visit(data.children[0]);\n}\n\n/** @ignore */\nfunction assembleNestedVector<T extends Struct | Union>(this: VectorAssembler, data: Data<T>) {\n    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\n}\n\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}