{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Buffer } from './buffer.mjs';\nimport { Int } from './int.mjs';\nimport { SparseMatrixCompressedAxis } from './sparse-matrix-compressed-axis.mjs';\n/**\n * Compressed Sparse format, that is matrix-specific.\n */\nexport class SparseMatrixIndexCSX {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  static getRootAsSparseMatrixIndexCSX(bb, obj) {\n    return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  static getSizePrefixedRootAsSparseMatrixIndexCSX(bb, obj) {\n    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n    return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  /**\n   * Which axis, row or column, is compressed\n   */\n  compressedAxis() {\n    const offset = this.bb.__offset(this.bb_pos, 4);\n    return offset ? this.bb.readInt16(this.bb_pos + offset) : SparseMatrixCompressedAxis.Row;\n  }\n  /**\n   * The type of values in indptrBuffer\n   */\n  indptrType(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  /**\n   * indptrBuffer stores the location and size of indptr array that\n   * represents the range of the rows.\n   * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.\n   * The length of this array is 1 + (the number of rows), and the type\n   * of index value is long.\n   *\n   * For example, let X be the following 6x4 matrix:\n   * ```text\n   *   X := [[0, 1, 2, 0],\n   *         [0, 0, 3, 0],\n   *         [0, 4, 0, 5],\n   *         [0, 0, 0, 0],\n   *         [6, 0, 7, 8],\n   *         [0, 9, 0, 0]].\n   * ```\n   * The array of non-zero values in X is:\n   * ```text\n   *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].\n   * ```\n   * And the indptr of X is:\n   * ```text\n   *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].\n   * ```\n   */\n  indptrBuffer(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb) : null;\n  }\n  /**\n   * The type of values in indicesBuffer\n   */\n  indicesType(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  /**\n   * indicesBuffer stores the location and size of the array that\n   * contains the column indices of the corresponding non-zero values.\n   * The type of index value is long.\n   *\n   * For example, the indices of the above X is:\n   * ```text\n   *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].\n   * ```\n   * Note that the indices are sorted in lexicographical order for each row.\n   */\n  indicesBuffer(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 12);\n    return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb) : null;\n  }\n  static startSparseMatrixIndexCSX(builder) {\n    builder.startObject(5);\n  }\n  static addCompressedAxis(builder, compressedAxis) {\n    builder.addFieldInt16(0, compressedAxis, SparseMatrixCompressedAxis.Row);\n  }\n  static addIndptrType(builder, indptrTypeOffset) {\n    builder.addFieldOffset(1, indptrTypeOffset, 0);\n  }\n  static addIndptrBuffer(builder, indptrBufferOffset) {\n    builder.addFieldStruct(2, indptrBufferOffset, 0);\n  }\n  static addIndicesType(builder, indicesTypeOffset) {\n    builder.addFieldOffset(3, indicesTypeOffset, 0);\n  }\n  static addIndicesBuffer(builder, indicesBufferOffset) {\n    builder.addFieldStruct(4, indicesBufferOffset, 0);\n  }\n  static endSparseMatrixIndexCSX(builder) {\n    const offset = builder.endObject();\n    builder.requiredField(offset, 6); // indptrType\n    builder.requiredField(offset, 8); // indptrBuffer\n    builder.requiredField(offset, 10); // indicesType\n    builder.requiredField(offset, 12); // indicesBuffer\n    return offset;\n  }\n}","map":{"version":3,"names":["flatbuffers","Buffer","Int","SparseMatrixCompressedAxis","SparseMatrixIndexCSX","constructor","bb","bb_pos","__init","i","getRootAsSparseMatrixIndexCSX","obj","readInt32","position","getSizePrefixedRootAsSparseMatrixIndexCSX","setPosition","SIZE_PREFIX_LENGTH","compressedAxis","offset","__offset","readInt16","Row","indptrType","__indirect","indptrBuffer","indicesType","indicesBuffer","startSparseMatrixIndexCSX","builder","startObject","addCompressedAxis","addFieldInt16","addIndptrType","indptrTypeOffset","addFieldOffset","addIndptrBuffer","indptrBufferOffset","addFieldStruct","addIndicesType","indicesTypeOffset","addIndicesBuffer","indicesBufferOffset","endSparseMatrixIndexCSX","endObject","requiredField"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/template/my_component/frontend/node_modules/apache-arrow/src/fb/sparse-matrix-index-c-s-x.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { Buffer } from './buffer.js';\nimport { Int } from './int.js';\nimport { SparseMatrixCompressedAxis } from './sparse-matrix-compressed-axis.js';\n\n\n/**\n * Compressed Sparse format, that is matrix-specific.\n */\nexport class SparseMatrixIndexCSX {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):SparseMatrixIndexCSX {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsSparseMatrixIndexCSX(bb:flatbuffers.ByteBuffer, obj?:SparseMatrixIndexCSX):SparseMatrixIndexCSX {\n  return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsSparseMatrixIndexCSX(bb:flatbuffers.ByteBuffer, obj?:SparseMatrixIndexCSX):SparseMatrixIndexCSX {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\n/**\n * Which axis, row or column, is compressed\n */\ncompressedAxis():SparseMatrixCompressedAxis {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.readInt16(this.bb_pos + offset) : SparseMatrixCompressedAxis.Row;\n}\n\n/**\n * The type of values in indptrBuffer\n */\nindptrType(obj?:Int):Int|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * indptrBuffer stores the location and size of indptr array that\n * represents the range of the rows.\n * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.\n * The length of this array is 1 + (the number of rows), and the type\n * of index value is long.\n *\n * For example, let X be the following 6x4 matrix:\n * ```text\n *   X := [[0, 1, 2, 0],\n *         [0, 0, 3, 0],\n *         [0, 4, 0, 5],\n *         [0, 0, 0, 0],\n *         [6, 0, 7, 8],\n *         [0, 9, 0, 0]].\n * ```\n * The array of non-zero values in X is:\n * ```text\n *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].\n * ```\n * And the indptr of X is:\n * ```text\n *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].\n * ```\n */\nindptrBuffer(obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb!) : null;\n}\n\n/**\n * The type of values in indicesBuffer\n */\nindicesType(obj?:Int):Int|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * indicesBuffer stores the location and size of the array that\n * contains the column indices of the corresponding non-zero values.\n * The type of index value is long.\n *\n * For example, the indices of the above X is:\n * ```text\n *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].\n * ```\n * Note that the indices are sorted in lexicographical order for each row.\n */\nindicesBuffer(obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb!) : null;\n}\n\nstatic startSparseMatrixIndexCSX(builder:flatbuffers.Builder) {\n  builder.startObject(5);\n}\n\nstatic addCompressedAxis(builder:flatbuffers.Builder, compressedAxis:SparseMatrixCompressedAxis) {\n  builder.addFieldInt16(0, compressedAxis, SparseMatrixCompressedAxis.Row);\n}\n\nstatic addIndptrType(builder:flatbuffers.Builder, indptrTypeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, indptrTypeOffset, 0);\n}\n\nstatic addIndptrBuffer(builder:flatbuffers.Builder, indptrBufferOffset:flatbuffers.Offset) {\n  builder.addFieldStruct(2, indptrBufferOffset, 0);\n}\n\nstatic addIndicesType(builder:flatbuffers.Builder, indicesTypeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(3, indicesTypeOffset, 0);\n}\n\nstatic addIndicesBuffer(builder:flatbuffers.Builder, indicesBufferOffset:flatbuffers.Offset) {\n  builder.addFieldStruct(4, indicesBufferOffset, 0);\n}\n\nstatic endSparseMatrixIndexCSX(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  builder.requiredField(offset, 6) // indptrType\n  builder.requiredField(offset, 8) // indptrBuffer\n  builder.requiredField(offset, 10) // indicesType\n  builder.requiredField(offset, 12) // indicesBuffer\n  return offset;\n}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}