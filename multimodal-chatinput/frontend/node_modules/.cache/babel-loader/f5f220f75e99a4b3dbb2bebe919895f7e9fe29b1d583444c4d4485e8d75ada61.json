{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Data, makeData } from './data.mjs';\nimport { Table } from './table.mjs';\nimport { Vector } from './vector.mjs';\nimport { Schema, Field } from './schema.mjs';\nimport { DataType, Struct, Null } from './type.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.mjs';\n/** @ignore */\nexport class RecordBatch {\n  constructor(...args) {\n    switch (args.length) {\n      case 2:\n        {\n          [this.schema] = args;\n          if (!(this.schema instanceof Schema)) {\n            throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n          }\n          [, this.data = makeData({\n            nullCount: 0,\n            type: new Struct(this.schema.fields),\n            children: this.schema.fields.map(f => makeData({\n              type: f.type,\n              nullCount: 0\n            }))\n          })] = args;\n          if (!(this.data instanceof Data)) {\n            throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n          }\n          [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);\n          break;\n        }\n      case 1:\n        {\n          const [obj] = args;\n          const {\n            fields,\n            children,\n            length\n          } = Object.keys(obj).reduce((memo, name, i) => {\n            memo.children[i] = obj[name];\n            memo.length = Math.max(memo.length, obj[name].length);\n            memo.fields[i] = Field.new({\n              name,\n              type: obj[name].type,\n              nullable: true\n            });\n            return memo;\n          }, {\n            length: 0,\n            fields: new Array(),\n            children: new Array()\n          });\n          const schema = new Schema(fields);\n          const data = makeData({\n            type: new Struct(fields),\n            length,\n            children,\n            nullCount: 0\n          });\n          [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);\n          break;\n        }\n      default:\n        throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n    }\n  }\n  get dictionaries() {\n    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n  }\n  /**\n   * The number of columns in this RecordBatch.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this RecordBatch.\n   */\n  get numRows() {\n    return this.data.length;\n  }\n  /**\n   * The number of null rows in this RecordBatch.\n   */\n  get nullCount() {\n    return this.data.nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  isValid(index) {\n    return this.data.getValid(index);\n  }\n  /**\n   * Get a row by position.\n   * @param index The index of the element to read.\n   */\n  get(index) {\n    return getVisitor.visit(this.data, index);\n  }\n  /**\n   * Set a row by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  set(index, value) {\n    return setVisitor.visit(this.data, index, value);\n  }\n  /**\n   * Retrieve the index of the first occurrence of a row in an RecordBatch.\n   * @param element The row to locate in the RecordBatch.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  indexOf(element, offset) {\n    return indexOfVisitor.visit(this.data, element, offset);\n  }\n  /**\n   * Get the size (in bytes) of a row by index.\n   * @param index The row index for which to compute the byteLength.\n   */\n  getByteLength(index) {\n    return byteLengthVisitor.visit(this.data, index);\n  }\n  /**\n   * Iterator for rows in this RecordBatch.\n   */\n  [Symbol.iterator]() {\n    return iteratorVisitor.visit(new Vector([this.data]));\n  }\n  /**\n   * Return a JavaScript Array of the RecordBatch rows.\n   * @returns An Array of RecordBatch rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Combines two or more RecordBatch of the same schema.\n   * @param others Additional RecordBatch to add to the end of this RecordBatch.\n   */\n  concat(...others) {\n    return new Table(this.schema, [this, ...others]);\n  }\n  /**\n   * Return a zero-copy sub-section of this RecordBatch.\n   * @param start The beginning of the specified portion of the RecordBatch.\n   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const [slice] = new Vector([this.data]).slice(begin, end).data;\n    return new RecordBatch(this.schema, slice);\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b;\n    return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(f => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index) {\n    if (index > -1 && index < this.schema.fields.length) {\n      return new Vector([this.data.children[index]]);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   * @param name The name of the child to overwrite.\n   * @returns A new RecordBatch with the new child for the specified name.\n   */\n  setChild(name, child) {\n    var _b;\n    return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(f => f.name === name), child);\n  }\n  setChildAt(index, child) {\n    let schema = this.schema;\n    let data = this.data;\n    if (index > -1 && index < this.numCols) {\n      if (!child) {\n        child = new Vector([makeData({\n          type: new Null(),\n          length: this.numRows\n        })]);\n      }\n      const fields = schema.fields.slice();\n      const children = data.children.slice();\n      const field = fields[index].clone({\n        type: child.type\n      });\n      [fields[index], children[index]] = [field, child.data[0]];\n      schema = new Schema(fields, new Map(this.schema.metadata));\n      data = makeData({\n        type: new Struct(fields),\n        children\n      });\n    }\n    return new RecordBatch(schema, data);\n  }\n  /**\n   * Construct a new RecordBatch containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new RecordBatch of columns matching the specified names.\n   */\n  select(columnNames) {\n    const schema = this.schema.select(columnNames);\n    const type = new Struct(schema.fields);\n    const children = [];\n    for (const name of columnNames) {\n      const index = this.schema.fields.findIndex(f => f.name === name);\n      if (~index) {\n        children[index] = this.data.children[index];\n      }\n    }\n    return new RecordBatch(schema, makeData({\n      type,\n      length: this.numRows,\n      children\n    }));\n  }\n  /**\n   * Construct a new RecordBatch containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new RecordBatch of columns matching at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const children = columnIndices.map(i => this.data.children[i]).filter(Boolean);\n    const subset = makeData({\n      type: new Struct(schema.fields),\n      length: this.numRows,\n      children\n    });\n    return new RecordBatch(schema, subset);\n  }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nRecordBatch[_a] = (proto => {\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  return 'RecordBatch';\n})(RecordBatch.prototype);\n/** @ignore */\nfunction ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {\n  var _b;\n  const fields = [...schema.fields];\n  const children = [...chunks];\n  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;\n  for (const [idx, field] of schema.fields.entries()) {\n    const chunk = chunks[idx];\n    if (!chunk || chunk.length !== maxLength) {\n      fields[idx] = field.clone({\n        nullable: true\n      });\n      children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : makeData({\n        type: field.type,\n        length: maxLength,\n        nullCount: maxLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return [schema.assign(fields), makeData({\n    type: new Struct(fields),\n    length: maxLength,\n    children\n  })];\n}\n/** @ignore */\nfunction collectDictionaries(fields, children, dictionaries = new Map()) {\n  for (let i = -1, n = fields.length; ++i < n;) {\n    const field = fields[i];\n    const type = field.type;\n    const data = children[i];\n    if (DataType.isDictionary(type)) {\n      if (!dictionaries.has(type.id)) {\n        if (data.dictionary) {\n          dictionaries.set(type.id, data.dictionary);\n        }\n      } else if (dictionaries.get(type.id) !== data.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type.children && type.children.length > 0) {\n      collectDictionaries(type.children, data.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {\n  constructor(schema) {\n    const children = schema.fields.map(f => makeData({\n      type: f.type\n    }));\n    const data = makeData({\n      type: new Struct(schema.fields),\n      nullCount: 0,\n      children\n    });\n    super(schema, data);\n  }\n}","map":{"version":3,"names":["Data","makeData","Table","Vector","Schema","Field","DataType","Struct","Null","instance","getVisitor","setVisitor","indexOfVisitor","iteratorVisitor","byteLengthVisitor","RecordBatch","constructor","args","length","schema","TypeError","data","nullCount","type","fields","children","map","f","ensureSameLengthData","obj","Object","keys","reduce","memo","name","i","Math","max","new","nullable","Array","dictionaries","_dictionaries","collectDictionaries","numCols","numRows","isValid","index","getValid","get","visit","set","value","indexOf","element","offset","getByteLength","Symbol","iterator","toArray","concat","others","slice","begin","end","getChild","getChildAt","_b","findIndex","setChild","child","setChildAt","field","clone","Map","metadata","select","columnNames","selectAt","columnIndices","filter","Boolean","subset","toStringTag","_a","proto","_nullCount","isConcatSpreadable","prototype","chunks","maxLength","col","nullBitmapSize","idx","entries","chunk","_changeLengthAndBackfillNullBitmap","nullBitmap","Uint8Array","assign","n","isDictionary","has","id","dictionary","Error","_InternalEmptyPlaceholderRecordBatch"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/template/my_component/frontend/node_modules/apache-arrow/src/recordbatch.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data, makeData } from './data.js';\nimport { Table } from './table.js';\nimport { Vector } from './vector.js';\nimport { Schema, Field } from './schema.js';\nimport { DataType, Struct, Null, TypeMap } from './type.js';\n\nimport { instance as getVisitor } from './visitor/get.js';\nimport { instance as setVisitor } from './visitor/set.js';\nimport { instance as indexOfVisitor } from './visitor/indexof.js';\nimport { instance as iteratorVisitor } from './visitor/iterator.js';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.js';\n\n/** @ignore */\nexport interface RecordBatch<T extends TypeMap = any> {\n    ///\n    // Virtual properties for the TypeScript compiler.\n    // These do not exist at runtime.\n    ///\n    readonly TType: Struct<T>;\n    readonly TArray: Struct<T>['TArray'];\n    readonly TValue: Struct<T>['TValue'];\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable\n     */\n    [Symbol.isConcatSpreadable]: true;\n}\n\n/** @ignore */\nexport class RecordBatch<T extends TypeMap = any> {\n\n    constructor(columns: { [P in keyof T]: Data<T[P]> });\n    constructor(schema: Schema<T>, data?: Data<Struct<T>>);\n    constructor(...args: any[]) {\n        switch (args.length) {\n            case 2: {\n                [this.schema] = args;\n                if (!(this.schema instanceof Schema)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [,\n                    this.data = makeData({\n                        nullCount: 0,\n                        type: new Struct<T>(this.schema.fields),\n                        children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n                    })\n                ] = args;\n                if (!(this.data instanceof Data)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [this.schema, this.data] = ensureSameLengthData<T>(this.schema, this.data.children as Data<T[keyof T]>[]);\n                break;\n            }\n            case 1: {\n                const [obj] = args;\n                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {\n                    memo.children[i] = obj[name];\n                    memo.length = Math.max(memo.length, obj[name].length);\n                    memo.fields[i] = Field.new({ name, type: obj[name].type, nullable: true });\n                    return memo;\n                }, {\n                    length: 0,\n                    fields: new Array<Field<T[keyof T]>>(),\n                    children: new Array<Data<T[keyof T]>>(),\n                });\n\n                const schema = new Schema<T>(fields);\n                const data = makeData({ type: new Struct<T>(fields), length, children, nullCount: 0 });\n                [this.schema, this.data] = ensureSameLengthData<T>(schema, data.children as Data<T[keyof T]>[], length);\n                break;\n            }\n            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n        }\n    }\n\n    protected _dictionaries?: Map<number, Vector>;\n\n    public readonly schema: Schema<T>;\n    public readonly data: Data<Struct<T>>;\n\n    public get dictionaries() {\n        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n    }\n\n    /**\n     * The number of columns in this RecordBatch.\n     */\n    public get numCols() { return this.schema.fields.length; }\n\n    /**\n     * The number of rows in this RecordBatch.\n     */\n    public get numRows() { return this.data.length; }\n\n    /**\n     * The number of null rows in this RecordBatch.\n     */\n    public get nullCount() {\n        return this.data.nullCount;\n    }\n\n    /**\n     * Check whether an element is null.\n     * @param index The index at which to read the validity bitmap.\n     */\n    public isValid(index: number) {\n        return this.data.getValid(index);\n    }\n\n    /**\n     * Get a row by position.\n     * @param index The index of the element to read.\n     */\n    public get(index: number) {\n        return getVisitor.visit(this.data, index);\n    }\n\n    /**\n     * Set a row by position.\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    public set(index: number, value: Struct<T>['TValue']) {\n        return setVisitor.visit(this.data, index, value);\n    }\n\n    /**\n     * Retrieve the index of the first occurrence of a row in an RecordBatch.\n     * @param element The row to locate in the RecordBatch.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    public indexOf(element: Struct<T>['TValue'], offset?: number): number {\n        return indexOfVisitor.visit(this.data, element, offset);\n    }\n\n    /**\n     * Get the size (in bytes) of a row by index.\n     * @param index The row index for which to compute the byteLength.\n     */\n    public getByteLength(index: number): number {\n        return byteLengthVisitor.visit(this.data, index);\n    }\n\n    /**\n     * Iterator for rows in this RecordBatch.\n     */\n    public [Symbol.iterator]() {\n        return iteratorVisitor.visit(new Vector([this.data])) as IterableIterator<Struct<T>['TValue']>;\n    }\n\n    /**\n     * Return a JavaScript Array of the RecordBatch rows.\n     * @returns An Array of RecordBatch rows.\n     */\n    public toArray() {\n        return [...this];\n    }\n\n    /**\n     * Combines two or more RecordBatch of the same schema.\n     * @param others Additional RecordBatch to add to the end of this RecordBatch.\n     */\n    public concat(...others: RecordBatch<T>[]) {\n        return new Table(this.schema, [this, ...others]);\n    }\n\n    /**\n     * Return a zero-copy sub-section of this RecordBatch.\n     * @param start The beginning of the specified portion of the RecordBatch.\n     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n     */\n    public slice(begin?: number, end?: number): RecordBatch<T> {\n        const [slice] = new Vector([this.data]).slice(begin, end).data;\n        return new RecordBatch(this.schema, slice);\n    }\n\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     * @param name The name of the child to retrieve.\n     */\n    public getChild<P extends keyof T>(name: P) {\n        return this.getChildAt<T[P]>(this.schema.fields?.findIndex((f) => f.name === name));\n    }\n\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     * @param index The index of the child to retrieve.\n     */\n    public getChildAt<R extends DataType = any>(index: number): Vector<R> | null {\n        if (index > -1 && index < this.schema.fields.length) {\n            return new Vector([this.data.children[index]]) as Vector<R>;\n        }\n        return null;\n    }\n\n    /**\n     * Sets a child Vector by name.\n     * @param name The name of the child to overwrite.\n     * @returns A new RecordBatch with the new child for the specified name.\n     */\n    public setChild<P extends keyof T, R extends DataType>(name: P, child: Vector<R>) {\n        return this.setChildAt(this.schema.fields?.findIndex((f) => f.name === name), child) as RecordBatch<T & { [K in P]: R }>;\n    }\n\n    /**\n     * Sets a child Vector by index.\n     * @param index The index of the child to overwrite.\n     * @returns A new RecordBatch with the new child at the specified index.\n     */\n    public setChildAt(index: number, child?: null): RecordBatch;\n    public setChildAt<R extends DataType = any>(index: number, child: Vector<R>): RecordBatch;\n    public setChildAt(index: number, child: any) {\n        let schema: Schema = this.schema;\n        let data: Data<Struct> = this.data;\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice() as Field<any>[];\n            const children = data.children.slice() as Data<any>[];\n            const field = fields[index].clone({ type: child.type });\n            [fields[index], children[index]] = [field, child.data[0]];\n            schema = new Schema(fields, new Map(this.schema.metadata));\n            data = makeData({ type: new Struct<T>(fields), children });\n        }\n        return new RecordBatch(schema, data);\n    }\n\n    /**\n     * Construct a new RecordBatch containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new RecordBatch of columns matching the specified names.\n     */\n    public select<K extends keyof T = any>(columnNames: K[]) {\n        const schema = this.schema.select(columnNames);\n        const type = new Struct(schema.fields);\n        const children = [] as Data<T[K]>[];\n        for (const name of columnNames) {\n            const index = this.schema.fields.findIndex((f) => f.name === name);\n            if (~index) {\n                children[index] = this.data.children[index] as Data<T[K]>;\n            }\n        }\n        return new RecordBatch(schema, makeData({ type, length: this.numRows, children }));\n    }\n\n    /**\n     * Construct a new RecordBatch containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new RecordBatch of columns matching at the specified indices.\n     */\n    public selectAt<K extends T = any>(columnIndices: number[]) {\n        const schema = this.schema.selectAt<K>(columnIndices);\n        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n        const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });\n        return new RecordBatch<{ [P in keyof K]: K[P] }>(schema, subset);\n    }\n\n    // Initialize this static property via an IIFE so bundlers don't tree-shake\n    // out this logic, but also so we're still compliant with `\"sideEffects\": false`\n    protected static [Symbol.toStringTag] = ((proto: RecordBatch) => {\n        (proto as any)._nullCount = -1;\n        (proto as any)[Symbol.isConcatSpreadable] = true;\n        return 'RecordBatch';\n    })(RecordBatch.prototype);\n}\n\n\n/** @ignore */\nfunction ensureSameLengthData<T extends TypeMap = any>(\n    schema: Schema<T>,\n    chunks: Data<T[keyof T]>[],\n    maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)\n) {\n    const fields = [...schema.fields];\n    const children = [...chunks] as Data<T[keyof T]>[];\n    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;\n\n    for (const [idx, field] of schema.fields.entries()) {\n        const chunk = chunks[idx];\n        if (!chunk || chunk.length !== maxLength) {\n            fields[idx] = field.clone({ nullable: true });\n            children[idx] = chunk?._changeLengthAndBackfillNullBitmap(maxLength) ?? makeData({\n                type: field.type,\n                length: maxLength,\n                nullCount: maxLength,\n                nullBitmap: new Uint8Array(nullBitmapSize)\n            });\n        }\n    }\n\n    return [\n        schema.assign(fields),\n        makeData({ type: new Struct<T>(fields), length: maxLength, children })\n    ] as [Schema<T>, Data<Struct<T>>];\n}\n\n/** @ignore */\nfunction collectDictionaries(fields: Field[], children: Data[], dictionaries = new Map<number, Vector>()): Map<number, Vector> {\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        const data = children[i];\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                if (data.dictionary) {\n                    dictionaries.set(type.id, data.dictionary);\n                }\n            } else if (dictionaries.get(type.id) !== data.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            collectDictionaries(type.children, data.children, dictionaries);\n        }\n    }\n    return dictionaries;\n}\n\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport class _InternalEmptyPlaceholderRecordBatch<T extends TypeMap = any> extends RecordBatch<T> {\n    constructor(schema: Schema<T>) {\n        const children = schema.fields.map((f) => makeData({ type: f.type }));\n        const data = makeData({ type: new Struct<T>(schema.fields), nullCount: 0, children });\n        super(schema, data);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}