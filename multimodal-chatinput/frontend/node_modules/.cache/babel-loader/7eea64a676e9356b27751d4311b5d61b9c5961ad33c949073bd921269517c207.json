{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DataType } from './type.mjs';\nexport class Schema {\n  constructor(fields = [], metadata, dictionaries) {\n    this.fields = fields || [];\n    this.metadata = metadata || new Map();\n    if (!dictionaries) {\n      dictionaries = generateDictionaryMap(fields);\n    }\n    this.dictionaries = dictionaries;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Schema';\n  }\n  get names() {\n    return this.fields.map(f => f.name);\n  }\n  toString() {\n    return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n  }\n  /**\n   * Construct a new Schema containing only specified fields.\n   *\n   * @param fieldNames Names of fields to keep.\n   * @returns A new Schema of fields matching the specified names.\n   */\n  select(fieldNames) {\n    const names = new Set(fieldNames);\n    const fields = this.fields.filter(f => names.has(f.name));\n    return new Schema(fields, this.metadata);\n  }\n  /**\n   * Construct a new Schema containing only fields at the specified indices.\n   *\n   * @param fieldIndices Indices of fields to keep.\n   * @returns A new Schema of fields at the specified indices.\n   */\n  selectAt(fieldIndices) {\n    const fields = fieldIndices.map(i => this.fields[i]).filter(Boolean);\n    return new Schema(fields, this.metadata);\n  }\n  assign(...args) {\n    const other = args[0] instanceof Schema ? args[0] : Array.isArray(args[0]) ? new Schema(args[0]) : new Schema(args);\n    const curFields = [...this.fields];\n    const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n    const newFields = other.fields.filter(f2 => {\n      const i = curFields.findIndex(f => f.name === f2.name);\n      return ~i ? (curFields[i] = f2.clone({\n        metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n      })) && false : true;\n    });\n    const newDictionaries = generateDictionaryMap(newFields, new Map());\n    return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n  }\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nSchema.prototype.fields = null;\nSchema.prototype.metadata = null;\nSchema.prototype.dictionaries = null;\nexport class Field {\n  constructor(name, type, nullable = false, metadata) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata || new Map();\n  }\n  /** @nocollapse */\n  static new(...args) {\n    let [name, type, nullable, metadata] = args;\n    if (args[0] && typeof args[0] === 'object') {\n      ({\n        name\n      } = args[0]);\n      type === undefined && (type = args[0].type);\n      nullable === undefined && (nullable = args[0].nullable);\n      metadata === undefined && (metadata = args[0].metadata);\n    }\n    return new Field(`${name}`, type, nullable, metadata);\n  }\n  get typeId() {\n    return this.type.typeId;\n  }\n  get [Symbol.toStringTag]() {\n    return 'Field';\n  }\n  toString() {\n    return `${this.name}: ${this.type}`;\n  }\n  clone(...args) {\n    let [name, type, nullable, metadata] = args;\n    !args[0] || typeof args[0] !== 'object' ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : ({\n      name = this.name,\n      type = this.type,\n      nullable = this.nullable,\n      metadata = this.metadata\n    } = args[0]);\n    return Field.new(name, type, nullable, metadata);\n  }\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nField.prototype.type = null;\nField.prototype.name = null;\nField.prototype.nullable = null;\nField.prototype.metadata = null;\n/** @ignore */\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n/** @ignore */\nfunction generateDictionaryMap(fields, dictionaries = new Map()) {\n  for (let i = -1, n = fields.length; ++i < n;) {\n    const field = fields[i];\n    const type = field.type;\n    if (DataType.isDictionary(type)) {\n      if (!dictionaries.has(type.id)) {\n        dictionaries.set(type.id, type.dictionary);\n      } else if (dictionaries.get(type.id) !== type.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n    if (type.children && type.children.length > 0) {\n      generateDictionaryMap(type.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}","map":{"version":3,"names":["DataType","Schema","constructor","fields","metadata","dictionaries","Map","generateDictionaryMap","Symbol","toStringTag","names","map","f","name","toString","i","join","select","fieldNames","Set","filter","has","selectAt","fieldIndices","Boolean","assign","args","other","Array","isArray","curFields","mergeMaps","newFields","f2","findIndex","clone","newDictionaries","prototype","Field","type","nullable","new","undefined","typeId","m1","m2","n","length","field","isDictionary","id","set","dictionary","get","Error","children"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/schema.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { DataType, TypeMap } from './type.js';\n\nexport class Schema<T extends TypeMap = any> {\n\n    public readonly fields: Field<T[keyof T]>[];\n    public readonly metadata: Map<string, string>;\n    public readonly dictionaries: Map<number, DataType>;\n\n    constructor(\n        fields: Field<T[keyof T]>[] = [],\n        metadata?: Map<string, string> | null,\n        dictionaries?: Map<number, DataType> | null) {\n        this.fields = (fields || []) as Field<T[keyof T]>[];\n        this.metadata = metadata || new Map();\n        if (!dictionaries) {\n            dictionaries = generateDictionaryMap(fields);\n        }\n        this.dictionaries = dictionaries;\n    }\n    public get [Symbol.toStringTag]() { return 'Schema'; }\n\n    public get names(): (keyof T)[] { return this.fields.map((f) => f.name); }\n\n    public toString() {\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n    }\n\n    /**\n     * Construct a new Schema containing only specified fields.\n     *\n     * @param fieldNames Names of fields to keep.\n     * @returns A new Schema of fields matching the specified names.\n     */\n    public select<K extends keyof T = any>(fieldNames: K[]) {\n        const names = new Set<string | K>(fieldNames);\n        const fields = this.fields.filter((f) => names.has(f.name)) as Field<T[K]>[];\n        return new Schema<{ [P in K]: T[P] }>(fields, this.metadata);\n    }\n\n    /**\n     * Construct a new Schema containing only fields at the specified indices.\n     *\n     * @param fieldIndices Indices of fields to keep.\n     * @returns A new Schema of fields at the specified indices.\n     */\n    public selectAt<K extends T = any>(fieldIndices: number[]) {\n        const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean) as Field<K[keyof K]>[];\n        return new Schema<K>(fields, this.metadata);\n    }\n\n    public assign<R extends TypeMap = any>(schema: Schema<R>): Schema<T & R>;\n    public assign<R extends TypeMap = any>(...fields: (Field<R[keyof R]> | Field<R[keyof R]>[])[]): Schema<T & R>;\n    public assign<R extends TypeMap = any>(...args: (Schema<R> | Field<R[keyof R]> | Field<R[keyof R]>[])[]) {\n\n        const other = (args[0] instanceof Schema\n            ? args[0] as Schema<R>\n            : Array.isArray(args[0])\n                ? new Schema<R>(<Field<R[keyof R]>[]>args[0])\n                : new Schema<R>(<Field<R[keyof R]>[]>args));\n\n        const curFields = [...this.fields] as Field[];\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n        const newFields = other.fields.filter((f2) => {\n            const i = curFields.findIndex((f) => f.name === f2.name);\n            return ~i ? (curFields[i] = f2.clone({\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n            })) && false : true;\n        }) as Field[];\n\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\n\n        return new Schema<T & R>(\n            [...curFields, ...newFields], metadata,\n            new Map([...this.dictionaries, ...newDictionaries])\n        );\n    }\n}\n\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n(Schema.prototype as any).fields = <any>null;\n(Schema.prototype as any).metadata = <any>null;\n(Schema.prototype as any).dictionaries = <any>null;\n\nexport class Field<T extends DataType = any> {\n\n    public static new<T extends DataType = any>(props: { name: string | number; type: T; nullable?: boolean; metadata?: Map<string, string> | null }): Field<T>;\n    public static new<T extends DataType = any>(name: string | number | Field<T>, type: T, nullable?: boolean, metadata?: Map<string, string> | null): Field<T>;\n    /** @nocollapse */\n    public static new<T extends DataType = any>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        if (args[0] && typeof args[0] === 'object') {\n            ({ name } = args[0]);\n            (type === undefined) && (type = args[0].type);\n            (nullable === undefined) && (nullable = args[0].nullable);\n            (metadata === undefined) && (metadata = args[0].metadata);\n        }\n        return new Field<T>(`${name}`, type, nullable, metadata);\n    }\n\n    public readonly type: T;\n    public readonly name: string;\n    public readonly nullable: boolean;\n    public readonly metadata: Map<string, string>;\n\n    constructor(name: string, type: T, nullable = false, metadata?: Map<string, string> | null) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata || new Map();\n    }\n\n    public get typeId() { return this.type.typeId; }\n    public get [Symbol.toStringTag]() { return 'Field'; }\n    public toString() { return `${this.name}: ${this.type}`; }\n    public clone<R extends DataType = T>(props: { name?: string | number; type?: R; nullable?: boolean; metadata?: Map<string, string> | null }): Field<R>;\n    public clone<R extends DataType = T>(name?: string | number | Field<T>, type?: R, nullable?: boolean, metadata?: Map<string, string> | null): Field<R>;\n    public clone<R extends DataType = T>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        (!args[0] || typeof args[0] !== 'object')\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\n            : ({ name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0]);\n        return Field.new<R>(name, type, nullable, metadata);\n    }\n}\n\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n(Field.prototype as any).type = null;\n(Field.prototype as any).name = null;\n(Field.prototype as any).nullable = null;\n(Field.prototype as any).metadata = null;\n\n/** @ignore */\nfunction mergeMaps<TKey, TVal>(m1?: Map<TKey, TVal> | null, m2?: Map<TKey, TVal> | null): Map<TKey, TVal> {\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n\n/** @ignore */\nfunction generateDictionaryMap(fields: Field[], dictionaries = new Map<number, DataType>()): Map<number, DataType> {\n\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                dictionaries.set(type.id, type.dictionary);\n            } else if (dictionaries.get(type.id) !== type.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            generateDictionaryMap(type.children, dictionaries);\n        }\n    }\n\n    return dictionaries;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}