{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from \"tslib\";\nimport { makeData } from '../data.mjs';\nimport { Vector } from '../vector.mjs';\nimport { Struct } from '../type.mjs';\nimport { MessageHeader } from '../enum.mjs';\nimport { Footer } from './metadata/file.mjs';\nimport streamAdapters from '../io/adapters.mjs';\nimport { ByteStream, AsyncByteStream } from '../io/stream.mjs';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file.mjs';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader.mjs';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch.mjs';\nimport { ITERATOR_DONE, ReadableInterop } from '../io/interfaces.mjs';\nimport { MessageReader, AsyncMessageReader, JSONMessageReader, checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding } from './message.mjs';\nimport { isPromise, isIterable, isAsyncIterable, isIteratorResult, isArrowJSON, isFileHandle, isFetchResponse, isReadableDOMStream, isReadableNodeStream } from '../util/compat.mjs';\nexport class RecordBatchReader extends ReadableInterop {\n  constructor(impl) {\n    super();\n    this._impl = impl;\n  }\n  get closed() {\n    return this._impl.closed;\n  }\n  get schema() {\n    return this._impl.schema;\n  }\n  get autoDestroy() {\n    return this._impl.autoDestroy;\n  }\n  get dictionaries() {\n    return this._impl.dictionaries;\n  }\n  get numDictionaries() {\n    return this._impl.numDictionaries;\n  }\n  get numRecordBatches() {\n    return this._impl.numRecordBatches;\n  }\n  get footer() {\n    return this._impl.isFile() ? this._impl.footer : null;\n  }\n  isSync() {\n    return this._impl.isSync();\n  }\n  isAsync() {\n    return this._impl.isAsync();\n  }\n  isFile() {\n    return this._impl.isFile();\n  }\n  isStream() {\n    return this._impl.isStream();\n  }\n  next() {\n    return this._impl.next();\n  }\n  throw(value) {\n    return this._impl.throw(value);\n  }\n  return(value) {\n    return this._impl.return(value);\n  }\n  cancel() {\n    return this._impl.cancel();\n  }\n  reset(schema) {\n    this._impl.reset(schema);\n    this._DOMStream = undefined;\n    this._nodeStream = undefined;\n    return this;\n  }\n  open(options) {\n    const opening = this._impl.open(options);\n    return isPromise(opening) ? opening.then(() => this) : this;\n  }\n  readRecordBatch(index) {\n    return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n  toDOMStream() {\n    return streamAdapters.toDOMStream(this.isSync() ? {\n      [Symbol.iterator]: () => this\n    } : {\n      [Symbol.asyncIterator]: () => this\n    });\n  }\n  toNodeStream() {\n    return streamAdapters.toNodeStream(this.isSync() ? {\n      [Symbol.iterator]: () => this\n    } : {\n      [Symbol.asyncIterator]: () => this\n    }, {\n      objectMode: true\n    });\n  }\n  /** @nocollapse */\n  // @ts-ignore\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static throughDOM(\n  // @ts-ignore\n  writableStrategy,\n  // @ts-ignore\n  readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /** @nocollapse */\n  static from(source) {\n    if (source instanceof RecordBatchReader) {\n      return source;\n    } else if (isArrowJSON(source)) {\n      return fromArrowJSON(source);\n    } else if (isFileHandle(source)) {\n      return fromFileHandle(source);\n    } else if (isPromise(source)) {\n      return (() => __awaiter(this, void 0, void 0, function* () {\n        return yield RecordBatchReader.from(yield source);\n      }))();\n    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n      return fromAsyncByteStream(new AsyncByteStream(source));\n    }\n    return fromByteStream(new ByteStream(source));\n  }\n  /** @nocollapse */\n  static readAll(source) {\n    if (source instanceof RecordBatchReader) {\n      return source.isSync() ? readAllSync(source) : readAllAsync(source);\n    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {\n      return readAllSync(source);\n    }\n    return readAllAsync(source);\n  }\n}\n//\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n/** @ignore */\nexport class RecordBatchStreamReader extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    return [...this];\n  }\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n  [Symbol.asyncIterator]() {\n    return __asyncGenerator(this, arguments, function* _a() {\n      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));\n    });\n  }\n}\n/** @ignore */\nexport class AsyncRecordBatchStreamReader extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n  readAll() {\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const batches = new Array();\n      try {\n        for (var _b = __asyncValues(this), _c; _c = yield _b.next(), !_c.done;) {\n          const batch = _c.value;\n          batches.push(batch);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return batches;\n    });\n  }\n  [Symbol.iterator]() {\n    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);\n  }\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n}\n/** @ignore */\nexport class RecordBatchFileReader extends RecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n}\n/** @ignore */\nexport class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n}\n/** @ignore */\nclass RecordBatchReaderImpl {\n  constructor(dictionaries = new Map()) {\n    this.closed = false;\n    this.autoDestroy = true;\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.dictionaries = dictionaries;\n  }\n  get numDictionaries() {\n    return this._dictionaryIndex;\n  }\n  get numRecordBatches() {\n    return this._recordBatchIndex;\n  }\n  isSync() {\n    return false;\n  }\n  isAsync() {\n    return false;\n  }\n  isFile() {\n    return false;\n  }\n  isStream() {\n    return false;\n  }\n  reset(schema) {\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.schema = schema;\n    this.dictionaries = new Map();\n    return this;\n  }\n  _loadRecordBatch(header, body) {\n    const children = this._loadVectors(header, body, this.schema.fields);\n    const data = makeData({\n      type: new Struct(this.schema.fields),\n      length: header.length,\n      children\n    });\n    return new RecordBatch(this.schema, data);\n  }\n  _loadDictionaryBatch(header, body) {\n    const {\n      id,\n      isDelta\n    } = header;\n    const {\n      dictionaries,\n      schema\n    } = this;\n    const dictionary = dictionaries.get(id);\n    if (isDelta || !dictionary) {\n      const type = schema.dictionaries.get(id);\n      const data = this._loadVectors(header.data, body, [type]);\n      return (dictionary && isDelta ? dictionary.concat(new Vector(data)) : new Vector(data)).memoize();\n    }\n    return dictionary.memoize();\n  }\n  _loadVectors(header, body, types) {\n    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n}\n/** @ignore */\nclass RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);\n  }\n  isSync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  cancel() {\n    if (!this.closed && (this.closed = true)) {\n      this.reset()._reader.return();\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n  open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n      if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n        this.cancel();\n      }\n    }\n    return this;\n  }\n  throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.throw(value);\n    }\n    return ITERATOR_DONE;\n  }\n  return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.return(value);\n    }\n    return ITERATOR_DONE;\n  }\n  next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n    let message;\n    const {\n      _reader: reader\n    } = this;\n    while (message = this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return {\n          done: false,\n          value: recordBatch\n        };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n        const vector = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return {\n        done: false,\n        value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n      };\n    }\n    return this.return();\n  }\n  _readNextMessageAndValidate(type) {\n    return this._reader.readMessage(type);\n  }\n}\n/** @ignore */\nclass AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = new AsyncMessageReader(this._handle = source);\n  }\n  isAsync() {\n    return true;\n  }\n  isStream() {\n    return true;\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  cancel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && (this.closed = true)) {\n        yield this.reset()._reader.return();\n        this._reader = null;\n        this.dictionaries = null;\n      }\n    });\n  }\n  open(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed) {\n        this.autoDestroy = shouldAutoDestroy(this, options);\n        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {\n          yield this.cancel();\n        }\n      }\n      return this;\n    });\n  }\n  throw(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.throw(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  return(value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return yield this.reset()._reader.return(value);\n      }\n      return ITERATOR_DONE;\n    });\n  }\n  next() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return ITERATOR_DONE;\n      }\n      let message;\n      const {\n        _reader: reader\n      } = this;\n      while (message = yield this._readNextMessageAndValidate()) {\n        if (message.isSchema()) {\n          yield this.reset(message.header());\n        } else if (message.isRecordBatch()) {\n          this._recordBatchIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return {\n            done: false,\n            value: recordBatch\n          };\n        } else if (message.isDictionaryBatch()) {\n          this._dictionaryIndex++;\n          const header = message.header();\n          const buffer = yield reader.readMessageBody(message.bodyLength);\n          const vector = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector);\n        }\n      }\n      if (this.schema && this._recordBatchIndex === 0) {\n        this._recordBatchIndex++;\n        return {\n          done: false,\n          value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n        };\n      }\n      return yield this.return();\n    });\n  }\n  _readNextMessageAndValidate(type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield this._reader.readMessage(type);\n    });\n  }\n}\n/** @ignore */\nclass RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isSync() {\n    return true;\n  }\n  isFile() {\n    return true;\n  }\n  open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = this._readFooter()).schema;\n      for (const block of this._footer.dictionaryBatches()) {\n        block && this._readDictionaryBatch(this._dictionaryIndex++);\n      }\n    }\n    return super.open(options);\n  }\n  readRecordBatch(index) {\n    var _a;\n    if (this.closed) {\n      return null;\n    }\n    if (!this._footer) {\n      this.open();\n    }\n    const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.RecordBatch);\n      if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const recordBatch = this._loadRecordBatch(header, buffer);\n        return recordBatch;\n      }\n    }\n    return null;\n  }\n  _readDictionaryBatch(index) {\n    var _a;\n    const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n      if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n        const header = message.header();\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n        const vector = this._loadDictionaryBatch(header, buffer);\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n  }\n  _readFooter() {\n    const {\n      _handle\n    } = this;\n    const offset = _handle.size - magicAndPadding;\n    const length = _handle.readInt32(offset);\n    const buffer = _handle.readAt(offset - length, length);\n    return Footer.decode(buffer);\n  }\n  _readNextMessageAndValidate(type) {\n    var _a;\n    if (!this._footer) {\n      this.open();\n    }\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(this._recordBatchIndex);\n      if (block && this._handle.seek(block.offset)) {\n        return this._reader.readMessage(type);\n      }\n    }\n    return null;\n  }\n}\n/** @ignore */\nclass AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {\n  constructor(source, ...rest) {\n    const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;\n    const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;\n    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n  }\n  get footer() {\n    return this._footer;\n  }\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n  isFile() {\n    return true;\n  }\n  isAsync() {\n    return true;\n  }\n  open(options) {\n    const _super = Object.create(null, {\n      open: {\n        get: () => super.open\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.closed && !this._footer) {\n        this.schema = (this._footer = yield this._readFooter()).schema;\n        for (const block of this._footer.dictionaryBatches()) {\n          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));\n        }\n      }\n      return yield _super.open.call(this, options);\n    });\n  }\n  readRecordBatch(index) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.closed) {\n        return null;\n      }\n      if (!this._footer) {\n        yield this.open();\n      }\n      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.RecordBatch);\n        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const recordBatch = this._loadRecordBatch(header, buffer);\n          return recordBatch;\n        }\n      }\n      return null;\n    });\n  }\n  _readDictionaryBatch(index) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);\n      if (block && (yield this._handle.seek(block.offset))) {\n        const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);\n        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {\n          const header = message.header();\n          const buffer = yield this._reader.readMessageBody(message.bodyLength);\n          const vector = this._loadDictionaryBatch(header, buffer);\n          this.dictionaries.set(header.id, vector);\n        }\n      }\n    });\n  }\n  _readFooter() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        _handle\n      } = this;\n      _handle._pending && (yield _handle._pending);\n      const offset = _handle.size - magicAndPadding;\n      const length = yield _handle.readInt32(offset);\n      const buffer = yield _handle.readAt(offset - length, length);\n      return Footer.decode(buffer);\n    });\n  }\n  _readNextMessageAndValidate(type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._footer) {\n        yield this.open();\n      }\n      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n        const block = this._footer.getRecordBatch(this._recordBatchIndex);\n        if (block && (yield this._handle.seek(block.offset))) {\n          return yield this._reader.readMessage(type);\n        }\n      }\n      return null;\n    });\n  }\n}\n/** @ignore */\nclass RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source, dictionaries);\n  }\n  _loadVectors(header, body, types) {\n    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n}\n//\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n/** @ignore */\nfunction shouldAutoDestroy(self, options) {\n  return options && typeof options['autoDestroy'] === 'boolean' ? options['autoDestroy'] : self['autoDestroy'];\n}\n/** @ignore */\nfunction* readAllSync(source) {\n  const reader = RecordBatchReader.from(source);\n  try {\n    if (!reader.open({\n      autoDestroy: false\n    }).closed) {\n      do {\n        yield reader;\n      } while (!reader.reset().open().closed);\n    }\n  } finally {\n    reader.cancel();\n  }\n}\n/** @ignore */\nfunction readAllAsync(source) {\n  return __asyncGenerator(this, arguments, function* readAllAsync_1() {\n    const reader = yield __await(RecordBatchReader.from(source));\n    try {\n      if (!(yield __await(reader.open({\n        autoDestroy: false\n      }))).closed) {\n        do {\n          yield yield __await(reader);\n        } while (!(yield __await(reader.reset().open())).closed);\n      }\n    } finally {\n      yield __await(reader.cancel());\n    }\n  });\n}\n/** @ignore */\nfunction fromArrowJSON(source) {\n  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\n/** @ignore */\nfunction fromByteStream(source) {\n  const bytes = source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {}()));\n}\n/** @ignore */\nfunction fromAsyncByteStream(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const bytes = yield source.peek(magicLength + 7 & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function () {\n      return __asyncGenerator(this, arguments, function* () {});\n    }()));\n  });\n}\n/** @ignore */\nfunction fromFileHandle(source) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      size\n    } = yield source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {\n      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));\n  });\n}","map":{"version":3,"names":["makeData","Vector","Struct","MessageHeader","Footer","streamAdapters","ByteStream","AsyncByteStream","RandomAccessFile","AsyncRandomAccessFile","VectorLoader","JSONVectorLoader","RecordBatch","_InternalEmptyPlaceholderRecordBatch","ITERATOR_DONE","ReadableInterop","MessageReader","AsyncMessageReader","JSONMessageReader","checkForMagicArrowString","magicLength","magicAndPadding","magicX2AndPadding","isPromise","isIterable","isAsyncIterable","isIteratorResult","isArrowJSON","isFileHandle","isFetchResponse","isReadableDOMStream","isReadableNodeStream","RecordBatchReader","constructor","impl","_impl","closed","schema","autoDestroy","dictionaries","numDictionaries","numRecordBatches","footer","isFile","isSync","isAsync","isStream","next","throw","value","return","cancel","reset","_DOMStream","undefined","_nodeStream","open","options","opening","then","readRecordBatch","index","Symbol","iterator","asyncIterator","toDOMStream","toNodeStream","objectMode","throughNode","Error","throughDOM","writableStrategy","readableStrategy","from","source","fromArrowJSON","fromFileHandle","__awaiter","fromAsyncByteStream","fromByteStream","readAll","readAllSync","readAllAsync","ArrayBuffer","isView","RecordBatchStreamReader","__asyncGenerator","arguments","_a","__await","__asyncDelegator","__asyncValues","AsyncRecordBatchStreamReader","batches","Array","_b","_c","done","batch","push","RecordBatchFileReader","AsyncRecordBatchFileReader","RecordBatchReaderImpl","Map","_dictionaryIndex","_recordBatchIndex","_loadRecordBatch","header","body","children","_loadVectors","fields","data","type","length","_loadDictionaryBatch","id","isDelta","dictionary","get","concat","memoize","types","nodes","buffers","visitMany","RecordBatchStreamReaderImpl","_reader","_handle","shouldAutoDestroy","readSchema","message","reader","_readNextMessageAndValidate","isSchema","isRecordBatch","buffer","readMessageBody","bodyLength","recordBatch","isDictionaryBatch","vector","set","readMessage","AsyncRecordBatchStreamReaderImpl","RecordBatchFileReaderImpl","_footer","_readFooter","block","dictionaryBatches","_readDictionaryBatch","getRecordBatch","seek","offset","getDictionaryBatch","DictionaryBatch","size","readInt32","readAt","decode","AsyncRecordBatchFileReaderImpl","rest","byteLength","shift","_super","call","_pending","RecordBatchJSONReaderImpl","self","bytes","peek","read","stat","file"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/template/my_component/frontend/node_modules/apache-arrow/src/ipc/reader.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { makeData } from '../data.js';\nimport { Vector } from '../vector.js';\nimport { DataType, Struct, TypeMap } from '../type.js';\nimport { MessageHeader } from '../enum.js';\nimport { Footer } from './metadata/file.js';\nimport { Schema, Field } from '../schema.js';\nimport streamAdapters from '../io/adapters.js';\nimport { Message } from './metadata/message.js';\nimport * as metadata from './metadata/message.js';\nimport { ArrayBufferViewInput } from '../util/buffer.js';\nimport { ByteStream, AsyncByteStream } from '../io/stream.js';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file.js';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader.js';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch.js';\nimport {\n    FileHandle,\n    ArrowJSONLike,\n    ITERATOR_DONE,\n    ReadableInterop,\n} from '../io/interfaces.js';\nimport {\n    MessageReader, AsyncMessageReader, JSONMessageReader,\n    checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding\n} from './message.js';\nimport {\n    isPromise,\n    isIterable, isAsyncIterable,\n    isIteratorResult, isArrowJSON,\n    isFileHandle, isFetchResponse,\n    isReadableDOMStream, isReadableNodeStream\n} from '../util/compat.js';\n\n/** @ignore */ export type FromArg0 = ArrowJSONLike;\n/** @ignore */ export type FromArg1 = PromiseLike<ArrowJSONLike>;\n/** @ignore */ export type FromArg2 = Iterable<ArrayBufferViewInput> | ArrayBufferViewInput;\n/** @ignore */ export type FromArg3 = PromiseLike<Iterable<ArrayBufferViewInput> | ArrayBufferViewInput>;\n/** @ignore */ export type FromArg4 = Response | NodeJS.ReadableStream | ReadableStream<ArrayBufferViewInput> | AsyncIterable<ArrayBufferViewInput>;\n/** @ignore */ export type FromArg5 = FileHandle | PromiseLike<FileHandle> | PromiseLike<FromArg4>;\n/** @ignore */ export type FromArgs = FromArg0 | FromArg1 | FromArg2 | FromArg3 | FromArg4 | FromArg5;\n\n/** @ignore */ type OpenOptions = { autoDestroy?: boolean };\n/** @ignore */ type RecordBatchReaders<T extends TypeMap = any> = RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n/** @ignore */ type AsyncRecordBatchReaders<T extends TypeMap = any> = AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>;\n/** @ignore */ type RecordBatchFileReaders<T extends TypeMap = any> = RecordBatchFileReader<T> | AsyncRecordBatchFileReader<T>;\n/** @ignore */ type RecordBatchStreamReaders<T extends TypeMap = any> = RecordBatchStreamReader<T> | AsyncRecordBatchStreamReader<T>;\n\nexport class RecordBatchReader<T extends TypeMap = any> extends ReadableInterop<RecordBatch<T>> {\n\n    protected _impl: RecordBatchReaderImpls<T>;\n    protected constructor(impl: RecordBatchReaderImpls<T>) {\n        super();\n        this._impl = impl;\n    }\n\n    public get closed() { return this._impl.closed; }\n    public get schema() { return this._impl.schema; }\n    public get autoDestroy() { return this._impl.autoDestroy; }\n    public get dictionaries() { return this._impl.dictionaries; }\n    public get numDictionaries() { return this._impl.numDictionaries; }\n    public get numRecordBatches() { return this._impl.numRecordBatches; }\n    public get footer(): Footer | null { return this._impl.isFile() ? this._impl.footer : null; }\n\n    public isSync(): this is RecordBatchReaders<T> { return this._impl.isSync(); }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return this._impl.isAsync(); }\n    public isFile(): this is RecordBatchFileReaders<T> { return this._impl.isFile(); }\n    public isStream(): this is RecordBatchStreamReaders<T> { return this._impl.isStream(); }\n\n    public next() {\n        return this._impl.next();\n    }\n    public throw(value?: any) {\n        return this._impl.throw(value);\n    }\n    public return(value?: any) {\n        return this._impl.return(value);\n    }\n    public cancel() {\n        return this._impl.cancel();\n    }\n    public reset(schema?: Schema<T> | null): this {\n        this._impl.reset(schema);\n        this._DOMStream = undefined;\n        this._nodeStream = undefined;\n        return this;\n    }\n    public open(options?: OpenOptions) {\n        const opening = this._impl.open(options);\n        return isPromise(opening) ? opening.then(() => this) : this;\n    }\n    public readRecordBatch(index: number): RecordBatch<T> | null | Promise<RecordBatch<T> | null> {\n        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n    }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return (<IterableIterator<RecordBatch<T>>>this._impl)[Symbol.iterator]();\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return (<AsyncIterableIterator<RecordBatch<T>>>this._impl)[Symbol.asyncIterator]();\n    }\n    public toDOMStream() {\n        return streamAdapters.toDOMStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>));\n    }\n    public toNodeStream() {\n        return streamAdapters.toNodeStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>),\n            { objectMode: true });\n    }\n\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughNode(options?: import('stream').DuplexOptions & { autoDestroy: boolean }): import('stream').Duplex {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    public static throughDOM<T extends TypeMap>(\n        // @ts-ignore\n        writableStrategy?: ByteLengthQueuingStrategy,\n        // @ts-ignore\n        readableStrategy?: { autoDestroy: boolean }\n    ): { writable: WritableStream<Uint8Array>; readable: ReadableStream<RecordBatch<T>> } {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n\n    public static from<T extends RecordBatchReader>(source: T): T;\n    public static from<T extends TypeMap = any>(source: FromArg0): RecordBatchStreamReader<T>;\n    public static from<T extends TypeMap = any>(source: FromArg1): Promise<RecordBatchStreamReader<T>>;\n    public static from<T extends TypeMap = any>(source: FromArg2): RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n    public static from<T extends TypeMap = any>(source: FromArg3): Promise<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static from<T extends TypeMap = any>(source: FromArg4): Promise<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    public static from<T extends TypeMap = any>(source: FromArg5): Promise<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    /** @nocollapse */\n    public static from<T extends TypeMap = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source;\n        } else if (isArrowJSON(source)) {\n            return fromArrowJSON<T>(source);\n        } else if (isFileHandle(source)) {\n            return fromFileHandle<T>(source);\n        } else if (isPromise<any>(source)) {\n            return (async () => await RecordBatchReader.from<any>(await source))();\n        } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n            return fromAsyncByteStream<T>(new AsyncByteStream(source));\n        }\n        return fromByteStream<T>(new ByteStream(source));\n    }\n\n    public static readAll<T extends RecordBatchReader>(source: T): T extends RecordBatchReaders ? IterableIterator<T> : AsyncIterableIterator<T>;\n    public static readAll<T extends TypeMap = any>(source: FromArg0): IterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends TypeMap = any>(source: FromArg1): AsyncIterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends TypeMap = any>(source: FromArg2): IterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends TypeMap = any>(source: FromArg3): AsyncIterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends TypeMap = any>(source: FromArg4): AsyncIterableIterator<AsyncRecordBatchReaders<T>>;\n    public static readAll<T extends TypeMap = any>(source: FromArg5): AsyncIterableIterator<AsyncRecordBatchReaders<T>>;\n    /** @nocollapse */\n    public static readAll<T extends TypeMap = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source.isSync() ? readAllSync(source) : readAllAsync(source as AsyncRecordBatchReaders<T>);\n        } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable<ArrayBufferViewInput>(source) || isIteratorResult(source)) {\n            return readAllSync<T>(source) as IterableIterator<RecordBatchReaders<T>>;\n        }\n        return readAllAsync<T>(source) as AsyncIterableIterator<RecordBatchReaders<T> | AsyncRecordBatchReaders<T>>;\n    }\n}\n\n//\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n\n/** @ignore */\nexport class RecordBatchStreamReader<T extends TypeMap = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: RecordBatchStreamReaderImpl<T>) { super(_impl); }\n    public readAll() { return [...this]; }\n    public [Symbol.iterator]() { return (this._impl as IterableIterator<RecordBatch<T>>)[Symbol.iterator](); }\n    public async *[Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> { yield* this[Symbol.iterator](); }\n}\n/** @ignore */\nexport class AsyncRecordBatchStreamReader<T extends TypeMap = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: AsyncRecordBatchStreamReaderImpl<T>) { super(_impl); }\n    public async readAll() {\n        const batches = new Array<RecordBatch<T>>();\n        for await (const batch of this) { batches.push(batch); }\n        return batches;\n    }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> { throw new Error(`AsyncRecordBatchStreamReader is not Iterable`); }\n    public [Symbol.asyncIterator]() { return (this._impl as AsyncIterableIterator<RecordBatch<T>>)[Symbol.asyncIterator](); }\n}\n/** @ignore */\nexport class RecordBatchFileReader<T extends TypeMap = any> extends RecordBatchStreamReader<T> {\n    constructor(protected _impl: RecordBatchFileReaderImpl<T>) { super(_impl); }\n}\n/** @ignore */\nexport class AsyncRecordBatchFileReader<T extends TypeMap = any> extends AsyncRecordBatchStreamReader<T> {\n    constructor(protected _impl: AsyncRecordBatchFileReaderImpl<T>) { super(_impl); }\n}\n\n//\n// Now override the return types for each sync/async RecordBatchReader variant\n//\n\n/** @ignore */\nexport interface RecordBatchStreamReader<T extends TypeMap = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): this;\n    cancel(): void;\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchStreamReader<T extends TypeMap = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): Promise<this>;\n    cancel(): Promise<void>;\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n}\n\n/** @ignore */\nexport interface RecordBatchFileReader<T extends TypeMap = any> extends RecordBatchStreamReader<T> {\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchFileReader<T extends TypeMap = any> extends AsyncRecordBatchStreamReader<T> {\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\ntype RecordBatchReaderImpls<T extends TypeMap = any> =\n    RecordBatchJSONReaderImpl<T> |\n    RecordBatchFileReaderImpl<T> |\n    RecordBatchStreamReaderImpl<T> |\n    AsyncRecordBatchFileReaderImpl<T> |\n    AsyncRecordBatchStreamReaderImpl<T>;\n\n/** @ignore */\ninterface RecordBatchReaderImpl<T extends TypeMap = any> {\n\n    closed: boolean;\n    schema: Schema<T>;\n    autoDestroy: boolean;\n    dictionaries: Map<number, Vector>;\n\n    isFile(): this is RecordBatchFileReaders<T>;\n    isStream(): this is RecordBatchStreamReaders<T>;\n    isSync(): this is RecordBatchReaders<T>;\n    isAsync(): this is AsyncRecordBatchReaders<T>;\n\n    reset(schema?: Schema<T> | null): this;\n}\n\n/** @ignore */\ninterface RecordBatchStreamReaderImpl<T extends TypeMap = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): this;\n    cancel(): void;\n\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n\n    [Symbol.iterator](): IterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchStreamReaderImpl<T extends TypeMap = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): Promise<this>;\n    cancel(): Promise<void>;\n\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface RecordBatchFileReaderImpl<T extends TypeMap = any> extends RecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchFileReaderImpl<T extends TypeMap = any> extends AsyncRecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\nabstract class RecordBatchReaderImpl<T extends TypeMap = any> implements RecordBatchReaderImpl<T> {\n\n    declare public schema: Schema<T>;\n    public closed = false;\n    public autoDestroy = true;\n    public dictionaries: Map<number, Vector>;\n\n    protected _dictionaryIndex = 0;\n    protected _recordBatchIndex = 0;\n    public get numDictionaries() { return this._dictionaryIndex; }\n    public get numRecordBatches() { return this._recordBatchIndex; }\n\n    constructor(dictionaries = new Map<number, Vector>()) {\n        this.dictionaries = dictionaries;\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return false; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return false; }\n    public isFile(): this is RecordBatchFileReaders<T> { return false; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return false; }\n\n    public reset(schema?: Schema<T> | null) {\n        this._dictionaryIndex = 0;\n        this._recordBatchIndex = 0;\n        this.schema = <any>schema;\n        this.dictionaries = new Map();\n        return this;\n    }\n\n    protected _loadRecordBatch(header: metadata.RecordBatch, body: any) {\n        const children = this._loadVectors(header, body, this.schema.fields);\n        const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children });\n        return new RecordBatch(this.schema, data);\n    }\n    protected _loadDictionaryBatch(header: metadata.DictionaryBatch, body: any) {\n        const { id, isDelta } = header;\n        const { dictionaries, schema } = this;\n        const dictionary = dictionaries.get(id);\n        if (isDelta || !dictionary) {\n            const type = schema.dictionaries.get(id)!;\n            const data = this._loadVectors(header.data, body, [type]);\n            return (dictionary && isDelta ? dictionary.concat(\n                new Vector(data)) :\n                new Vector(data)).memoize() as Vector;\n        }\n        return dictionary.memoize();\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n/** @ignore */\nclass RecordBatchStreamReaderImpl<T extends TypeMap = any> extends RecordBatchReaderImpl<T> implements IterableIterator<RecordBatch<T>> {\n\n    protected _reader: MessageReader;\n    protected _handle: ByteStream | ArrowJSONLike;\n\n    constructor(source: ByteStream | ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = !isArrowJSON(source)\n            ? new MessageReader(this._handle = source)\n            : new JSONMessageReader(this._handle = source);\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return this as IterableIterator<RecordBatch<T>>;\n    }\n    public cancel() {\n        if (!this.closed && (this.closed = true)) {\n            this.reset()._reader.return();\n            this._reader = <any>null;\n            this.dictionaries = <any>null;\n        }\n    }\n    public open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = this._reader.readSchema()!))) {\n                this.cancel();\n            }\n        }\n        return this;\n    }\n    public throw(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public return(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public next(): IteratorResult<RecordBatch<T>> {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null;\n        const { _reader: reader } = this;\n        while (message = this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return this.return();\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchStreamReaderImpl<T extends TypeMap = any> extends RecordBatchReaderImpl<T> implements AsyncIterableIterator<RecordBatch<T>> {\n\n    protected _handle: AsyncByteStream;\n    protected _reader: AsyncMessageReader;\n\n    constructor(source: AsyncByteStream, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = new AsyncMessageReader(this._handle = source);\n    }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return this as AsyncIterableIterator<RecordBatch<T>>;\n    }\n    public async cancel() {\n        if (!this.closed && (this.closed = true)) {\n            await this.reset()._reader.return();\n            this._reader = <any>null;\n            this.dictionaries = <any>null;\n        }\n    }\n    public async open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = (await this._reader.readSchema())!))) {\n                await this.cancel();\n            }\n        }\n        return this;\n    }\n    public async throw(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async return(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async next() {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null;\n        const { _reader: reader } = this;\n        while (message = await this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                await this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return await this.return();\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return await this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass RecordBatchFileReaderImpl<T extends TypeMap = any> extends RecordBatchStreamReaderImpl<T> {\n\n    protected _footer?: Footer;\n    declare protected _handle: RandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: RandomAccessFile | ArrayBufferViewInput, dictionaries?: Map<number, Vector>) {\n        super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n    }\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return super.open(options);\n    }\n    public readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { this.open(); }\n        const block = this._footer?.getRecordBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message?.isRecordBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected _readDictionaryBatch(index: number) {\n        const block = this._footer?.getDictionaryBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message?.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected _readFooter() {\n        const { _handle } = this;\n        const offset = _handle.size - magicAndPadding;\n        const length = _handle.readInt32(offset);\n        const buffer = _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Message<T> | null {\n        if (!this._footer) { this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer?.getRecordBatch(this._recordBatchIndex);\n            if (block && this._handle.seek(block.offset)) {\n                return this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchFileReaderImpl<T extends TypeMap = any> extends AsyncRecordBatchStreamReaderImpl<T>\n    implements AsyncRecordBatchFileReaderImpl<T> {\n\n    protected _footer?: Footer;\n    declare protected _handle: AsyncRandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: FileHandle, byteLength?: number, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, ...rest: any[]) {\n        const byteLength = typeof rest[0] !== 'number' ? <number>rest.shift() : undefined;\n        const dictionaries = rest[0] instanceof Map ? <Map<number, Vector>>rest.shift() : undefined;\n        super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n    }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public async open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = await this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && await this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return await super.open(options);\n    }\n    public async readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { await this.open(); }\n        const block = this._footer?.getRecordBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message?.isRecordBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected async _readDictionaryBatch(index: number) {\n        const block = this._footer?.getDictionaryBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message?.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected async _readFooter() {\n        const { _handle } = this;\n        _handle._pending && await _handle._pending;\n        const offset = _handle.size - magicAndPadding;\n        const length = await _handle.readInt32(offset);\n        const buffer = await _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Promise<Message<T> | null> {\n        if (!this._footer) { await this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer.getRecordBatch(this._recordBatchIndex);\n            if (block && await this._handle.seek(block.offset)) {\n                return await this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass RecordBatchJSONReaderImpl<T extends TypeMap = any> extends RecordBatchStreamReaderImpl<T> {\n    constructor(source: ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(source, dictionaries);\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n//\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n\n/** @ignore */\nfunction shouldAutoDestroy(self: { autoDestroy: boolean }, options?: OpenOptions) {\n    return options && (typeof options['autoDestroy'] === 'boolean') ? options['autoDestroy'] : self['autoDestroy'];\n}\n\n/** @ignore */\nfunction* readAllSync<T extends TypeMap = any>(source: RecordBatchReaders<T> | FromArg0 | FromArg2) {\n    const reader = RecordBatchReader.from<T>(<any>source) as RecordBatchReaders<T>;\n    try {\n        if (!reader.open({ autoDestroy: false }).closed) {\n            do { yield reader; } while (!(reader.reset().open()).closed);\n        }\n    } finally { reader.cancel(); }\n}\n\n/** @ignore */\nasync function* readAllAsync<T extends TypeMap = any>(source: AsyncRecordBatchReaders<T> | FromArg1 | FromArg3 | FromArg4 | FromArg5) {\n    const reader = await RecordBatchReader.from<T>(<any>source) as RecordBatchReader<T>;\n    try {\n        if (!(await reader.open({ autoDestroy: false })).closed) {\n            do { yield reader; } while (!(await reader.reset().open()).closed);\n        }\n    } finally { await reader.cancel(); }\n}\n\n/** @ignore */\nfunction fromArrowJSON<T extends TypeMap>(source: ArrowJSONLike) {\n    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl<T>(source));\n}\n\n/** @ignore */\nfunction fromByteStream<T extends TypeMap>(source: ByteStream) {\n    const bytes = source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(source.read()))\n        : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(function* (): any { }()));\n}\n\n/** @ignore */\nasync function fromAsyncByteStream<T extends TypeMap>(source: AsyncByteStream) {\n    const bytes = await source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(await source.read()))\n        : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(async function* (): any { }()));\n}\n\n/** @ignore */\nasync function fromFileHandle<T extends TypeMap>(source: FileHandle) {\n    const { size } = await source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding && checkForMagicArrowString(await file.readAt(0, (magicLength + 7) & ~7))) {\n        return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl<T>(file));\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(file));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}