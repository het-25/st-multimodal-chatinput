{"ast":null,"code":"import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from \"./constants\";\nimport { Long } from \"./long\";\nimport { int32, isLittleEndian, float32, float64 } from \"./utils\";\nimport { Encoding } from \"./encoding\";\nexport class ByteBuffer {\n  /**\r\n   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\r\n   */\n  constructor(bytes_) {\n    this.bytes_ = bytes_;\n    this.position_ = 0;\n  }\n  /**\r\n   * Create and allocate a new ByteBuffer with a given size.\r\n   */\n  static allocate(byte_size) {\n    return new ByteBuffer(new Uint8Array(byte_size));\n  }\n  clear() {\n    this.position_ = 0;\n  }\n  /**\r\n   * Get the underlying `Uint8Array`.\r\n   */\n  bytes() {\n    return this.bytes_;\n  }\n  /**\r\n   * Get the buffer's position.\r\n   */\n  position() {\n    return this.position_;\n  }\n  /**\r\n   * Set the buffer's position.\r\n   */\n  setPosition(position) {\n    this.position_ = position;\n  }\n  /**\r\n   * Get the buffer's capacity.\r\n   */\n  capacity() {\n    return this.bytes_.length;\n  }\n  readInt8(offset) {\n    return this.readUint8(offset) << 24 >> 24;\n  }\n  readUint8(offset) {\n    return this.bytes_[offset];\n  }\n  readInt16(offset) {\n    return this.readUint16(offset) << 16 >> 16;\n  }\n  readUint16(offset) {\n    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n  }\n  readInt32(offset) {\n    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n  }\n  readUint32(offset) {\n    return this.readInt32(offset) >>> 0;\n  }\n  readInt64(offset) {\n    return new Long(this.readInt32(offset), this.readInt32(offset + 4));\n  }\n  readUint64(offset) {\n    return new Long(this.readUint32(offset), this.readUint32(offset + 4));\n  }\n  readFloat32(offset) {\n    int32[0] = this.readInt32(offset);\n    return float32[0];\n  }\n  readFloat64(offset) {\n    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n    return float64[0];\n  }\n  writeInt8(offset, value) {\n    this.bytes_[offset] = value;\n  }\n  writeUint8(offset, value) {\n    this.bytes_[offset] = value;\n  }\n  writeInt16(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n  }\n  writeUint16(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n  }\n  writeInt32(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n  }\n  writeUint32(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n  }\n  writeInt64(offset, value) {\n    this.writeInt32(offset, value.low);\n    this.writeInt32(offset + 4, value.high);\n  }\n  writeUint64(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n  }\n  writeFloat32(offset, value) {\n    float32[0] = value;\n    this.writeInt32(offset, int32[0]);\n  }\n  writeFloat64(offset, value) {\n    float64[0] = value;\n    this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n    this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n  }\n  /**\r\n   * Return the file identifier.   Behavior is undefined for FlatBuffers whose\r\n   * schema does not include a file_identifier (likely points at padding or the\r\n   * start of a the root vtable).\r\n   */\n  getBufferIdentifier() {\n    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n    }\n    let result = \"\";\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n    }\n    return result;\n  }\n  /**\r\n   * Look up a field in the vtable, return an offset into the object, or 0 if the\r\n   * field is not present.\r\n   */\n  __offset(bb_pos, vtable_offset) {\n    const vtable = bb_pos - this.readInt32(bb_pos);\n    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n  }\n  /**\r\n   * Initialize any Table-derived type to point to the union at the given offset.\r\n   */\n  __union(t, offset) {\n    t.bb_pos = offset + this.readInt32(offset);\n    t.bb = this;\n    return t;\n  }\n  /**\r\n   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\r\n   * This allocates a new string and converts to wide chars upon each access.\r\n   *\r\n   * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as\r\n   * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\r\n   * and from UTF-16 when the data will just be packaged back up in another\r\n   * FlatBuffer later on.\r\n   *\r\n   * @param offset\r\n   * @param opt_encoding Defaults to UTF16_STRING\r\n   */\n  __string(offset, opt_encoding) {\n    offset += this.readInt32(offset);\n    const length = this.readInt32(offset);\n    let result = '';\n    let i = 0;\n    offset += SIZEOF_INT;\n    if (opt_encoding === Encoding.UTF8_BYTES) {\n      return this.bytes_.subarray(offset, offset + length);\n    }\n    while (i < length) {\n      let codePoint;\n      // Decode UTF-8\n      const a = this.readUint8(offset + i++);\n      if (a < 0xC0) {\n        codePoint = a;\n      } else {\n        const b = this.readUint8(offset + i++);\n        if (a < 0xE0) {\n          codePoint = (a & 0x1F) << 6 | b & 0x3F;\n        } else {\n          const c = this.readUint8(offset + i++);\n          if (a < 0xF0) {\n            codePoint = (a & 0x0F) << 12 | (b & 0x3F) << 6 | c & 0x3F;\n          } else {\n            const d = this.readUint8(offset + i++);\n            codePoint = (a & 0x07) << 18 | (b & 0x3F) << 12 | (c & 0x3F) << 6 | d & 0x3F;\n          }\n        }\n      }\n      // Encode UTF-16\n      if (codePoint < 0x10000) {\n        result += String.fromCharCode(codePoint);\n      } else {\n        codePoint -= 0x10000;\n        result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & (1 << 10) - 1) + 0xDC00);\n      }\n    }\n    return result;\n  }\n  /**\r\n   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\r\n   * if a string then return a new one\r\n   *\r\n   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\r\n   * makes the behaviour of __union_with_string different compared to __union\r\n   */\n  __union_with_string(o, offset) {\n    if (typeof o === 'string') {\n      return this.__string(offset);\n    }\n    return this.__union(o, offset);\n  }\n  /**\r\n   * Retrieve the relative offset stored at \"offset\"\r\n   */\n  __indirect(offset) {\n    return offset + this.readInt32(offset);\n  }\n  /**\r\n   * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\r\n   */\n  __vector(offset) {\n    return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n  }\n  /**\r\n   * Get the length of a vector whose offset is stored at \"offset\" in this object.\r\n   */\n  __vector_len(offset) {\n    return this.readInt32(offset + this.readInt32(offset));\n  }\n  __has_identifier(ident) {\n    if (ident.length != FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' + FILE_IDENTIFIER_LENGTH);\n    }\n    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\r\n   * A helper function to avoid generated code depending on this file directly.\r\n   */\n  createLong(low, high) {\n    return Long.create(low, high);\n  }\n  /**\r\n   * A helper function for generating list for obj api\r\n   */\n  createScalarList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      if (listAccessor(i) !== null) {\n        ret.push(listAccessor(i));\n      }\n    }\n    return ret;\n  }\n  /**\r\n   * A helper function for generating list for obj api\r\n   * @param listAccessor function that accepts an index and return data at that index\r\n   * @param listLength listLength\r\n   * @param res result list\r\n   */\n  createObjList(listAccessor, listLength) {\n    const ret = [];\n    for (let i = 0; i < listLength; ++i) {\n      const val = listAccessor(i);\n      if (val !== null) {\n        ret.push(val.unpack());\n      }\n    }\n    return ret;\n  }\n}","map":{"version":3,"names":["FILE_IDENTIFIER_LENGTH","SIZEOF_INT","Long","int32","isLittleEndian","float32","float64","Encoding","ByteBuffer","constructor","bytes_","position_","allocate","byte_size","Uint8Array","clear","bytes","position","setPosition","capacity","length","readInt8","offset","readUint8","readInt16","readUint16","readInt32","readUint32","readInt64","readUint64","readFloat32","readFloat64","writeInt8","value","writeUint8","writeInt16","writeUint16","writeInt32","writeUint32","writeInt64","low","high","writeUint64","writeFloat32","writeFloat64","getBufferIdentifier","Error","result","i","String","fromCharCode","__offset","bb_pos","vtable_offset","vtable","__union","t","bb","__string","opt_encoding","UTF8_BYTES","subarray","codePoint","a","b","c","d","__union_with_string","o","__indirect","__vector","__vector_len","__has_identifier","ident","charCodeAt","createLong","create","createScalarList","listAccessor","listLength","ret","push","createObjList","val","unpack"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/flatbuffers/mjs/byte-buffer.js"],"sourcesContent":["import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from \"./constants\";\r\nimport { Long } from \"./long\";\r\nimport { int32, isLittleEndian, float32, float64 } from \"./utils\";\r\nimport { Encoding } from \"./encoding\";\r\nexport class ByteBuffer {\r\n    /**\r\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\r\n     */\r\n    constructor(bytes_) {\r\n        this.bytes_ = bytes_;\r\n        this.position_ = 0;\r\n    }\r\n    /**\r\n     * Create and allocate a new ByteBuffer with a given size.\r\n     */\r\n    static allocate(byte_size) {\r\n        return new ByteBuffer(new Uint8Array(byte_size));\r\n    }\r\n    clear() {\r\n        this.position_ = 0;\r\n    }\r\n    /**\r\n     * Get the underlying `Uint8Array`.\r\n     */\r\n    bytes() {\r\n        return this.bytes_;\r\n    }\r\n    /**\r\n     * Get the buffer's position.\r\n     */\r\n    position() {\r\n        return this.position_;\r\n    }\r\n    /**\r\n     * Set the buffer's position.\r\n     */\r\n    setPosition(position) {\r\n        this.position_ = position;\r\n    }\r\n    /**\r\n     * Get the buffer's capacity.\r\n     */\r\n    capacity() {\r\n        return this.bytes_.length;\r\n    }\r\n    readInt8(offset) {\r\n        return this.readUint8(offset) << 24 >> 24;\r\n    }\r\n    readUint8(offset) {\r\n        return this.bytes_[offset];\r\n    }\r\n    readInt16(offset) {\r\n        return this.readUint16(offset) << 16 >> 16;\r\n    }\r\n    readUint16(offset) {\r\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\r\n    }\r\n    readInt32(offset) {\r\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\r\n    }\r\n    readUint32(offset) {\r\n        return this.readInt32(offset) >>> 0;\r\n    }\r\n    readInt64(offset) {\r\n        return new Long(this.readInt32(offset), this.readInt32(offset + 4));\r\n    }\r\n    readUint64(offset) {\r\n        return new Long(this.readUint32(offset), this.readUint32(offset + 4));\r\n    }\r\n    readFloat32(offset) {\r\n        int32[0] = this.readInt32(offset);\r\n        return float32[0];\r\n    }\r\n    readFloat64(offset) {\r\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\r\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\r\n        return float64[0];\r\n    }\r\n    writeInt8(offset, value) {\r\n        this.bytes_[offset] = value;\r\n    }\r\n    writeUint8(offset, value) {\r\n        this.bytes_[offset] = value;\r\n    }\r\n    writeInt16(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n    }\r\n    writeUint16(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n    }\r\n    writeInt32(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n        this.bytes_[offset + 2] = value >> 16;\r\n        this.bytes_[offset + 3] = value >> 24;\r\n    }\r\n    writeUint32(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n        this.bytes_[offset + 2] = value >> 16;\r\n        this.bytes_[offset + 3] = value >> 24;\r\n    }\r\n    writeInt64(offset, value) {\r\n        this.writeInt32(offset, value.low);\r\n        this.writeInt32(offset + 4, value.high);\r\n    }\r\n    writeUint64(offset, value) {\r\n        this.writeUint32(offset, value.low);\r\n        this.writeUint32(offset + 4, value.high);\r\n    }\r\n    writeFloat32(offset, value) {\r\n        float32[0] = value;\r\n        this.writeInt32(offset, int32[0]);\r\n    }\r\n    writeFloat64(offset, value) {\r\n        float64[0] = value;\r\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\r\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\r\n    }\r\n    /**\r\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\r\n     * schema does not include a file_identifier (likely points at padding or the\r\n     * start of a the root vtable).\r\n     */\r\n    getBufferIdentifier() {\r\n        if (this.bytes_.length < this.position_ + SIZEOF_INT +\r\n            FILE_IDENTIFIER_LENGTH) {\r\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\r\n        }\r\n        let result = \"\";\r\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\r\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\r\n     * field is not present.\r\n     */\r\n    __offset(bb_pos, vtable_offset) {\r\n        const vtable = bb_pos - this.readInt32(bb_pos);\r\n        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\r\n    }\r\n    /**\r\n     * Initialize any Table-derived type to point to the union at the given offset.\r\n     */\r\n    __union(t, offset) {\r\n        t.bb_pos = offset + this.readInt32(offset);\r\n        t.bb = this;\r\n        return t;\r\n    }\r\n    /**\r\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\r\n     * This allocates a new string and converts to wide chars upon each access.\r\n     *\r\n     * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as\r\n     * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\r\n     * and from UTF-16 when the data will just be packaged back up in another\r\n     * FlatBuffer later on.\r\n     *\r\n     * @param offset\r\n     * @param opt_encoding Defaults to UTF16_STRING\r\n     */\r\n    __string(offset, opt_encoding) {\r\n        offset += this.readInt32(offset);\r\n        const length = this.readInt32(offset);\r\n        let result = '';\r\n        let i = 0;\r\n        offset += SIZEOF_INT;\r\n        if (opt_encoding === Encoding.UTF8_BYTES) {\r\n            return this.bytes_.subarray(offset, offset + length);\r\n        }\r\n        while (i < length) {\r\n            let codePoint;\r\n            // Decode UTF-8\r\n            const a = this.readUint8(offset + i++);\r\n            if (a < 0xC0) {\r\n                codePoint = a;\r\n            }\r\n            else {\r\n                const b = this.readUint8(offset + i++);\r\n                if (a < 0xE0) {\r\n                    codePoint =\r\n                        ((a & 0x1F) << 6) |\r\n                            (b & 0x3F);\r\n                }\r\n                else {\r\n                    const c = this.readUint8(offset + i++);\r\n                    if (a < 0xF0) {\r\n                        codePoint =\r\n                            ((a & 0x0F) << 12) |\r\n                                ((b & 0x3F) << 6) |\r\n                                (c & 0x3F);\r\n                    }\r\n                    else {\r\n                        const d = this.readUint8(offset + i++);\r\n                        codePoint =\r\n                            ((a & 0x07) << 18) |\r\n                                ((b & 0x3F) << 12) |\r\n                                ((c & 0x3F) << 6) |\r\n                                (d & 0x3F);\r\n                    }\r\n                }\r\n            }\r\n            // Encode UTF-16\r\n            if (codePoint < 0x10000) {\r\n                result += String.fromCharCode(codePoint);\r\n            }\r\n            else {\r\n                codePoint -= 0x10000;\r\n                result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & ((1 << 10) - 1)) + 0xDC00);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\r\n     * if a string then return a new one\r\n     *\r\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\r\n     * makes the behaviour of __union_with_string different compared to __union\r\n     */\r\n    __union_with_string(o, offset) {\r\n        if (typeof o === 'string') {\r\n            return this.__string(offset);\r\n        }\r\n        return this.__union(o, offset);\r\n    }\r\n    /**\r\n     * Retrieve the relative offset stored at \"offset\"\r\n     */\r\n    __indirect(offset) {\r\n        return offset + this.readInt32(offset);\r\n    }\r\n    /**\r\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\r\n     */\r\n    __vector(offset) {\r\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\r\n    }\r\n    /**\r\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\r\n     */\r\n    __vector_len(offset) {\r\n        return this.readInt32(offset + this.readInt32(offset));\r\n    }\r\n    __has_identifier(ident) {\r\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\r\n            throw new Error('FlatBuffers: file identifier must be length ' +\r\n                FILE_IDENTIFIER_LENGTH);\r\n        }\r\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\r\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A helper function to avoid generated code depending on this file directly.\r\n     */\r\n    createLong(low, high) {\r\n        return Long.create(low, high);\r\n    }\r\n    /**\r\n     * A helper function for generating list for obj api\r\n     */\r\n    createScalarList(listAccessor, listLength) {\r\n        const ret = [];\r\n        for (let i = 0; i < listLength; ++i) {\r\n            if (listAccessor(i) !== null) {\r\n                ret.push(listAccessor(i));\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    /**\r\n     * A helper function for generating list for obj api\r\n     * @param listAccessor function that accepts an index and return data at that index\r\n     * @param listLength listLength\r\n     * @param res result list\r\n     */\r\n    createObjList(listAccessor, listLength) {\r\n        const ret = [];\r\n        for (let i = 0; i < listLength; ++i) {\r\n            const val = listAccessor(i);\r\n            if (val !== null) {\r\n                ret.push(val.unpack());\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}