{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { DictionaryKind } from './dictionary-kind.mjs';\nimport { Int } from './int.mjs';\nexport class DictionaryEncoding {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  static getRootAsDictionaryEncoding(bb, obj) {\n    return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {\n    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n    return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  /**\n   * The known dictionary id in the application where this data is used. In\n   * the file or streaming formats, the dictionary ids are found in the\n   * DictionaryBatch messages\n   */\n  id() {\n    const offset = this.bb.__offset(this.bb_pos, 4);\n    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);\n  }\n  /**\n   * The dictionary indices are constrained to be non-negative integers. If\n   * this field is null, the indices must be signed int32. To maximize\n   * cross-language compatibility and performance, implementations are\n   * recommended to prefer signed integer types over unsigned integer types\n   * and to avoid uint64 indices unless they are required by an application.\n   */\n  indexType(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  /**\n   * By default, dictionaries are not ordered, or the order does not have\n   * semantic meaning. In some statistical, applications, dictionary-encoding\n   * is used to represent ordered categorical data, and we provide a way to\n   * preserve that metadata here\n   */\n  isOrdered() {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n  }\n  dictionaryKind() {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;\n  }\n  static startDictionaryEncoding(builder) {\n    builder.startObject(4);\n  }\n  static addId(builder, id) {\n    builder.addFieldInt64(0, id, builder.createLong(0, 0));\n  }\n  static addIndexType(builder, indexTypeOffset) {\n    builder.addFieldOffset(1, indexTypeOffset, 0);\n  }\n  static addIsOrdered(builder, isOrdered) {\n    builder.addFieldInt8(2, +isOrdered, +false);\n  }\n  static addDictionaryKind(builder, dictionaryKind) {\n    builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);\n  }\n  static endDictionaryEncoding(builder) {\n    const offset = builder.endObject();\n    return offset;\n  }\n}","map":{"version":3,"names":["flatbuffers","DictionaryKind","Int","DictionaryEncoding","constructor","bb","bb_pos","__init","i","getRootAsDictionaryEncoding","obj","readInt32","position","getSizePrefixedRootAsDictionaryEncoding","setPosition","SIZE_PREFIX_LENGTH","id","offset","__offset","readInt64","createLong","indexType","__indirect","isOrdered","readInt8","dictionaryKind","readInt16","DenseArray","startDictionaryEncoding","builder","startObject","addId","addFieldInt64","addIndexType","indexTypeOffset","addFieldOffset","addIsOrdered","addFieldInt8","addDictionaryKind","addFieldInt16","endDictionaryEncoding","endObject"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/fb/dictionary-encoding.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { DictionaryKind } from './dictionary-kind.js';\nimport { Int } from './int.js';\n\n\nexport class DictionaryEncoding {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):DictionaryEncoding {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsDictionaryEncoding(bb:flatbuffers.ByteBuffer, obj?:DictionaryEncoding):DictionaryEncoding {\n  return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsDictionaryEncoding(bb:flatbuffers.ByteBuffer, obj?:DictionaryEncoding):DictionaryEncoding {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\n/**\n * The known dictionary id in the application where this data is used. In\n * the file or streaming formats, the dictionary ids are found in the\n * DictionaryBatch messages\n */\nid():flatbuffers.Long {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n}\n\n/**\n * The dictionary indices are constrained to be non-negative integers. If\n * this field is null, the indices must be signed int32. To maximize\n * cross-language compatibility and performance, implementations are\n * recommended to prefer signed integer types over unsigned integer types\n * and to avoid uint64 indices unless they are required by an application.\n */\nindexType(obj?:Int):Int|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * By default, dictionaries are not ordered, or the order does not have\n * semantic meaning. In some statistical, applications, dictionary-encoding\n * is used to represent ordered categorical data, and we provide a way to\n * preserve that metadata here\n */\nisOrdered():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\ndictionaryKind():DictionaryKind {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? this.bb!.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;\n}\n\nstatic startDictionaryEncoding(builder:flatbuffers.Builder) {\n  builder.startObject(4);\n}\n\nstatic addId(builder:flatbuffers.Builder, id:flatbuffers.Long) {\n  builder.addFieldInt64(0, id, builder.createLong(0, 0));\n}\n\nstatic addIndexType(builder:flatbuffers.Builder, indexTypeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, indexTypeOffset, 0);\n}\n\nstatic addIsOrdered(builder:flatbuffers.Builder, isOrdered:boolean) {\n  builder.addFieldInt8(2, +isOrdered, +false);\n}\n\nstatic addDictionaryKind(builder:flatbuffers.Builder, dictionaryKind:DictionaryKind) {\n  builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);\n}\n\nstatic endDictionaryEncoding(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}