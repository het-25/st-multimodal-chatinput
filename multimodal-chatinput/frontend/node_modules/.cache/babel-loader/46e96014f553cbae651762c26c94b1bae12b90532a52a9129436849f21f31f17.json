{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\n/**\n * ----------------------------------------------------------------------\n * A Buffer represents a single contiguous memory segment\n */\nexport class Buffer {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  /**\n   * The relative offset into the shared memory page where the bytes for this\n   * buffer starts\n   */\n  offset() {\n    return this.bb.readInt64(this.bb_pos);\n  }\n  /**\n   * The absolute length (in bytes) of the memory buffer. The memory is found\n   * from offset (inclusive) to offset + length (non-inclusive). When building\n   * messages using the encapsulated IPC message, padding bytes may be written\n   * after a buffer, but such padding bytes do not need to be accounted for in\n   * the size here.\n   */\n  length() {\n    return this.bb.readInt64(this.bb_pos + 8);\n  }\n  static sizeOf() {\n    return 16;\n  }\n  static createBuffer(builder, offset, length) {\n    builder.prep(8, 16);\n    builder.writeInt64(length);\n    builder.writeInt64(offset);\n    return builder.offset();\n  }\n}","map":{"version":3,"names":["Buffer","constructor","bb","bb_pos","__init","i","offset","readInt64","length","sizeOf","createBuffer","builder","prep","writeInt64"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/template/my_component/frontend/node_modules/apache-arrow/src/fb/buffer.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\n/**\n * ----------------------------------------------------------------------\n * A Buffer represents a single contiguous memory segment\n */\nexport class Buffer {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):Buffer {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\n/**\n * The relative offset into the shared memory page where the bytes for this\n * buffer starts\n */\noffset():flatbuffers.Long {\n  return this.bb!.readInt64(this.bb_pos);\n}\n\n/**\n * The absolute length (in bytes) of the memory buffer. The memory is found\n * from offset (inclusive) to offset + length (non-inclusive). When building\n * messages using the encapsulated IPC message, padding bytes may be written\n * after a buffer, but such padding bytes do not need to be accounted for in\n * the size here.\n */\nlength():flatbuffers.Long {\n  return this.bb!.readInt64(this.bb_pos + 8);\n}\n\nstatic sizeOf():number {\n  return 16;\n}\n\nstatic createBuffer(builder:flatbuffers.Builder, offset: flatbuffers.Long, length: flatbuffers.Long):flatbuffers.Offset {\n  builder.prep(8, 16);\n  builder.writeInt64(length);\n  builder.writeInt64(offset);\n  return builder.offset();\n}\n\n}\n"],"mappings":"AAAA;AAIA;;;;AAIA,OAAM,MAAOA,MAAM;EAAnBC,YAAA;IACE,KAAAC,EAAE,GAAgC,IAAI;IACtC,KAAAC,MAAM,GAAG,CAAC;EAqCZ;EApCAC,MAAMA,CAACC,CAAQ,EAAEH,EAAyB;IACxC,IAAI,CAACC,MAAM,GAAGE,CAAC;IACf,IAAI,CAACH,EAAE,GAAGA,EAAE;IACZ,OAAO,IAAI;EACb;EAEA;;;;EAIAI,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACJ,EAAG,CAACK,SAAS,CAAC,IAAI,CAACJ,MAAM,CAAC;EACxC;EAEA;;;;;;;EAOAK,MAAMA,CAAA;IACJ,OAAO,IAAI,CAACN,EAAG,CAACK,SAAS,CAAC,IAAI,CAACJ,MAAM,GAAG,CAAC,CAAC;EAC5C;EAEA,OAAOM,MAAMA,CAAA;IACX,OAAO,EAAE;EACX;EAEA,OAAOC,YAAYA,CAACC,OAA2B,EAAEL,MAAwB,EAAEE,MAAwB;IACjGG,OAAO,CAACC,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC;IACnBD,OAAO,CAACE,UAAU,CAACL,MAAM,CAAC;IAC1BG,OAAO,CAACE,UAAU,CAACP,MAAM,CAAC;IAC1B,OAAOK,OAAO,CAACL,MAAM,EAAE;EACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}