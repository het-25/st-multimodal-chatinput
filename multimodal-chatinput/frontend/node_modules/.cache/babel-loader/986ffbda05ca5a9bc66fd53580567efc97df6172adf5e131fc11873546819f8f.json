{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Buffer } from './buffer.mjs';\nimport { SparseTensorIndex } from './sparse-tensor-index.mjs';\nimport { TensorDim } from './tensor-dim.mjs';\nimport { Type } from './type.mjs';\nexport class SparseTensor {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  static getRootAsSparseTensor(bb, obj) {\n    return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  static getSizePrefixedRootAsSparseTensor(bb, obj) {\n    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n    return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  typeType() {\n    const offset = this.bb.__offset(this.bb_pos, 4);\n    return offset ? this.bb.readUint8(this.bb_pos + offset) : Type.NONE;\n  }\n  /**\n   * The type of data contained in a value cell.\n   * Currently only fixed-width value types are supported,\n   * no strings or nested types.\n   */\n  // @ts-ignore\n  type(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;\n  }\n  /**\n   * The dimensions of the tensor, optionally named.\n   */\n  shape(index, obj) {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? (obj || new TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;\n  }\n  shapeLength() {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  /**\n   * The number of non-zero values in a sparse tensor.\n   */\n  nonZeroLength() {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);\n  }\n  sparseIndexType() {\n    const offset = this.bb.__offset(this.bb_pos, 12);\n    return offset ? this.bb.readUint8(this.bb_pos + offset) : SparseTensorIndex.NONE;\n  }\n  /**\n   * Sparse tensor index\n   */\n  // @ts-ignore\n  sparseIndex(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 14);\n    return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;\n  }\n  /**\n   * The location and size of the tensor's data\n   */\n  data(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 16);\n    return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb) : null;\n  }\n  static startSparseTensor(builder) {\n    builder.startObject(7);\n  }\n  static addTypeType(builder, typeType) {\n    builder.addFieldInt8(0, typeType, Type.NONE);\n  }\n  static addType(builder, typeOffset) {\n    builder.addFieldOffset(1, typeOffset, 0);\n  }\n  static addShape(builder, shapeOffset) {\n    builder.addFieldOffset(2, shapeOffset, 0);\n  }\n  static createShapeVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addOffset(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startShapeVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static addNonZeroLength(builder, nonZeroLength) {\n    builder.addFieldInt64(3, nonZeroLength, builder.createLong(0, 0));\n  }\n  static addSparseIndexType(builder, sparseIndexType) {\n    builder.addFieldInt8(4, sparseIndexType, SparseTensorIndex.NONE);\n  }\n  static addSparseIndex(builder, sparseIndexOffset) {\n    builder.addFieldOffset(5, sparseIndexOffset, 0);\n  }\n  static addData(builder, dataOffset) {\n    builder.addFieldStruct(6, dataOffset, 0);\n  }\n  static endSparseTensor(builder) {\n    const offset = builder.endObject();\n    builder.requiredField(offset, 6); // type\n    builder.requiredField(offset, 8); // shape\n    builder.requiredField(offset, 14); // sparseIndex\n    builder.requiredField(offset, 16); // data\n    return offset;\n  }\n  static finishSparseTensorBuffer(builder, offset) {\n    builder.finish(offset);\n  }\n  static finishSizePrefixedSparseTensorBuffer(builder, offset) {\n    builder.finish(offset, undefined, true);\n  }\n}","map":{"version":3,"names":["flatbuffers","Buffer","SparseTensorIndex","TensorDim","Type","SparseTensor","constructor","bb","bb_pos","__init","i","getRootAsSparseTensor","obj","readInt32","position","getSizePrefixedRootAsSparseTensor","setPosition","SIZE_PREFIX_LENGTH","typeType","offset","__offset","readUint8","NONE","type","__union","shape","index","__indirect","__vector","shapeLength","__vector_len","nonZeroLength","readInt64","createLong","sparseIndexType","sparseIndex","data","startSparseTensor","builder","startObject","addTypeType","addFieldInt8","addType","typeOffset","addFieldOffset","addShape","shapeOffset","createShapeVector","startVector","length","addOffset","endVector","startShapeVector","numElems","addNonZeroLength","addFieldInt64","addSparseIndexType","addSparseIndex","sparseIndexOffset","addData","dataOffset","addFieldStruct","endSparseTensor","endObject","requiredField","finishSparseTensorBuffer","finish","finishSizePrefixedSparseTensorBuffer","undefined"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/template/my_component/frontend/node_modules/apache-arrow/src/fb/sparse-tensor.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { Buffer } from './buffer.js';\nimport { SparseTensorIndex } from './sparse-tensor-index.js';\nimport { TensorDim } from './tensor-dim.js';\nimport { Type } from './type.js';\n\n\nexport class SparseTensor {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):SparseTensor {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsSparseTensor(bb:flatbuffers.ByteBuffer, obj?:SparseTensor):SparseTensor {\n  return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsSparseTensor(bb:flatbuffers.ByteBuffer, obj?:SparseTensor):SparseTensor {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\ntypeType():Type {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : Type.NONE;\n}\n\n/**\n * The type of data contained in a value cell.\n * Currently only fixed-width value types are supported,\n * no strings or nested types.\n */\n// @ts-ignore\ntype<T extends flatbuffers.Table>(obj:any):any|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\n}\n\n/**\n * The dimensions of the tensor, optionally named.\n */\nshape(index: number, obj?:TensorDim):TensorDim|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? (obj || new TensorDim()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;\n}\n\nshapeLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\n/**\n * The number of non-zero values in a sparse tensor.\n */\nnonZeroLength():flatbuffers.Long {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n}\n\nsparseIndexType():SparseTensorIndex {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? this.bb!.readUint8(this.bb_pos + offset) : SparseTensorIndex.NONE;\n}\n\n/**\n * Sparse tensor index\n */\n// @ts-ignore\nsparseIndex<T extends flatbuffers.Table>(obj:any):any|null {\n  const offset = this.bb!.__offset(this.bb_pos, 14);\n  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\n}\n\n/**\n * The location and size of the tensor's data\n */\ndata(obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 16);\n  return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb!) : null;\n}\n\nstatic startSparseTensor(builder:flatbuffers.Builder) {\n  builder.startObject(7);\n}\n\nstatic addTypeType(builder:flatbuffers.Builder, typeType:Type) {\n  builder.addFieldInt8(0, typeType, Type.NONE);\n}\n\nstatic addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, typeOffset, 0);\n}\n\nstatic addShape(builder:flatbuffers.Builder, shapeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(2, shapeOffset, 0);\n}\n\nstatic createShapeVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {\n  builder.startVector(4, data.length, 4);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addOffset(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startShapeVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(4, numElems, 4);\n}\n\nstatic addNonZeroLength(builder:flatbuffers.Builder, nonZeroLength:flatbuffers.Long) {\n  builder.addFieldInt64(3, nonZeroLength, builder.createLong(0, 0));\n}\n\nstatic addSparseIndexType(builder:flatbuffers.Builder, sparseIndexType:SparseTensorIndex) {\n  builder.addFieldInt8(4, sparseIndexType, SparseTensorIndex.NONE);\n}\n\nstatic addSparseIndex(builder:flatbuffers.Builder, sparseIndexOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(5, sparseIndexOffset, 0);\n}\n\nstatic addData(builder:flatbuffers.Builder, dataOffset:flatbuffers.Offset) {\n  builder.addFieldStruct(6, dataOffset, 0);\n}\n\nstatic endSparseTensor(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  builder.requiredField(offset, 6) // type\n  builder.requiredField(offset, 8) // shape\n  builder.requiredField(offset, 14) // sparseIndex\n  builder.requiredField(offset, 16) // data\n  return offset;\n}\n\nstatic finishSparseTensorBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\n  builder.finish(offset);\n}\n\nstatic finishSizePrefixedSparseTensorBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {\n  builder.finish(offset, undefined, true);\n}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}