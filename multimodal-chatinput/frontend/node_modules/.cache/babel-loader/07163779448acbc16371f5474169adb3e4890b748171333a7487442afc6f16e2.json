{"ast":null,"code":"import _regeneratorRuntime from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { Field, Schema } from './schema.mjs';\nimport * as dtypes from './type.mjs';\nimport { Data } from './data.mjs';\nimport { Vector, makeVector } from './vector.mjs';\nimport { instance as getBuilderConstructor } from './visitor/builderctor.mjs';\nimport { Table } from './table.mjs';\nimport { RecordBatch } from './recordbatch.mjs';\nimport { compareTypes } from './visitor/typecomparator.mjs';\nexport function makeBuilder(options) {\n  var type = options.type;\n  var builder = new (getBuilderConstructor.getVisitFn(type)())(options);\n  if (type.children && type.children.length > 0) {\n    var children = options['children'] || [];\n    var defaultOptions = {\n      'nullValues': options['nullValues']\n    };\n    var getChildOptions = Array.isArray(children) ? function (_, i) {\n      return children[i] || defaultOptions;\n    } : function (_ref) {\n      var name = _ref.name;\n      return children[name] || defaultOptions;\n    };\n    var _iterator = _createForOfIteratorHelper(type.children.entries()),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          index = _step$value[0],\n          field = _step$value[1];\n        var _type = field.type;\n        var opts = getChildOptions(field, index);\n        builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), {\n          type: _type\n        })));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  return builder;\n}\nexport function vectorFromArray(init, type) {\n  if (init instanceof Data || init instanceof Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {\n    return makeVector(init);\n  }\n  var options = {\n    type: type !== null && type !== void 0 ? type : inferType(init),\n    nullValues: [null]\n  };\n  var chunks = _toConsumableArray(builderThroughIterable(options)(init));\n  var vector = chunks.length === 1 ? chunks[0] : chunks.reduce(function (a, b) {\n    return a.concat(b);\n  });\n  if (dtypes.DataType.isDictionary(vector.type)) {\n    return vector.memoize();\n  }\n  return vector;\n}\n/**\n * Creates a {@link Table} from an array of objects.\n *\n * @param array A table of objects.\n */\nexport function tableFromJSON(array) {\n  var vector = vectorFromArray(array);\n  var batch = new RecordBatch(new Schema(vector.type.children), vector.data[0]);\n  return new Table(batch);\n}\nfunction inferType(value) {\n  if (value.length === 0) {\n    return new dtypes.Null();\n  }\n  var nullsCount = 0;\n  var arraysCount = 0;\n  var objectsCount = 0;\n  var numbersCount = 0;\n  var stringsCount = 0;\n  var bigintsCount = 0;\n  var booleansCount = 0;\n  var datesCount = 0;\n  var _iterator2 = _createForOfIteratorHelper(value),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var val = _step2.value;\n      if (val == null) {\n        ++nullsCount;\n        continue;\n      }\n      switch (typeof val) {\n        case 'bigint':\n          ++bigintsCount;\n          continue;\n        case 'boolean':\n          ++booleansCount;\n          continue;\n        case 'number':\n          ++numbersCount;\n          continue;\n        case 'string':\n          ++stringsCount;\n          continue;\n        case 'object':\n          if (Array.isArray(val)) {\n            ++arraysCount;\n          } else if (Object.prototype.toString.call(val) === '[object Date]') {\n            ++datesCount;\n          } else {\n            ++objectsCount;\n          }\n          continue;\n      }\n      throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (numbersCount + nullsCount === value.length) {\n    return new dtypes.Float64();\n  } else if (stringsCount + nullsCount === value.length) {\n    return new dtypes.Dictionary(new dtypes.Utf8(), new dtypes.Int32());\n  } else if (bigintsCount + nullsCount === value.length) {\n    return new dtypes.Int64();\n  } else if (booleansCount + nullsCount === value.length) {\n    return new dtypes.Bool();\n  } else if (datesCount + nullsCount === value.length) {\n    return new dtypes.DateMillisecond();\n  } else if (arraysCount + nullsCount === value.length) {\n    var array = value;\n    var childType = inferType(array[array.findIndex(function (ary) {\n      return ary != null;\n    })]);\n    if (array.every(function (ary) {\n      return ary == null || compareTypes(childType, inferType(ary));\n    })) {\n      return new dtypes.List(new Field('', childType, true));\n    }\n  } else if (objectsCount + nullsCount === value.length) {\n    var fields = new Map();\n    var _iterator3 = _createForOfIteratorHelper(value),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var row = _step3.value;\n        for (var _i = 0, _Object$keys = Object.keys(row); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          if (!fields.has(key) && row[key] != null) {\n            // use the type inferred for the first instance of a found key\n            fields.set(key, new Field(key, inferType([row[key]]), true));\n          }\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return new dtypes.Struct(_toConsumableArray(fields.values()));\n  }\n  throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n}\n/**\n * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `Iterable` of values to\n * transform. When called, this function returns an Iterator of `Vector<T>`.\n *\n * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `Iterable` of values to\n *          write, and returns an `Iterator` that yields Vectors according\n *          to the chunking semantics defined in the `options` argument.\n * @nocollapse\n */\nexport function builderThroughIterable(options) {\n  var _options$queueingStra = options['queueingStrategy'],\n    queueingStrategy = _options$queueingStra === void 0 ? 'count' : _options$queueingStra;\n  var _options$highWaterMar = options['highWaterMark'],\n    highWaterMark = _options$highWaterMar === void 0 ? queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) : _options$highWaterMar;\n  var sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n    var numChunks, builder, _iterator4, _step4, value;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          numChunks = 0;\n          builder = makeBuilder(options);\n          _iterator4 = _createForOfIteratorHelper(source);\n          _context.prev = 3;\n          _iterator4.s();\n        case 5:\n          if ((_step4 = _iterator4.n()).done) {\n            _context.next = 14;\n            break;\n          }\n          value = _step4.value;\n          if (!(builder.append(value)[sizeProperty] >= highWaterMark)) {\n            _context.next = 12;\n            break;\n          }\n          _context.t0 = ++numChunks;\n          if (!_context.t0) {\n            _context.next = 12;\n            break;\n          }\n          _context.next = 12;\n          return builder.toVector();\n        case 12:\n          _context.next = 5;\n          break;\n        case 14:\n          _context.next = 19;\n          break;\n        case 16:\n          _context.prev = 16;\n          _context.t1 = _context[\"catch\"](3);\n          _iterator4.e(_context.t1);\n        case 19:\n          _context.prev = 19;\n          _iterator4.f();\n          return _context.finish(19);\n        case 22:\n          if (!(builder.finish().length > 0 || numChunks === 0)) {\n            _context.next = 25;\n            break;\n          }\n          _context.next = 25;\n          return builder.toVector();\n        case 25:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[3, 16, 19, 22]]);\n  });\n}\n/**\n * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `AsyncIterable` of values to\n * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n *\n * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `AsyncIterable` of values\n *          to write, and returns an `AsyncIterator` that yields Vectors\n *          according to the chunking semantics defined in the `options`\n *          argument.\n * @nocollapse\n */\nexport function builderThroughAsyncIterable(options) {\n  var _options$queueingStra2 = options['queueingStrategy'],\n    queueingStrategy = _options$queueingStra2 === void 0 ? 'count' : _options$queueingStra2;\n  var _options$highWaterMar2 = options['highWaterMark'],\n    highWaterMark = _options$highWaterMar2 === void 0 ? queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) : _options$highWaterMar2;\n  var sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return function (source) {\n    return __asyncGenerator(this, arguments, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var e_1, _a, numChunks, builder, source_1, source_1_1, value;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            numChunks = 0;\n            builder = makeBuilder(options);\n            _context2.prev = 2;\n            source_1 = __asyncValues(source);\n          case 4:\n            _context2.next = 6;\n            return __await(source_1.next());\n          case 6:\n            source_1_1 = _context2.sent;\n            if (source_1_1.done) {\n              _context2.next = 18;\n              break;\n            }\n            value = source_1_1.value;\n            if (!(builder.append(value)[sizeProperty] >= highWaterMark)) {\n              _context2.next = 16;\n              break;\n            }\n            _context2.t0 = ++numChunks;\n            if (!_context2.t0) {\n              _context2.next = 16;\n              break;\n            }\n            _context2.next = 14;\n            return __await(builder.toVector());\n          case 14:\n            _context2.next = 16;\n            return _context2.sent;\n          case 16:\n            _context2.next = 4;\n            break;\n          case 18:\n            _context2.next = 23;\n            break;\n          case 20:\n            _context2.prev = 20;\n            _context2.t1 = _context2[\"catch\"](2);\n            e_1 = {\n              error: _context2.t1\n            };\n          case 23:\n            _context2.prev = 23;\n            _context2.prev = 24;\n            if (!(source_1_1 && !source_1_1.done && (_a = source_1.return))) {\n              _context2.next = 28;\n              break;\n            }\n            _context2.next = 28;\n            return __await(_a.call(source_1));\n          case 28:\n            _context2.prev = 28;\n            if (!e_1) {\n              _context2.next = 31;\n              break;\n            }\n            throw e_1.error;\n          case 31:\n            return _context2.finish(28);\n          case 32:\n            return _context2.finish(23);\n          case 33:\n            if (!(builder.finish().length > 0 || numChunks === 0)) {\n              _context2.next = 38;\n              break;\n            }\n            _context2.next = 36;\n            return __await(builder.toVector());\n          case 36:\n            _context2.next = 38;\n            return _context2.sent;\n          case 38:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[2, 20, 23, 33], [24,, 28, 32]]);\n    }));\n  };\n}","map":{"version":3,"names":["Field","Schema","dtypes","Data","Vector","makeVector","instance","getBuilderConstructor","Table","RecordBatch","compareTypes","makeBuilder","options","type","builder","getVisitFn","children","length","defaultOptions","getChildOptions","Array","isArray","_","i","_ref","name","_iterator","_createForOfIteratorHelper","entries","_step","s","n","done","_step$value","_slicedToArray","value","index","field","opts","push","Object","assign","err","e","f","vectorFromArray","init","DataType","ArrayBuffer","isView","inferType","nullValues","chunks","_toConsumableArray","builderThroughIterable","vector","reduce","a","b","concat","isDictionary","memoize","tableFromJSON","array","batch","data","Null","nullsCount","arraysCount","objectsCount","numbersCount","stringsCount","bigintsCount","booleansCount","datesCount","_iterator2","_step2","val","prototype","toString","call","TypeError","Float64","Dictionary","Utf8","Int32","Int64","Bool","DateMillisecond","childType","findIndex","ary","every","List","fields","Map","_iterator3","_step3","row","_i","_Object$keys","keys","key","has","set","Struct","values","_options$queueingStra","queueingStrategy","_options$highWaterMar","highWaterMark","Number","POSITIVE_INFINITY","Math","pow","sizeProperty","_regeneratorRuntime","mark","_callee","source","numChunks","_iterator4","_step4","wrap","_callee$","_context","prev","next","append","t0","toVector","t1","finish","stop","builderThroughAsyncIterable","_options$queueingStra2","_options$highWaterMar2","_context2","source_1","__asyncValues","__await","source_1_1","sent","_callee2"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/factories.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Field, Schema } from './schema.js';\nimport * as dtypes from './type.js';\nimport { Data, DataProps } from './data.js';\nimport { BuilderType, JavaScriptDataType } from './interfaces.js';\nimport { Vector, makeVector } from './vector.js';\nimport { Builder, BuilderOptions } from './builder.js';\nimport { instance as getBuilderConstructor } from './visitor/builderctor.js';\nimport { ArrayDataType, BigIntArray, JavaScriptArrayDataType, TypedArray, TypedArrayDataType } from './interfaces.js';\nimport { Table } from './table.js';\nimport { RecordBatch } from './recordbatch.js';\nimport { compareTypes } from './visitor/typecomparator.js';\n\nexport function makeBuilder<T extends dtypes.DataType = any, TNull = any>(options: BuilderOptions<T, TNull>): BuilderType<T, TNull> {\n\n    const type = options.type;\n    const builder = new (getBuilderConstructor.getVisitFn<T>(type)())(options) as Builder<T, TNull>;\n\n    if (type.children && type.children.length > 0) {\n\n        const children = options['children'] || [] as BuilderOptions[];\n        const defaultOptions = { 'nullValues': options['nullValues'] };\n        const getChildOptions = Array.isArray(children)\n            ? ((_: Field, i: number) => children[i] || defaultOptions)\n            : (({ name }: Field) => children[name] || defaultOptions);\n\n        for (const [index, field] of type.children.entries()) {\n            const { type } = field;\n            const opts = getChildOptions(field, index);\n            builder.children.push(makeBuilder({ ...opts, type }));\n        }\n    }\n\n    return builder as BuilderType<T, TNull>;\n}\n\n/**\n * Creates a Vector from a JavaScript array via a {@link Builder}.\n * Use {@link makeVector} if you only want to create a vector from a typed array.\n *\n * @example\n * ```ts\n * const vf64 = vectorFromArray([1, 2, 3]);\n * const vi8 = vectorFromArray([1, 2, 3], new Int8);\n * const vdict = vectorFromArray(['foo', 'bar']);\n * const vstruct = vectorFromArray([{a: 'foo', b: 42}, {a: 'bar', b: 12}]);\n * ```\n */\nexport function vectorFromArray(values: readonly (null | undefined)[], type?: dtypes.Null): Vector<dtypes.Null>;\nexport function vectorFromArray(values: readonly (null | undefined | boolean)[], type?: dtypes.Bool): Vector<dtypes.Bool>;\nexport function vectorFromArray<T extends dtypes.Utf8 | dtypes.Dictionary<dtypes.Utf8> = dtypes.Dictionary<dtypes.Utf8, dtypes.Int32>>(values: readonly (null | undefined | string)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Date_>(values: readonly (null | undefined | Date)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Int>(values: readonly (null | undefined | number)[], type: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Int64 | dtypes.Uint64 = dtypes.Int64>(values: readonly (null | undefined | bigint)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Float = dtypes.Float64>(values: readonly (null | undefined | number)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.DataType>(values: readonly (unknown)[], type: T): Vector<T>;\nexport function vectorFromArray<T extends readonly unknown[]>(values: T): Vector<JavaScriptArrayDataType<T>>;\n/** Creates a Vector from a typed array via {@link makeVector}. */\nexport function vectorFromArray<T extends TypedArray | BigIntArray>(data: T): Vector<TypedArrayDataType<T>>;\n\nexport function vectorFromArray<T extends dtypes.DataType>(data: Data<T>): Vector<T>;\nexport function vectorFromArray<T extends dtypes.DataType>(data: Vector<T>): Vector<T>;\nexport function vectorFromArray<T extends dtypes.DataType>(data: DataProps<T>): Vector<T>;\nexport function vectorFromArray<T extends TypedArray | BigIntArray | readonly unknown[]>(data: T): Vector<ArrayDataType<T>>;\n\nexport function vectorFromArray(init: any, type?: dtypes.DataType) {\n    if (init instanceof Data || init instanceof Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {\n        return makeVector(init as any);\n    }\n    const options: IterableBuilderOptions = { type: type ?? inferType(init), nullValues: [null] };\n    const chunks = [...builderThroughIterable(options)(init)];\n    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));\n    if (dtypes.DataType.isDictionary(vector.type)) {\n        return vector.memoize();\n    }\n    return vector;\n}\n\n/**\n * Creates a {@link Table} from an array of objects.\n *\n * @param array A table of objects.\n */\nexport function tableFromJSON<T extends Record<string, unknown>>(array: T[]): Table<{ [P in keyof T]: JavaScriptDataType<T[P]> }> {\n    const vector = vectorFromArray(array) as Vector<dtypes.Struct<any>>;\n    const batch = new RecordBatch(new Schema(vector.type.children), vector.data[0]);\n    return new Table(batch);\n}\n\n/** @ignore */\nfunction inferType<T extends readonly unknown[]>(values: T): JavaScriptArrayDataType<T>;\nfunction inferType(value: readonly unknown[]): dtypes.DataType {\n    if (value.length === 0) { return new dtypes.Null; }\n    let nullsCount = 0;\n    let arraysCount = 0;\n    let objectsCount = 0;\n    let numbersCount = 0;\n    let stringsCount = 0;\n    let bigintsCount = 0;\n    let booleansCount = 0;\n    let datesCount = 0;\n\n    for (const val of value) {\n        if (val == null) { ++nullsCount; continue; }\n        switch (typeof val) {\n            case 'bigint': ++bigintsCount; continue;\n            case 'boolean': ++booleansCount; continue;\n            case 'number': ++numbersCount; continue;\n            case 'string': ++stringsCount; continue;\n            case 'object':\n                if (Array.isArray(val)) {\n                    ++arraysCount;\n                } else if (Object.prototype.toString.call(val) === '[object Date]') {\n                    ++datesCount;\n                } else {\n                    ++objectsCount;\n                }\n                continue;\n        }\n        throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n    }\n\n    if (numbersCount + nullsCount === value.length) {\n        return new dtypes.Float64;\n    } else if (stringsCount + nullsCount === value.length) {\n        return new dtypes.Dictionary(new dtypes.Utf8, new dtypes.Int32);\n    } else if (bigintsCount + nullsCount === value.length) {\n        return new dtypes.Int64;\n    } else if (booleansCount + nullsCount === value.length) {\n        return new dtypes.Bool;\n    } else if (datesCount + nullsCount === value.length) {\n        return new dtypes.DateMillisecond;\n    } else if (arraysCount + nullsCount === value.length) {\n        const array = value as Array<unknown>[];\n        const childType = inferType(array[array.findIndex((ary) => ary != null)]);\n        if (array.every((ary) => ary == null || compareTypes(childType, inferType(ary)))) {\n            return new dtypes.List(new Field('', childType, true));\n        }\n    } else if (objectsCount + nullsCount === value.length) {\n        const fields = new Map<string, Field>();\n        for (const row of value as Record<string, unknown>[]) {\n            for (const key of Object.keys(row)) {\n                if (!fields.has(key) && row[key] != null) {\n                    // use the type inferred for the first instance of a found key\n                    fields.set(key, new Field(key, inferType([row[key]]), true));\n                }\n            }\n        }\n        return new dtypes.Struct([...fields.values()]);\n    }\n\n    throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n}\n\n/**\n * A set of options to create an Iterable or AsyncIterable `Builder` transform function.\n * @see {@link builderThroughIterable}\n * @see {@link builderThroughAsyncIterable}\n */\nexport interface IterableBuilderOptions<T extends dtypes.DataType = any, TNull = any> extends BuilderOptions<T, TNull> {\n    highWaterMark?: number;\n    queueingStrategy?: 'bytes' | 'count';\n    dictionaryHashFunction?: (value: any) => string | number;\n    valueToChildTypeId?: (builder: Builder<T, TNull>, value: any, offset: number) => number;\n}\n\n/** @ignore */\ntype ThroughIterable<T extends dtypes.DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull>) => IterableIterator<Vector<T>>;\n\n/**\n * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `Iterable` of values to\n * transform. When called, this function returns an Iterator of `Vector<T>`.\n *\n * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `Iterable` of values to\n *          write, and returns an `Iterator` that yields Vectors according\n *          to the chunking semantics defined in the `options` argument.\n * @nocollapse\n */\nexport function builderThroughIterable<T extends dtypes.DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return function* (source: Iterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        const builder = makeBuilder(options);\n        for (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    } as ThroughIterable<T, TNull>;\n}\n\n/** @ignore */\ntype ThroughAsyncIterable<T extends dtypes.DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) => AsyncIterableIterator<Vector<T>>;\n\n/**\n * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `AsyncIterable` of values to\n * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n *\n * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `AsyncIterable` of values\n *          to write, and returns an `AsyncIterator` that yields Vectors\n *          according to the chunking semantics defined in the `options`\n *          argument.\n * @nocollapse\n */\nexport function builderThroughAsyncIterable<T extends dtypes.DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return async function* (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        const builder = makeBuilder(options);\n        for await (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    } as ThroughAsyncIterable<T, TNull>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}