{"ast":null,"code":"import _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Buffer } from './buffer.mjs';\nimport { Int } from './int.mjs';\nimport { SparseMatrixCompressedAxis } from './sparse-matrix-compressed-axis.mjs';\n/**\n * Compressed Sparse format, that is matrix-specific.\n */\nexport var SparseMatrixIndexCSX = /*#__PURE__*/function () {\n  function SparseMatrixIndexCSX() {\n    _classCallCheck(this, SparseMatrixIndexCSX);\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  _createClass(SparseMatrixIndexCSX, [{\n    key: \"__init\",\n    value: function __init(i, bb) {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n  }, {\n    key: \"compressedAxis\",\n    value:\n    /**\n     * Which axis, row or column, is compressed\n     */\n    function compressedAxis() {\n      var offset = this.bb.__offset(this.bb_pos, 4);\n      return offset ? this.bb.readInt16(this.bb_pos + offset) : SparseMatrixCompressedAxis.Row;\n    }\n    /**\n     * The type of values in indptrBuffer\n     */\n  }, {\n    key: \"indptrType\",\n    value: function indptrType(obj) {\n      var offset = this.bb.__offset(this.bb_pos, 6);\n      return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    /**\n     * indptrBuffer stores the location and size of indptr array that\n     * represents the range of the rows.\n     * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.\n     * The length of this array is 1 + (the number of rows), and the type\n     * of index value is long.\n     *\n     * For example, let X be the following 6x4 matrix:\n     * ```text\n     *   X := [[0, 1, 2, 0],\n     *         [0, 0, 3, 0],\n     *         [0, 4, 0, 5],\n     *         [0, 0, 0, 0],\n     *         [6, 0, 7, 8],\n     *         [0, 9, 0, 0]].\n     * ```\n     * The array of non-zero values in X is:\n     * ```text\n     *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].\n     * ```\n     * And the indptr of X is:\n     * ```text\n     *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].\n     * ```\n     */\n  }, {\n    key: \"indptrBuffer\",\n    value: function indptrBuffer(obj) {\n      var offset = this.bb.__offset(this.bb_pos, 8);\n      return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb) : null;\n    }\n    /**\n     * The type of values in indicesBuffer\n     */\n  }, {\n    key: \"indicesType\",\n    value: function indicesType(obj) {\n      var offset = this.bb.__offset(this.bb_pos, 10);\n      return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    /**\n     * indicesBuffer stores the location and size of the array that\n     * contains the column indices of the corresponding non-zero values.\n     * The type of index value is long.\n     *\n     * For example, the indices of the above X is:\n     * ```text\n     *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].\n     * ```\n     * Note that the indices are sorted in lexicographical order for each row.\n     */\n  }, {\n    key: \"indicesBuffer\",\n    value: function indicesBuffer(obj) {\n      var offset = this.bb.__offset(this.bb_pos, 12);\n      return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb) : null;\n    }\n  }], [{\n    key: \"getRootAsSparseMatrixIndexCSX\",\n    value: function getRootAsSparseMatrixIndexCSX(bb, obj) {\n      return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n  }, {\n    key: \"getSizePrefixedRootAsSparseMatrixIndexCSX\",\n    value: function getSizePrefixedRootAsSparseMatrixIndexCSX(bb, obj) {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n  }, {\n    key: \"startSparseMatrixIndexCSX\",\n    value: function startSparseMatrixIndexCSX(builder) {\n      builder.startObject(5);\n    }\n  }, {\n    key: \"addCompressedAxis\",\n    value: function addCompressedAxis(builder, compressedAxis) {\n      builder.addFieldInt16(0, compressedAxis, SparseMatrixCompressedAxis.Row);\n    }\n  }, {\n    key: \"addIndptrType\",\n    value: function addIndptrType(builder, indptrTypeOffset) {\n      builder.addFieldOffset(1, indptrTypeOffset, 0);\n    }\n  }, {\n    key: \"addIndptrBuffer\",\n    value: function addIndptrBuffer(builder, indptrBufferOffset) {\n      builder.addFieldStruct(2, indptrBufferOffset, 0);\n    }\n  }, {\n    key: \"addIndicesType\",\n    value: function addIndicesType(builder, indicesTypeOffset) {\n      builder.addFieldOffset(3, indicesTypeOffset, 0);\n    }\n  }, {\n    key: \"addIndicesBuffer\",\n    value: function addIndicesBuffer(builder, indicesBufferOffset) {\n      builder.addFieldStruct(4, indicesBufferOffset, 0);\n    }\n  }, {\n    key: \"endSparseMatrixIndexCSX\",\n    value: function endSparseMatrixIndexCSX(builder) {\n      var offset = builder.endObject();\n      builder.requiredField(offset, 6); // indptrType\n      builder.requiredField(offset, 8); // indptrBuffer\n      builder.requiredField(offset, 10); // indicesType\n      builder.requiredField(offset, 12); // indicesBuffer\n      return offset;\n    }\n  }]);\n  return SparseMatrixIndexCSX;\n}();","map":{"version":3,"names":["flatbuffers","Buffer","Int","SparseMatrixCompressedAxis","SparseMatrixIndexCSX","_classCallCheck","bb","bb_pos","_createClass","key","value","__init","i","compressedAxis","offset","__offset","readInt16","Row","indptrType","obj","__indirect","indptrBuffer","indicesType","indicesBuffer","getRootAsSparseMatrixIndexCSX","readInt32","position","getSizePrefixedRootAsSparseMatrixIndexCSX","setPosition","SIZE_PREFIX_LENGTH","startSparseMatrixIndexCSX","builder","startObject","addCompressedAxis","addFieldInt16","addIndptrType","indptrTypeOffset","addFieldOffset","addIndptrBuffer","indptrBufferOffset","addFieldStruct","addIndicesType","indicesTypeOffset","addIndicesBuffer","indicesBufferOffset","endSparseMatrixIndexCSX","endObject","requiredField"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/fb/sparse-matrix-index-c-s-x.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { Buffer } from './buffer.js';\nimport { Int } from './int.js';\nimport { SparseMatrixCompressedAxis } from './sparse-matrix-compressed-axis.js';\n\n\n/**\n * Compressed Sparse format, that is matrix-specific.\n */\nexport class SparseMatrixIndexCSX {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):SparseMatrixIndexCSX {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsSparseMatrixIndexCSX(bb:flatbuffers.ByteBuffer, obj?:SparseMatrixIndexCSX):SparseMatrixIndexCSX {\n  return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsSparseMatrixIndexCSX(bb:flatbuffers.ByteBuffer, obj?:SparseMatrixIndexCSX):SparseMatrixIndexCSX {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\n/**\n * Which axis, row or column, is compressed\n */\ncompressedAxis():SparseMatrixCompressedAxis {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.readInt16(this.bb_pos + offset) : SparseMatrixCompressedAxis.Row;\n}\n\n/**\n * The type of values in indptrBuffer\n */\nindptrType(obj?:Int):Int|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * indptrBuffer stores the location and size of indptr array that\n * represents the range of the rows.\n * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.\n * The length of this array is 1 + (the number of rows), and the type\n * of index value is long.\n *\n * For example, let X be the following 6x4 matrix:\n * ```text\n *   X := [[0, 1, 2, 0],\n *         [0, 0, 3, 0],\n *         [0, 4, 0, 5],\n *         [0, 0, 0, 0],\n *         [6, 0, 7, 8],\n *         [0, 9, 0, 0]].\n * ```\n * The array of non-zero values in X is:\n * ```text\n *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].\n * ```\n * And the indptr of X is:\n * ```text\n *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].\n * ```\n */\nindptrBuffer(obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb!) : null;\n}\n\n/**\n * The type of values in indicesBuffer\n */\nindicesType(obj?:Int):Int|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * indicesBuffer stores the location and size of the array that\n * contains the column indices of the corresponding non-zero values.\n * The type of index value is long.\n *\n * For example, the indices of the above X is:\n * ```text\n *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].\n * ```\n * Note that the indices are sorted in lexicographical order for each row.\n */\nindicesBuffer(obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 12);\n  return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb!) : null;\n}\n\nstatic startSparseMatrixIndexCSX(builder:flatbuffers.Builder) {\n  builder.startObject(5);\n}\n\nstatic addCompressedAxis(builder:flatbuffers.Builder, compressedAxis:SparseMatrixCompressedAxis) {\n  builder.addFieldInt16(0, compressedAxis, SparseMatrixCompressedAxis.Row);\n}\n\nstatic addIndptrType(builder:flatbuffers.Builder, indptrTypeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, indptrTypeOffset, 0);\n}\n\nstatic addIndptrBuffer(builder:flatbuffers.Builder, indptrBufferOffset:flatbuffers.Offset) {\n  builder.addFieldStruct(2, indptrBufferOffset, 0);\n}\n\nstatic addIndicesType(builder:flatbuffers.Builder, indicesTypeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(3, indicesTypeOffset, 0);\n}\n\nstatic addIndicesBuffer(builder:flatbuffers.Builder, indicesBufferOffset:flatbuffers.Offset) {\n  builder.addFieldStruct(4, indicesBufferOffset, 0);\n}\n\nstatic endSparseMatrixIndexCSX(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  builder.requiredField(offset, 6) // indptrType\n  builder.requiredField(offset, 8) // indptrBuffer\n  builder.requiredField(offset, 10) // indicesType\n  builder.requiredField(offset, 12) // indicesBuffer\n  return offset;\n}\n\n}\n"],"mappings":";;AAAA;AAEA,OAAO,KAAKA,WAAW,MAAM,aAAa;AAE1C,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,GAAG,QAAQ,WAAW;AAC/B,SAASC,0BAA0B,QAAQ,qCAAqC;AAGhF;;;AAGA,WAAaC,oBAAoB;EAAjC,SAAAA,qBAAA;IAAAC,eAAA,OAAAD,oBAAA;IACE,KAAAE,EAAE,GAAgC,IAAI;IACtC,KAAAC,MAAM,GAAG,CAAC;EAuHZ;EAACC,YAAA,CAAAJ,oBAAA;IAAAK,GAAA;IAAAC,KAAA,EAtHD,SAAAC,OAAOC,CAAQ,EAAEN,EAAyB;MACxC,IAAI,CAACC,MAAM,GAAGK,CAAC;MACf,IAAI,CAACN,EAAE,GAAGA,EAAE;MACZ,OAAO,IAAI;IACb;EAAC;IAAAG,GAAA;IAAAC,KAAA;IAWD;;;IAGA,SAAAG,eAAA,EAAc;MACZ,IAAMC,MAAM,GAAG,IAAI,CAACR,EAAG,CAACS,QAAQ,CAAC,IAAI,CAACR,MAAM,EAAE,CAAC,CAAC;MAChD,OAAOO,MAAM,GAAG,IAAI,CAACR,EAAG,CAACU,SAAS,CAAC,IAAI,CAACT,MAAM,GAAGO,MAAM,CAAC,GAAGX,0BAA0B,CAACc,GAAG;IAC3F;IAEA;;;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAGA,SAAAQ,WAAWC,GAAQ;MACjB,IAAML,MAAM,GAAG,IAAI,CAACR,EAAG,CAACS,QAAQ,CAAC,IAAI,CAACR,MAAM,EAAE,CAAC,CAAC;MAChD,OAAOO,MAAM,GAAG,CAACK,GAAG,IAAI,IAAIjB,GAAG,EAAE,EAAES,MAAM,CAAC,IAAI,CAACL,EAAG,CAACc,UAAU,CAAC,IAAI,CAACb,MAAM,GAAGO,MAAM,CAAC,EAAE,IAAI,CAACR,EAAG,CAAC,GAAG,IAAI;IACvG;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAAG,GAAA;IAAAC,KAAA,EAyBA,SAAAW,aAAaF,GAAW;MACtB,IAAML,MAAM,GAAG,IAAI,CAACR,EAAG,CAACS,QAAQ,CAAC,IAAI,CAACR,MAAM,EAAE,CAAC,CAAC;MAChD,OAAOO,MAAM,GAAG,CAACK,GAAG,IAAI,IAAIlB,MAAM,EAAE,EAAEU,MAAM,CAAC,IAAI,CAACJ,MAAM,GAAGO,MAAM,EAAE,IAAI,CAACR,EAAG,CAAC,GAAG,IAAI;IACrF;IAEA;;;EAAA;IAAAG,GAAA;IAAAC,KAAA,EAGA,SAAAY,YAAYH,GAAQ;MAClB,IAAML,MAAM,GAAG,IAAI,CAACR,EAAG,CAACS,QAAQ,CAAC,IAAI,CAACR,MAAM,EAAE,EAAE,CAAC;MACjD,OAAOO,MAAM,GAAG,CAACK,GAAG,IAAI,IAAIjB,GAAG,EAAE,EAAES,MAAM,CAAC,IAAI,CAACL,EAAG,CAACc,UAAU,CAAC,IAAI,CAACb,MAAM,GAAGO,MAAM,CAAC,EAAE,IAAI,CAACR,EAAG,CAAC,GAAG,IAAI;IACvG;IAEA;;;;;;;;;;;EAAA;IAAAG,GAAA;IAAAC,KAAA,EAWA,SAAAa,cAAcJ,GAAW;MACvB,IAAML,MAAM,GAAG,IAAI,CAACR,EAAG,CAACS,QAAQ,CAAC,IAAI,CAACR,MAAM,EAAE,EAAE,CAAC;MACjD,OAAOO,MAAM,GAAG,CAACK,GAAG,IAAI,IAAIlB,MAAM,EAAE,EAAEU,MAAM,CAAC,IAAI,CAACJ,MAAM,GAAGO,MAAM,EAAE,IAAI,CAACR,EAAG,CAAC,GAAG,IAAI;IACrF;EAAC;IAAAG,GAAA;IAAAC,KAAA,EA7ED,SAAAc,8BAAqClB,EAAyB,EAAEa,GAAyB;MACvF,OAAO,CAACA,GAAG,IAAI,IAAIf,oBAAoB,EAAE,EAAEO,MAAM,CAACL,EAAE,CAACmB,SAAS,CAACnB,EAAE,CAACoB,QAAQ,EAAE,CAAC,GAAGpB,EAAE,CAACoB,QAAQ,EAAE,EAAEpB,EAAE,CAAC;IACpG;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAED,SAAAiB,0CAAiDrB,EAAyB,EAAEa,GAAyB;MACnGb,EAAE,CAACsB,WAAW,CAACtB,EAAE,CAACoB,QAAQ,EAAE,GAAG1B,WAAW,CAAC6B,kBAAkB,CAAC;MAC9D,OAAO,CAACV,GAAG,IAAI,IAAIf,oBAAoB,EAAE,EAAEO,MAAM,CAACL,EAAE,CAACmB,SAAS,CAACnB,EAAE,CAACoB,QAAQ,EAAE,CAAC,GAAGpB,EAAE,CAACoB,QAAQ,EAAE,EAAEpB,EAAE,CAAC;IACpG;EAAC;IAAAG,GAAA;IAAAC,KAAA,EAwED,SAAAoB,0BAAiCC,OAA2B;MAC1DA,OAAO,CAACC,WAAW,CAAC,CAAC,CAAC;IACxB;EAAC;IAAAvB,GAAA;IAAAC,KAAA,EAED,SAAAuB,kBAAyBF,OAA2B,EAAElB,cAAyC;MAC7FkB,OAAO,CAACG,aAAa,CAAC,CAAC,EAAErB,cAAc,EAAEV,0BAA0B,CAACc,GAAG,CAAC;IAC1E;EAAC;IAAAR,GAAA;IAAAC,KAAA,EAED,SAAAyB,cAAqBJ,OAA2B,EAAEK,gBAAmC;MACnFL,OAAO,CAACM,cAAc,CAAC,CAAC,EAAED,gBAAgB,EAAE,CAAC,CAAC;IAChD;EAAC;IAAA3B,GAAA;IAAAC,KAAA,EAED,SAAA4B,gBAAuBP,OAA2B,EAAEQ,kBAAqC;MACvFR,OAAO,CAACS,cAAc,CAAC,CAAC,EAAED,kBAAkB,EAAE,CAAC,CAAC;IAClD;EAAC;IAAA9B,GAAA;IAAAC,KAAA,EAED,SAAA+B,eAAsBV,OAA2B,EAAEW,iBAAoC;MACrFX,OAAO,CAACM,cAAc,CAAC,CAAC,EAAEK,iBAAiB,EAAE,CAAC,CAAC;IACjD;EAAC;IAAAjC,GAAA;IAAAC,KAAA,EAED,SAAAiC,iBAAwBZ,OAA2B,EAAEa,mBAAsC;MACzFb,OAAO,CAACS,cAAc,CAAC,CAAC,EAAEI,mBAAmB,EAAE,CAAC,CAAC;IACnD;EAAC;IAAAnC,GAAA;IAAAC,KAAA,EAED,SAAAmC,wBAA+Bd,OAA2B;MACxD,IAAMjB,MAAM,GAAGiB,OAAO,CAACe,SAAS,EAAE;MAClCf,OAAO,CAACgB,aAAa,CAACjC,MAAM,EAAE,CAAC,CAAC,EAAC;MACjCiB,OAAO,CAACgB,aAAa,CAACjC,MAAM,EAAE,CAAC,CAAC,EAAC;MACjCiB,OAAO,CAACgB,aAAa,CAACjC,MAAM,EAAE,EAAE,CAAC,EAAC;MAClCiB,OAAO,CAACgB,aAAa,CAACjC,MAAM,EAAE,EAAE,CAAC,EAAC;MAClC,OAAOA,MAAM;IACf;EAAC;EAAA,OAAAV,oBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}