{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __awaiter } from \"tslib\";\nimport { AsyncByteStream } from '../../io/stream.mjs';\n/** @ignore */\nexport function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {\n  const writer = new this(writableStrategy);\n  const reader = new AsyncByteStream(writer);\n  const readable = new ReadableStream({\n    // type: 'bytes',\n    cancel() {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield reader.cancel();\n      });\n    },\n    pull(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    },\n    start(controller) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield next(controller);\n      });\n    }\n  }, Object.assign({\n    'highWaterMark': Math.pow(2, 14)\n  }, readableStrategy));\n  return {\n    writable: new WritableStream(writer, writableStrategy),\n    readable\n  };\n  function next(controller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let buf = null;\n      let size = controller.desiredSize;\n      while (buf = yield reader.read(size || null)) {\n        controller.enqueue(buf);\n        if (size != null && (size -= buf.byteLength) <= 0) {\n          return;\n        }\n      }\n      controller.close();\n    });\n  }\n}","map":{"version":3,"names":["AsyncByteStream","recordBatchWriterThroughDOMStream","writableStrategy","readableStrategy","writer","reader","readable","ReadableStream","cancel","pull","controller","next","start","Object","assign","Math","pow","writable","WritableStream","buf","size","desiredSize","read","enqueue","byteLength","close"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/io/whatwg/writer.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { TypeMap } from '../../type.js';\nimport { RecordBatch } from '../../recordbatch.js';\nimport { AsyncByteStream } from '../../io/stream.js';\nimport { RecordBatchWriter } from '../../ipc/writer.js';\n\n/** @ignore */\nexport function recordBatchWriterThroughDOMStream<T extends TypeMap = any>(\n    this: typeof RecordBatchWriter,\n    writableStrategy?: QueuingStrategy<RecordBatch<T>> & { autoDestroy: boolean },\n    readableStrategy?: { highWaterMark?: number; size?: any }\n) {\n\n    const writer = new this<T>(writableStrategy);\n    const reader = new AsyncByteStream(writer);\n    const readable = new ReadableStream({\n        // type: 'bytes',\n        async cancel() { await reader.cancel(); },\n        async pull(controller) { await next(controller); },\n        async start(controller) { await next(controller); },\n    }, { 'highWaterMark': 2 ** 14, ...readableStrategy });\n\n    return { writable: new WritableStream(writer, writableStrategy), readable };\n\n    async function next(controller: ReadableStreamDefaultController<Uint8Array>) {\n        let buf: Uint8Array | null = null;\n        let size = controller.desiredSize;\n        while (buf = await reader.read(size || null)) {\n            controller.enqueue(buf);\n            if (size != null && (size -= buf.byteLength) <= 0) { return; }\n        }\n        controller.close();\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA,SAASA,eAAe,QAAQ,qBAAqB;AAGrD;AACA,OAAM,SAAUC,iCAAiCA,CAE7CC,gBAA6E,EAC7EC,gBAAyD;EAGzD,MAAMC,MAAM,GAAG,IAAI,IAAI,CAAIF,gBAAgB,CAAC;EAC5C,MAAMG,MAAM,GAAG,IAAIL,eAAe,CAACI,MAAM,CAAC;EAC1C,MAAME,QAAQ,GAAG,IAAIC,cAAc,CAAC;IAChC;IACMC,MAAMA,CAAA;;QAAK,MAAMH,MAAM,CAACG,MAAM,EAAE;MAAE,CAAC;KAAA;IACnCC,IAAIA,CAACC,UAAU;;QAAI,MAAMC,IAAI,CAACD,UAAU,CAAC;MAAE,CAAC;KAAA;IAC5CE,KAAKA,CAACF,UAAU;;QAAI,MAAMC,IAAI,CAACD,UAAU,CAAC;MAAE,CAAC;;GACtD,EAAAG,MAAA,CAAAC,MAAA;IAAI,eAAe,EAAEC,IAAA,CAAAC,GAAA,EAAC,EAAI,EAAE;EAAA,GAAKb,gBAAgB,EAAG;EAErD,OAAO;IAAEc,QAAQ,EAAE,IAAIC,cAAc,CAACd,MAAM,EAAEF,gBAAgB,CAAC;IAAEI;EAAQ,CAAE;EAE3E,SAAeK,IAAIA,CAACD,UAAuD;;MACvE,IAAIS,GAAG,GAAsB,IAAI;MACjC,IAAIC,IAAI,GAAGV,UAAU,CAACW,WAAW;MACjC,OAAOF,GAAG,GAAG,MAAMd,MAAM,CAACiB,IAAI,CAACF,IAAI,IAAI,IAAI,CAAC,EAAE;QAC1CV,UAAU,CAACa,OAAO,CAACJ,GAAG,CAAC;QACvB,IAAIC,IAAI,IAAI,IAAI,IAAI,CAACA,IAAI,IAAID,GAAG,CAACK,UAAU,KAAK,CAAC,EAAE;UAAE;;;MAEzDd,UAAU,CAACe,KAAK,EAAE;IACtB,CAAC;;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}