{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */\nexport class ChunkedIterator {\n  constructor(numChunks = 0, getChunkIterator) {\n    this.numChunks = numChunks;\n    this.getChunkIterator = getChunkIterator;\n    this.chunkIndex = 0;\n    this.chunkIterator = this.getChunkIterator(0);\n  }\n  next() {\n    while (this.chunkIndex < this.numChunks) {\n      const next = this.chunkIterator.next();\n      if (!next.done) {\n        return next;\n      }\n      if (++this.chunkIndex < this.numChunks) {\n        this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n      }\n    }\n    return {\n      done: true,\n      value: null\n    };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n}\n/** @ignore */\nexport function computeChunkNullCounts(chunks) {\n  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\n/** @ignore */\nexport function computeChunkOffsets(chunks) {\n  return chunks.reduce((offsets, chunk, index) => {\n    offsets[index + 1] = offsets[index] + chunk.length;\n    return offsets;\n  }, new Uint32Array(chunks.length + 1));\n}\n/** @ignore */\nexport function sliceChunks(chunks, offsets, begin, end) {\n  const slices = [];\n  for (let i = -1, n = chunks.length; ++i < n;) {\n    const chunk = chunks[i];\n    const offset = offsets[i];\n    const {\n      length\n    } = chunk;\n    // Stop if the child is to the right of the slice boundary\n    if (offset >= end) {\n      break;\n    }\n    // Exclude children to the left of of the slice boundary\n    if (begin >= offset + length) {\n      continue;\n    }\n    // Include entire child if between both left and right boundaries\n    if (offset >= begin && offset + length <= end) {\n      slices.push(chunk);\n      continue;\n    }\n    // Include the child slice that overlaps one of the slice boundaries\n    const from = Math.max(0, begin - offset);\n    const to = Math.min(end - offset, length);\n    slices.push(chunk.slice(from, to - from));\n  }\n  if (slices.length === 0) {\n    slices.push(chunks[0].slice(0, 0));\n  }\n  return slices;\n}\n/** @ignore */\nexport function binarySearch(chunks, offsets, idx, fn) {\n  let lhs = 0,\n    mid = 0,\n    rhs = offsets.length - 1;\n  do {\n    if (lhs >= rhs - 1) {\n      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n    }\n    mid = lhs + Math.trunc((rhs - lhs) * .5);\n    idx < offsets[mid] ? rhs = mid : lhs = mid;\n  } while (lhs < rhs);\n}\n/** @ignore */\nexport function isChunkedValid(data, index) {\n  return data.getValid(index);\n}\n/** @ignore */\nexport function wrapChunkedCall1(fn) {\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j);\n  }\n  return function (index) {\n    const data = this.data;\n    return binarySearch(data, this._offsets, index, chunkedFn);\n  };\n}\n/** @ignore */\nexport function wrapChunkedCall2(fn) {\n  let _2;\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j, _2);\n  }\n  return function (index, value) {\n    const data = this.data;\n    _2 = value;\n    const result = binarySearch(data, this._offsets, index, chunkedFn);\n    _2 = undefined;\n    return result;\n  };\n}\n/** @ignore */\nexport function wrapChunkedIndexOf(indexOf) {\n  let _1;\n  function chunkedIndexOf(data, chunkIndex, fromIndex) {\n    let begin = fromIndex,\n      index = 0,\n      total = 0;\n    for (let i = chunkIndex - 1, n = data.length; ++i < n;) {\n      const chunk = data[i];\n      if (~(index = indexOf(chunk, _1, begin))) {\n        return total + index;\n      }\n      begin = 0;\n      total += chunk.length;\n    }\n    return -1;\n  }\n  return function (element, offset) {\n    _1 = element;\n    const data = this.data;\n    const result = typeof offset !== 'number' ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n    _1 = undefined;\n    return result;\n  };\n}","map":{"version":3,"names":["ChunkedIterator","constructor","numChunks","getChunkIterator","chunkIndex","chunkIterator","next","done","value","Symbol","iterator","computeChunkNullCounts","chunks","reduce","nullCount","chunk","computeChunkOffsets","offsets","index","length","Uint32Array","sliceChunks","begin","end","slices","i","n","offset","push","from","Math","max","to","min","slice","binarySearch","idx","fn","lhs","mid","rhs","trunc","isChunkedValid","data","getValid","wrapChunkedCall1","chunkedFn","j","_offsets","wrapChunkedCall2","_2","result","undefined","wrapChunkedIndexOf","indexOf","_1","chunkedIndexOf","fromIndex","total","element"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/template/my_component/frontend/node_modules/apache-arrow/src/util/chunk.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data.js';\nimport { DataType } from '../type.js';\n\n/** @ignore */\nexport class ChunkedIterator<T extends DataType> implements IterableIterator<T['TValue'] | null> {\n    private chunkIndex = 0;\n    private chunkIterator: IterableIterator<T['TValue'] | null>;\n\n    constructor(\n        private numChunks: number = 0,\n        private getChunkIterator: (chunkIndex: number) => IterableIterator<T['TValue'] | null>\n    ) {\n        this.chunkIterator = this.getChunkIterator(0);\n    }\n\n    next(): IteratorResult<T['TValue'] | null> {\n        while (this.chunkIndex < this.numChunks) {\n            const next = this.chunkIterator.next();\n\n            if (!next.done) {\n                return next;\n            }\n\n            if (++this.chunkIndex < this.numChunks) {\n                this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n            }\n        }\n\n        return { done: true, value: null };\n    }\n\n    [Symbol.iterator]() {\n        return this;\n    }\n}\n\n/** @ignore */\nexport function computeChunkNullCounts<T extends DataType>(chunks: ReadonlyArray<Data<T>>) {\n    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\n\n/** @ignore */\nexport function computeChunkOffsets<T extends DataType>(chunks: ReadonlyArray<Data<T>>) {\n    return chunks.reduce((offsets, chunk, index) => {\n        offsets[index + 1] = offsets[index] + chunk.length;\n        return offsets;\n    }, new Uint32Array(chunks.length + 1));\n}\n\n/** @ignore */\nexport function sliceChunks<T extends DataType>(chunks: ReadonlyArray<Data<T>>, offsets: Uint32Array | Array<number>, begin: number, end: number) {\n    const slices: Data<T>[] = [];\n    for (let i = -1, n = chunks.length; ++i < n;) {\n        const chunk = chunks[i];\n        const offset = offsets[i];\n        const { length } = chunk;\n        // Stop if the child is to the right of the slice boundary\n        if (offset >= end) { break; }\n        // Exclude children to the left of of the slice boundary\n        if (begin >= offset + length) { continue; }\n        // Include entire child if between both left and right boundaries\n        if (offset >= begin && (offset + length) <= end) {\n            slices.push(chunk);\n            continue;\n        }\n        // Include the child slice that overlaps one of the slice boundaries\n        const from = Math.max(0, begin - offset);\n        const to = Math.min(end - offset, length);\n        slices.push(chunk.slice(from, to - from));\n    }\n    if (slices.length === 0) {\n        slices.push(chunks[0].slice(0, 0));\n    }\n    return slices;\n}\n\n/** @ignore */\nexport function binarySearch<\n    T extends DataType,\n    F extends (chunks: ReadonlyArray<Data<T>>, _1: number, _2: number) => any\n>(chunks: ReadonlyArray<Data<T>>, offsets: Uint32Array | number[], idx: number, fn: F) {\n    let lhs = 0, mid = 0, rhs = offsets.length - 1;\n    do {\n        if (lhs >= rhs - 1) {\n            return (idx < offsets[rhs]) ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n        }\n        mid = lhs + (Math.trunc((rhs - lhs) * .5));\n        idx < offsets[mid] ? (rhs = mid) : (lhs = mid);\n    } while (lhs < rhs);\n}\n\n/** @ignore */\nexport function isChunkedValid<T extends DataType>(data: Data<T>, index: number): boolean {\n    return data.getValid(index);\n}\n\n/** @ignore */\nexport function wrapChunkedCall1<T extends DataType>(fn: (c: Data<T>, _1: number) => any) {\n    function chunkedFn(chunks: ReadonlyArray<Data<T>>, i: number, j: number) { return fn(chunks[i], j); }\n    return function (this: any, index: number) {\n        const data = this.data as ReadonlyArray<Data<T>>;\n        return binarySearch(data, this._offsets, index, chunkedFn);\n    };\n}\n\n/** @ignore */\nexport function wrapChunkedCall2<T extends DataType>(fn: (c: Data<T>, _1: number, _2: any) => any) {\n    let _2: any;\n    function chunkedFn(chunks: ReadonlyArray<Data<T>>, i: number, j: number) { return fn(chunks[i], j, _2); }\n    return function (this: any, index: number, value: any) {\n        const data = this.data as ReadonlyArray<Data<T>>;\n        _2 = value;\n        const result = binarySearch(data, this._offsets, index, chunkedFn);\n        _2 = undefined;\n        return result;\n    };\n}\n\n/** @ignore */\nexport function wrapChunkedIndexOf<T extends DataType>(indexOf: (c: Data<T>, e: T['TValue'], o?: number) => any) {\n    let _1: any;\n    function chunkedIndexOf(data: ReadonlyArray<Data<T>>, chunkIndex: number, fromIndex: number) {\n        let begin = fromIndex, index = 0, total = 0;\n        for (let i = chunkIndex - 1, n = data.length; ++i < n;) {\n            const chunk = data[i];\n            if (~(index = indexOf(chunk, _1, begin))) {\n                return total + index;\n            }\n            begin = 0;\n            total += chunk.length;\n        }\n        return -1;\n    }\n    return function (this: any, element: T['TValue'], offset?: number) {\n        _1 = element;\n        const data = this.data as ReadonlyArray<Data<T>>;\n        const result = typeof offset !== 'number'\n            ? chunkedIndexOf(data, 0, 0)\n            : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n        _1 = undefined;\n        return result;\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}