{"ast":null,"code":"import _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Buffer } from './buffer.mjs';\nimport { Int } from './int.mjs';\n/**\n * ----------------------------------------------------------------------\n * EXPERIMENTAL: Data structures for sparse tensors\n * Coordinate (COO) format of sparse tensor index.\n *\n * COO's index list are represented as a NxM matrix,\n * where N is the number of non-zero values,\n * and M is the number of dimensions of a sparse tensor.\n *\n * indicesBuffer stores the location and size of the data of this indices\n * matrix.  The value type and the stride of the indices matrix is\n * specified in indicesType and indicesStrides fields.\n *\n * For example, let X be a 2x3x4x5 tensor, and it has the following\n * 6 non-zero values:\n * ```text\n *   X[0, 1, 2, 0] := 1\n *   X[1, 1, 2, 3] := 2\n *   X[0, 2, 1, 0] := 3\n *   X[0, 1, 3, 0] := 4\n *   X[0, 1, 2, 1] := 5\n *   X[1, 2, 0, 4] := 6\n * ```\n * In COO format, the index matrix of X is the following 4x6 matrix:\n * ```text\n *   [[0, 0, 0, 0, 1, 1],\n *    [1, 1, 1, 2, 1, 2],\n *    [2, 2, 3, 1, 2, 0],\n *    [0, 1, 0, 0, 3, 4]]\n * ```\n * When isCanonical is true, the indices is sorted in lexicographical order\n * (row-major order), and it does not have duplicated entries.  Otherwise,\n * the indices may not be sorted, or may have duplicated entries.\n */\nexport var SparseTensorIndexCOO = /*#__PURE__*/function () {\n  function SparseTensorIndexCOO() {\n    _classCallCheck(this, SparseTensorIndexCOO);\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  _createClass(SparseTensorIndexCOO, [{\n    key: \"__init\",\n    value: function __init(i, bb) {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n  }, {\n    key: \"indicesType\",\n    value:\n    /**\n     * The type of values in indicesBuffer\n     */\n    function indicesType(obj) {\n      var offset = this.bb.__offset(this.bb_pos, 4);\n      return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n    }\n    /**\n     * Non-negative byte offsets to advance one value cell along each dimension\n     * If omitted, default to row-major order (C-like).\n     */\n  }, {\n    key: \"indicesStrides\",\n    value: function indicesStrides(index) {\n      var offset = this.bb.__offset(this.bb_pos, 6);\n      return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);\n    }\n  }, {\n    key: \"indicesStridesLength\",\n    value: function indicesStridesLength() {\n      var offset = this.bb.__offset(this.bb_pos, 6);\n      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n    }\n    /**\n     * The location and size of the indices matrix's data\n     */\n  }, {\n    key: \"indicesBuffer\",\n    value: function indicesBuffer(obj) {\n      var offset = this.bb.__offset(this.bb_pos, 8);\n      return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb) : null;\n    }\n    /**\n     * This flag is true if and only if the indices matrix is sorted in\n     * row-major order, and does not have duplicated entries.\n     * This sort order is the same as of Tensorflow's SparseTensor,\n     * but it is inverse order of SciPy's canonical coo_matrix\n     * (SciPy employs column-major order for its coo_matrix).\n     */\n  }, {\n    key: \"isCanonical\",\n    value: function isCanonical() {\n      var offset = this.bb.__offset(this.bb_pos, 10);\n      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n  }], [{\n    key: \"getRootAsSparseTensorIndexCOO\",\n    value: function getRootAsSparseTensorIndexCOO(bb, obj) {\n      return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n  }, {\n    key: \"getSizePrefixedRootAsSparseTensorIndexCOO\",\n    value: function getSizePrefixedRootAsSparseTensorIndexCOO(bb, obj) {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n  }, {\n    key: \"startSparseTensorIndexCOO\",\n    value: function startSparseTensorIndexCOO(builder) {\n      builder.startObject(4);\n    }\n  }, {\n    key: \"addIndicesType\",\n    value: function addIndicesType(builder, indicesTypeOffset) {\n      builder.addFieldOffset(0, indicesTypeOffset, 0);\n    }\n  }, {\n    key: \"addIndicesStrides\",\n    value: function addIndicesStrides(builder, indicesStridesOffset) {\n      builder.addFieldOffset(1, indicesStridesOffset, 0);\n    }\n  }, {\n    key: \"createIndicesStridesVector\",\n    value: function createIndicesStridesVector(builder, data) {\n      builder.startVector(8, data.length, 8);\n      for (var i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n  }, {\n    key: \"startIndicesStridesVector\",\n    value: function startIndicesStridesVector(builder, numElems) {\n      builder.startVector(8, numElems, 8);\n    }\n  }, {\n    key: \"addIndicesBuffer\",\n    value: function addIndicesBuffer(builder, indicesBufferOffset) {\n      builder.addFieldStruct(2, indicesBufferOffset, 0);\n    }\n  }, {\n    key: \"addIsCanonical\",\n    value: function addIsCanonical(builder, isCanonical) {\n      builder.addFieldInt8(3, +isCanonical, +false);\n    }\n  }, {\n    key: \"endSparseTensorIndexCOO\",\n    value: function endSparseTensorIndexCOO(builder) {\n      var offset = builder.endObject();\n      builder.requiredField(offset, 4); // indicesType\n      builder.requiredField(offset, 8); // indicesBuffer\n      return offset;\n    }\n  }]);\n  return SparseTensorIndexCOO;\n}();","map":{"version":3,"names":["flatbuffers","Buffer","Int","SparseTensorIndexCOO","_classCallCheck","bb","bb_pos","_createClass","key","value","__init","i","indicesType","obj","offset","__offset","__indirect","indicesStrides","index","readInt64","__vector","createLong","indicesStridesLength","__vector_len","indicesBuffer","isCanonical","readInt8","getRootAsSparseTensorIndexCOO","readInt32","position","getSizePrefixedRootAsSparseTensorIndexCOO","setPosition","SIZE_PREFIX_LENGTH","startSparseTensorIndexCOO","builder","startObject","addIndicesType","indicesTypeOffset","addFieldOffset","addIndicesStrides","indicesStridesOffset","createIndicesStridesVector","data","startVector","length","addInt64","endVector","startIndicesStridesVector","numElems","addIndicesBuffer","indicesBufferOffset","addFieldStruct","addIsCanonical","addFieldInt8","endSparseTensorIndexCOO","endObject","requiredField"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/fb/sparse-tensor-index-c-o-o.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { Buffer } from './buffer.js';\nimport { Int } from './int.js';\n\n\n/**\n * ----------------------------------------------------------------------\n * EXPERIMENTAL: Data structures for sparse tensors\n * Coordinate (COO) format of sparse tensor index.\n *\n * COO's index list are represented as a NxM matrix,\n * where N is the number of non-zero values,\n * and M is the number of dimensions of a sparse tensor.\n *\n * indicesBuffer stores the location and size of the data of this indices\n * matrix.  The value type and the stride of the indices matrix is\n * specified in indicesType and indicesStrides fields.\n *\n * For example, let X be a 2x3x4x5 tensor, and it has the following\n * 6 non-zero values:\n * ```text\n *   X[0, 1, 2, 0] := 1\n *   X[1, 1, 2, 3] := 2\n *   X[0, 2, 1, 0] := 3\n *   X[0, 1, 3, 0] := 4\n *   X[0, 1, 2, 1] := 5\n *   X[1, 2, 0, 4] := 6\n * ```\n * In COO format, the index matrix of X is the following 4x6 matrix:\n * ```text\n *   [[0, 0, 0, 0, 1, 1],\n *    [1, 1, 1, 2, 1, 2],\n *    [2, 2, 3, 1, 2, 0],\n *    [0, 1, 0, 0, 3, 4]]\n * ```\n * When isCanonical is true, the indices is sorted in lexicographical order\n * (row-major order), and it does not have duplicated entries.  Otherwise,\n * the indices may not be sorted, or may have duplicated entries.\n */\nexport class SparseTensorIndexCOO {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):SparseTensorIndexCOO {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsSparseTensorIndexCOO(bb:flatbuffers.ByteBuffer, obj?:SparseTensorIndexCOO):SparseTensorIndexCOO {\n  return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsSparseTensorIndexCOO(bb:flatbuffers.ByteBuffer, obj?:SparseTensorIndexCOO):SparseTensorIndexCOO {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\n/**\n * The type of values in indicesBuffer\n */\nindicesType(obj?:Int):Int|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * Non-negative byte offsets to advance one value cell along each dimension\n * If omitted, default to row-major order (C-like).\n */\nindicesStrides(index: number):flatbuffers.Long|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : this.bb!.createLong(0, 0);\n}\n\nindicesStridesLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\n/**\n * The location and size of the indices matrix's data\n */\nindicesBuffer(obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb!) : null;\n}\n\n/**\n * This flag is true if and only if the indices matrix is sorted in\n * row-major order, and does not have duplicated entries.\n * This sort order is the same as of Tensorflow's SparseTensor,\n * but it is inverse order of SciPy's canonical coo_matrix\n * (SciPy employs column-major order for its coo_matrix).\n */\nisCanonical():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\nstatic startSparseTensorIndexCOO(builder:flatbuffers.Builder) {\n  builder.startObject(4);\n}\n\nstatic addIndicesType(builder:flatbuffers.Builder, indicesTypeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, indicesTypeOffset, 0);\n}\n\nstatic addIndicesStrides(builder:flatbuffers.Builder, indicesStridesOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, indicesStridesOffset, 0);\n}\n\nstatic createIndicesStridesVector(builder:flatbuffers.Builder, data:flatbuffers.Long[]):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addInt64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startIndicesStridesVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addIndicesBuffer(builder:flatbuffers.Builder, indicesBufferOffset:flatbuffers.Offset) {\n  builder.addFieldStruct(2, indicesBufferOffset, 0);\n}\n\nstatic addIsCanonical(builder:flatbuffers.Builder, isCanonical:boolean) {\n  builder.addFieldInt8(3, +isCanonical, +false);\n}\n\nstatic endSparseTensorIndexCOO(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  builder.requiredField(offset, 4) // indicesType\n  builder.requiredField(offset, 8) // indicesBuffer\n  return offset;\n}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}