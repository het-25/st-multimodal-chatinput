{"ast":null,"code":"import _construct from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _createForOfIteratorHelper from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Type } from './enum.mjs';\nimport { Data, makeData } from './data.mjs';\nimport { vectorFromArray } from './factories.mjs';\nimport { makeVector, Vector } from './vector.mjs';\nimport { Field, Schema } from './schema.mjs';\nimport { Null, Struct } from './type.mjs';\nimport { compareSchemas } from './visitor/typecomparator.mjs';\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.mjs';\nimport { isChunkedValid, computeChunkOffsets, computeChunkNullCounts, wrapChunkedCall1, wrapChunkedCall2, wrapChunkedIndexOf, sliceChunks } from './util/chunk.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.mjs';\nimport { clampRange } from './util/vector.mjs';\nimport { RecordBatch } from './recordbatch.mjs';\n/**\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\n * {@link tableFromIPC}.\n */\nexport var Table = /*#__PURE__*/function (_Symbol$iterator) {\n  function Table() {\n    _classCallCheck(this, Table);\n    var _b, _c;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === 0) {\n      this.batches = [];\n      this.schema = new Schema([]);\n      this._offsets = [0];\n      return this;\n    }\n    var schema;\n    var offsets;\n    if (args[0] instanceof Schema) {\n      schema = args.shift();\n    }\n    if (args[args.length - 1] instanceof Uint32Array) {\n      offsets = args.pop();\n    }\n    var unwrap = function unwrap(x) {\n      if (x) {\n        if (x instanceof RecordBatch) {\n          return [x];\n        } else if (x instanceof Table) {\n          return x.batches;\n        } else if (x instanceof Data) {\n          if (x.type instanceof Struct) {\n            return [new RecordBatch(new Schema(x.type.children), x)];\n          }\n        } else if (Array.isArray(x)) {\n          return x.flatMap(function (v) {\n            return unwrap(v);\n          });\n        } else if (typeof x[Symbol.iterator] === 'function') {\n          return _toConsumableArray(x).flatMap(function (v) {\n            return unwrap(v);\n          });\n        } else if (typeof x === 'object') {\n          var keys = Object.keys(x);\n          var vecs = keys.map(function (k) {\n            return new Vector([x[k]]);\n          });\n          var _schema = new Schema(keys.map(function (k, i) {\n            return new Field(String(k), vecs[i].type);\n          }));\n          var _distributeVectorsInt = distributeVectorsIntoRecordBatches(_schema, vecs),\n            _distributeVectorsInt2 = _slicedToArray(_distributeVectorsInt, 2),\n            _batches = _distributeVectorsInt2[1];\n          return _batches.length === 0 ? [new RecordBatch(x)] : _batches;\n        }\n      }\n      return [];\n    };\n    var batches = args.flatMap(function (v) {\n      return unwrap(v);\n    });\n    schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new Schema([]);\n    if (!(schema instanceof Schema)) {\n      throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n    }\n    var _iterator = _createForOfIteratorHelper(batches),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var batch = _step.value;\n        if (!(batch instanceof RecordBatch)) {\n          throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n        }\n        if (!compareSchemas(schema, batch.schema)) {\n          throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    this.schema = schema;\n    this.batches = batches;\n    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n  }\n  /**\n   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n   */\n  _createClass(Table, [{\n    key: \"data\",\n    get: function get() {\n      return this.batches.map(function (_ref) {\n        var data = _ref.data;\n        return data;\n      });\n    }\n    /**\n     * The number of columns in this Table.\n     */\n  }, {\n    key: \"numCols\",\n    get: function get() {\n      return this.schema.fields.length;\n    }\n    /**\n     * The number of rows in this Table.\n     */\n  }, {\n    key: \"numRows\",\n    get: function get() {\n      return this.data.reduce(function (numRows, data) {\n        return numRows + data.length;\n      }, 0);\n    }\n    /**\n     * The number of null rows in this Table.\n     */\n  }, {\n    key: \"nullCount\",\n    get: function get() {\n      if (this._nullCount === -1) {\n        this._nullCount = computeChunkNullCounts(this.data);\n      }\n      return this._nullCount;\n    }\n    /**\n     * Check whether an element is null.\n     *\n     * @param index The index at which to read the validity bitmap.\n     */\n    // @ts-ignore\n  }, {\n    key: \"isValid\",\n    value: function isValid(index) {\n      return false;\n    }\n    /**\n     * Get an element value by position.\n     *\n     * @param index The index of the element to read.\n     */\n    // @ts-ignore\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return null;\n    }\n    /**\n     * Set an element value by position.\n     *\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    // @ts-ignore\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      return;\n    }\n    /**\n     * Retrieve the index of the first occurrence of a value in an Vector.\n     *\n     * @param element The value to locate in the Vector.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    // @ts-ignore\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(element, offset) {\n      return -1;\n    }\n    /**\n     * Get the size in bytes of an element by index.\n     * @param index The index at which to get the byteLength.\n     */\n    // @ts-ignore\n  }, {\n    key: \"getByteLength\",\n    value: function getByteLength(index) {\n      return 0;\n    }\n    /**\n     * Iterator for rows in this Table.\n     */\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      if (this.batches.length > 0) {\n        return iteratorVisitor.visit(new Vector(this.data));\n      }\n      return new Array(0)[Symbol.iterator]();\n    }\n    /**\n     * Return a JavaScript Array of the Table rows.\n     *\n     * @returns An Array of Table rows.\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return _toConsumableArray(this);\n    }\n    /**\n     * Returns a string representation of the Table rows.\n     *\n     * @returns A string representation of the Table rows.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[\\n  \".concat(this.toArray().join(',\\n  '), \"\\n]\");\n    }\n    /**\n     * Combines two or more Tables of the same schema.\n     *\n     * @param others Additional Tables to add to the end of this Tables.\n     */\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var schema = this.schema;\n      for (var _len2 = arguments.length, others = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        others[_key2] = arguments[_key2];\n      }\n      var data = this.data.concat(others.flatMap(function (_ref2) {\n        var data = _ref2.data;\n        return data;\n      }));\n      return new Table(schema, data.map(function (data) {\n        return new RecordBatch(schema, data);\n      }));\n    }\n    /**\n     * Return a zero-copy sub-section of this Table.\n     *\n     * @param begin The beginning of the specified portion of the Table.\n     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n     */\n  }, {\n    key: \"slice\",\n    value: function slice(begin, end) {\n      var schema = this.schema;\n      var _clampRange = clampRange({\n        length: this.numRows\n      }, begin, end);\n      var _clampRange2 = _slicedToArray(_clampRange, 2);\n      begin = _clampRange2[0];\n      end = _clampRange2[1];\n      var data = sliceChunks(this.data, this._offsets, begin, end);\n      return new Table(schema, data.map(function (chunk) {\n        return new RecordBatch(schema, chunk);\n      }));\n    }\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     *\n     * @param name The name of the child to retrieve.\n     */\n  }, {\n    key: \"getChild\",\n    value: function getChild(name) {\n      return this.getChildAt(this.schema.fields.findIndex(function (f) {\n        return f.name === name;\n      }));\n    }\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     *\n     * @param index The index of the child to retrieve.\n     */\n  }, {\n    key: \"getChildAt\",\n    value: function getChildAt(index) {\n      if (index > -1 && index < this.schema.fields.length) {\n        var data = this.data.map(function (data) {\n          return data.children[index];\n        });\n        if (data.length === 0) {\n          var type = this.schema.fields[index].type;\n          var empty = makeData({\n            type: type,\n            length: 0,\n            nullCount: 0\n          });\n          data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\n        }\n        return new Vector(data);\n      }\n      return null;\n    }\n    /**\n     * Sets a child Vector by name.\n     *\n     * @param name The name of the child to overwrite.\n     * @returns A new Table with the supplied child for the specified name.\n     */\n  }, {\n    key: \"setChild\",\n    value: function setChild(name, child) {\n      var _b;\n      return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(function (f) {\n        return f.name === name;\n      }), child);\n    }\n  }, {\n    key: \"setChildAt\",\n    value: function setChildAt(index, child) {\n      var _this = this;\n      var schema = this.schema;\n      var batches = _toConsumableArray(this.batches);\n      if (index > -1 && index < this.numCols) {\n        if (!child) {\n          child = new Vector([makeData({\n            type: new Null(),\n            length: this.numRows\n          })]);\n        }\n        var fields = schema.fields.slice();\n        var field = fields[index].clone({\n          type: child.type\n        });\n        var children = this.schema.fields.map(function (_, i) {\n          return _this.getChildAt(i);\n        });\n        var _ref3 = [field, child];\n        fields[index] = _ref3[0];\n        children[index] = _ref3[1];\n        var _distributeVectorsInt3 = distributeVectorsIntoRecordBatches(schema, children);\n        var _distributeVectorsInt4 = _slicedToArray(_distributeVectorsInt3, 2);\n        schema = _distributeVectorsInt4[0];\n        batches = _distributeVectorsInt4[1];\n      }\n      return new Table(schema, batches);\n    }\n    /**\n     * Construct a new Table containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new Table of columns matching the specified names.\n     */\n  }, {\n    key: \"select\",\n    value: function select(columnNames) {\n      var nameToIndex = this.schema.fields.reduce(function (m, f, i) {\n        return m.set(f.name, i);\n      }, new Map());\n      return this.selectAt(columnNames.map(function (columnName) {\n        return nameToIndex.get(columnName);\n      }).filter(function (x) {\n        return x > -1;\n      }));\n    }\n    /**\n     * Construct a new Table containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new Table of columns at the specified indices.\n     */\n  }, {\n    key: \"selectAt\",\n    value: function selectAt(columnIndices) {\n      var schema = this.schema.selectAt(columnIndices);\n      var data = this.batches.map(function (batch) {\n        return batch.selectAt(columnIndices);\n      });\n      return new Table(schema, data);\n    }\n  }, {\n    key: \"assign\",\n    value: function assign(other) {\n      var _this2 = this;\n      var fields = this.schema.fields;\n      var _other$schema$fields$ = other.schema.fields.reduce(function (memo, f2, newIdx) {\n          var _memo = _slicedToArray(memo, 2),\n            indices = _memo[0],\n            oldToNew = _memo[1];\n          var i = fields.findIndex(function (f) {\n            return f.name === f2.name;\n          });\n          ~i ? oldToNew[i] = newIdx : indices.push(newIdx);\n          return memo;\n        }, [[], []]),\n        _other$schema$fields$2 = _slicedToArray(_other$schema$fields$, 2),\n        indices = _other$schema$fields$2[0],\n        oldToNew = _other$schema$fields$2[1];\n      var schema = this.schema.assign(other.schema);\n      var columns = [].concat(_toConsumableArray(fields.map(function (_, i) {\n        return [i, oldToNew[i]];\n      }).map(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          i = _ref5[0],\n          j = _ref5[1];\n        return j === undefined ? _this2.getChildAt(i) : other.getChildAt(j);\n      })), _toConsumableArray(indices.map(function (i) {\n        return other.getChildAt(i);\n      }))).filter(Boolean);\n      return _construct(Table, _toConsumableArray(distributeVectorsIntoRecordBatches(schema, columns)));\n    }\n  }]);\n  return Table;\n}(Symbol.iterator);\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nTable[_a] = function (proto) {\n  proto.schema = null;\n  proto.batches = [];\n  proto._offsets = new Uint32Array([0]);\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  proto['isValid'] = wrapChunkedCall1(isChunkedValid);\n  proto['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\n  proto['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\n  proto['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\n  proto['getByteLength'] = wrapChunkedCall1(byteLengthVisitor.getVisitFn(Type.Struct));\n  return 'Table';\n}(Table.prototype);\n/**\n * Creates a new Table from an object of typed arrays.\n *\n*  @example\n * ```ts\n * const table = makeTable({\n *   a: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays.\n * @returns A new Table.\n */\nexport function makeTable(input) {\n  var vecs = {};\n  var inputs = Object.entries(input);\n  for (var _i = 0, _inputs = inputs; _i < _inputs.length; _i++) {\n    var _inputs$_i = _slicedToArray(_inputs[_i], 2),\n      key = _inputs$_i[0],\n      col = _inputs$_i[1];\n    vecs[key] = makeVector(col);\n  }\n  return new Table(vecs);\n}\n/**\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\n *\n *  @example\n * ```ts\n * const table = tableFromArrays({\n *   a: [1, 2, 3],\n *   b: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays or JavaScript arrays.\n * @returns A new Table.\n */\nexport function tableFromArrays(input) {\n  var vecs = {};\n  var inputs = Object.entries(input);\n  for (var _i2 = 0, _inputs2 = inputs; _i2 < _inputs2.length; _i2++) {\n    var _inputs2$_i = _slicedToArray(_inputs2[_i2], 2),\n      key = _inputs2$_i[0],\n      col = _inputs2$_i[1];\n    vecs[key] = vectorFromArray(col);\n  }\n  return new Table(vecs);\n}","map":{"version":3,"names":["Type","Data","makeData","vectorFromArray","makeVector","Vector","Field","Schema","Null","Struct","compareSchemas","distributeVectorsIntoRecordBatches","isChunkedValid","computeChunkOffsets","computeChunkNullCounts","wrapChunkedCall1","wrapChunkedCall2","wrapChunkedIndexOf","sliceChunks","instance","getVisitor","setVisitor","indexOfVisitor","iteratorVisitor","byteLengthVisitor","clampRange","RecordBatch","Table","_Symbol$iterator","_classCallCheck","args","Array","_len","_key","arguments","length","batches","schema","_offsets","offsets","shift","Uint32Array","pop","unwrap","x","type","children","isArray","flatMap","v","Symbol","iterator","_toConsumableArray","keys","Object","vecs","map","k","i","String","_distributeVectorsInt","_distributeVectorsInt2","_slicedToArray","_c","_b","TypeError","_iterator","_createForOfIteratorHelper","_step","s","n","done","batch","value","err","e","f","data","_createClass","key","get","_ref","fields","reduce","numRows","_nullCount","isValid","index","set","indexOf","element","offset","getByteLength","visit","toArray","toString","concat","join","_len2","others","_key2","_ref2","slice","begin","end","_clampRange","_clampRange2","chunk","getChild","name","getChildAt","findIndex","empty","nullCount","push","_changeLengthAndBackfillNullBitmap","setChild","child","setChildAt","_this","numCols","field","clone","_","_ref3","_distributeVectorsInt3","_distributeVectorsInt4","select","columnNames","nameToIndex","m","Map","selectAt","columnName","filter","columnIndices","assign","other","_this2","_other$schema$fields$","memo","f2","newIdx","_memo","indices","oldToNew","_other$schema$fields$2","columns","_ref4","_ref5","j","undefined","Boolean","_construct","toStringTag","_a","proto","isConcatSpreadable","getVisitFn","prototype","makeTable","input","inputs","entries","_i","_inputs","_inputs$_i","col","tableFromArrays","_i2","_inputs2","_inputs2$_i"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/table.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Type } from './enum.js';\nimport { Data, makeData } from './data.js';\nimport { vectorFromArray } from './factories.js';\nimport { makeVector, Vector } from './vector.js';\nimport { Field, Schema } from './schema.js';\nimport { DataType, Null, Struct, TypeMap } from './type.js';\nimport { compareSchemas } from './visitor/typecomparator.js';\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.js';\n\nimport {\n    isChunkedValid,\n    computeChunkOffsets,\n    computeChunkNullCounts,\n    wrapChunkedCall1,\n    wrapChunkedCall2,\n    wrapChunkedIndexOf,\n    sliceChunks,\n} from './util/chunk.js';\n\nimport { instance as getVisitor } from './visitor/get.js';\nimport { instance as setVisitor } from './visitor/set.js';\nimport { instance as indexOfVisitor } from './visitor/indexof.js';\nimport { instance as iteratorVisitor } from './visitor/iterator.js';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.js';\n\nimport { DataProps } from './data.js';\nimport { clampRange } from './util/vector.js';\nimport { ArrayDataType, BigIntArray, TypedArray, TypedArrayDataType } from './interfaces.js';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from './recordbatch.js';\n\n/** @ignore */\nexport interface Table<T extends TypeMap = any> {\n    ///\n    // Virtual properties for the TypeScript compiler.\n    // These do not exist at runtime.\n    ///\n    readonly TType: Struct<T>;\n    readonly TArray: Struct<T>['TArray'];\n    readonly TValue: Struct<T>['TValue'];\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable\n     */\n    [Symbol.isConcatSpreadable]: true;\n}\n\n/**\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\n * {@link tableFromIPC}.\n */\nexport class Table<T extends TypeMap = any> {\n\n    constructor();\n    constructor(batches: Iterable<RecordBatch<T>>);\n    constructor(...batches: readonly RecordBatch<T>[]);\n    constructor(...columns: { [P in keyof T]: Vector<T[P]> }[]);\n    constructor(...columns: { [P in keyof T]: Data<T[P]> | DataProps<T[P]> }[]);\n    constructor(schema: Schema<T>, data?: RecordBatch<T> | RecordBatch<T>[]);\n    constructor(schema: Schema<T>, data?: RecordBatch<T> | RecordBatch<T>[], offsets?: Uint32Array);\n    constructor(...args: any[]) {\n\n        if (args.length === 0) {\n            this.batches = [];\n            this.schema = new Schema([]);\n            this._offsets = [0];\n            return this;\n        }\n\n        let schema: Schema<T> | undefined;\n        let offsets: Uint32Array | number[] | undefined;\n\n        if (args[0] instanceof Schema) {\n            schema = args.shift() as Schema<T>;\n        }\n\n        if (args[args.length - 1] instanceof Uint32Array) {\n            offsets = args.pop();\n        }\n\n        const unwrap = (x: any): RecordBatch<T>[] => {\n            if (x) {\n                if (x instanceof RecordBatch) {\n                    return [x];\n                } else if (x instanceof Table) {\n                    return x.batches;\n                } else if (x instanceof Data) {\n                    if (x.type instanceof Struct) {\n                        return [new RecordBatch(new Schema(x.type.children), x)];\n                    }\n                } else if (Array.isArray(x)) {\n                    return x.flatMap(v => unwrap(v));\n                } else if (typeof x[Symbol.iterator] === 'function') {\n                    return [...x].flatMap(v => unwrap(v));\n                } else if (typeof x === 'object') {\n                    const keys = Object.keys(x) as (keyof T)[];\n                    const vecs = keys.map((k) => new Vector([x[k]]));\n                    const schema = new Schema(keys.map((k, i) => new Field(String(k), vecs[i].type)));\n                    const [, batches] = distributeVectorsIntoRecordBatches(schema, vecs);\n                    return batches.length === 0 ? [new RecordBatch(x)] : batches;\n                }\n            }\n            return [];\n        };\n\n        const batches = args.flatMap(v => unwrap(v));\n\n        schema = schema ?? batches[0]?.schema ?? new Schema([]);\n\n        if (!(schema instanceof Schema)) {\n            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n        }\n\n        for (const batch of batches) {\n            if (!(batch instanceof RecordBatch)) {\n                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n            }\n            if (!compareSchemas(schema, batch.schema)) {\n                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\n            }\n        }\n\n        this.schema = schema;\n        this.batches = batches;\n        this._offsets = offsets ?? computeChunkOffsets(this.data);\n    }\n\n    declare protected _offsets: Uint32Array | number[];\n    declare protected _nullCount: number;\n\n    declare public readonly schema: Schema<T>;\n\n    /**\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n     */\n    declare public readonly batches: RecordBatch<T>[];\n\n    /**\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n     */\n    public get data() { return this.batches.map(({ data }) => data); }\n\n    /**\n     * The number of columns in this Table.\n     */\n    public get numCols() { return this.schema.fields.length; }\n\n    /**\n     * The number of rows in this Table.\n     */\n    public get numRows() {\n        return this.data.reduce((numRows, data) => numRows + data.length, 0);\n    }\n\n    /**\n     * The number of null rows in this Table.\n     */\n    public get nullCount() {\n        if (this._nullCount === -1) {\n            this._nullCount = computeChunkNullCounts(this.data);\n        }\n        return this._nullCount;\n    }\n\n    /**\n     * Check whether an element is null.\n     *\n     * @param index The index at which to read the validity bitmap.\n     */\n    // @ts-ignore\n    public isValid(index: number): boolean { return false; }\n\n    /**\n     * Get an element value by position.\n     *\n     * @param index The index of the element to read.\n     */\n    // @ts-ignore\n    public get(index: number): Struct<T>['TValue'] | null { return null; }\n\n    /**\n     * Set an element value by position.\n     *\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    // @ts-ignore\n    public set(index: number, value: Struct<T>['TValue'] | null): void { return; }\n\n    /**\n     * Retrieve the index of the first occurrence of a value in an Vector.\n     *\n     * @param element The value to locate in the Vector.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    // @ts-ignore\n    public indexOf(element: Struct<T>['TValue'], offset?: number): number { return -1; }\n\n    /**\n     * Get the size in bytes of an element by index.\n     * @param index The index at which to get the byteLength.\n     */\n    // @ts-ignore\n    public getByteLength(index: number): number { return 0; }\n\n    /**\n     * Iterator for rows in this Table.\n     */\n    public [Symbol.iterator]() {\n        if (this.batches.length > 0) {\n            return iteratorVisitor.visit(new Vector(this.data)) as IterableIterator<Struct<T>['TValue']>;\n        }\n        return (new Array(0))[Symbol.iterator]();\n    }\n\n    /**\n     * Return a JavaScript Array of the Table rows.\n     *\n     * @returns An Array of Table rows.\n     */\n    public toArray() {\n        return [...this];\n    }\n\n    /**\n     * Returns a string representation of the Table rows.\n     *\n     * @returns A string representation of the Table rows.\n     */\n    public toString() {\n        return `[\\n  ${this.toArray().join(',\\n  ')}\\n]`;\n    }\n\n    /**\n     * Combines two or more Tables of the same schema.\n     *\n     * @param others Additional Tables to add to the end of this Tables.\n     */\n    public concat(...others: Table<T>[]) {\n        const schema = this.schema;\n        const data = this.data.concat(others.flatMap(({ data }) => data));\n        return new Table(schema, data.map((data) => new RecordBatch(schema, data)));\n    }\n\n    /**\n     * Return a zero-copy sub-section of this Table.\n     *\n     * @param begin The beginning of the specified portion of the Table.\n     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n     */\n    public slice(begin?: number, end?: number): Table<T> {\n        const schema = this.schema;\n        [begin, end] = clampRange({ length: this.numRows }, begin, end);\n        const data = sliceChunks(this.data, this._offsets, begin, end);\n        return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\n    }\n\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     *\n     * @param name The name of the child to retrieve.\n     */\n    public getChild<P extends keyof T>(name: P) {\n        return this.getChildAt<T[P]>(this.schema.fields.findIndex((f) => f.name === name));\n    }\n\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     *\n     * @param index The index of the child to retrieve.\n     */\n    public getChildAt<R extends T[keyof T] = any>(index: number): Vector<R> | null {\n        if (index > -1 && index < this.schema.fields.length) {\n            const data = this.data.map((data) => data.children[index] as Data<R>);\n            if (data.length === 0) {\n                const { type } = this.schema.fields[index] as Field<R>;\n                const empty = makeData<R>({ type, length: 0, nullCount: 0 });\n                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\n            }\n            return new Vector(data);\n        }\n        return null;\n    }\n\n    /**\n     * Sets a child Vector by name.\n     *\n     * @param name The name of the child to overwrite.\n     * @returns A new Table with the supplied child for the specified name.\n     */\n    public setChild<P extends keyof T, R extends DataType>(name: P, child: Vector<R>) {\n        return this.setChildAt(this.schema.fields?.findIndex((f) => f.name === name), child) as Table<T & { [K in P]: R }>;\n    }\n\n    /**\n     * Sets a child Vector by index.\n     *\n     * @param index The index of the child to overwrite.\n     * @returns A new Table with the supplied child at the specified index.\n     */\n    public setChildAt(index: number, child?: null): Table;\n    public setChildAt<R extends DataType = any>(index: number, child: Vector<R>): Table;\n    public setChildAt(index: number, child: any) {\n        let schema: Schema = this.schema;\n        let batches: RecordBatch[] = [...this.batches];\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice() as Field<any>[];\n            const field = fields[index].clone({ type: child.type });\n            const children = this.schema.fields.map((_, i) => this.getChildAt(i)!);\n            [fields[index], children[index]] = [field, child];\n            [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);\n        }\n        return new Table(schema, batches);\n    }\n\n    /**\n     * Construct a new Table containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new Table of columns matching the specified names.\n     */\n    public select<K extends keyof T = any>(columnNames: K[]) {\n        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\n        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\n    }\n\n    /**\n     * Construct a new Table containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new Table of columns at the specified indices.\n     */\n    public selectAt<K extends T[keyof T] = any>(columnIndices: number[]) {\n        const schema = this.schema.selectAt(columnIndices);\n        const data = this.batches.map((batch) => batch.selectAt(columnIndices));\n        return new Table<{ [key: string]: K }>(schema, data);\n    }\n\n    public assign<R extends TypeMap = any>(other: Table<R>) {\n\n        const fields = this.schema.fields;\n        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n            const [indices, oldToNew] = memo;\n            const i = fields.findIndex((f) => f.name === f2.name);\n            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);\n            return memo;\n        }, [[], []] as number[][]);\n\n        const schema = this.schema.assign(other.schema);\n        const columns = [\n            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) =>\n                (j === undefined ? this.getChildAt(i) : other.getChildAt(j))!),\n            ...indices.map((i) => other.getChildAt(i)!)\n        ].filter(Boolean) as Vector<(T & R)[keyof T | keyof R]>[];\n\n        return new Table<T & R>(...distributeVectorsIntoRecordBatches<any>(schema, columns));\n    }\n\n    // Initialize this static property via an IIFE so bundlers don't tree-shake\n    // out this logic, but also so we're still compliant with `\"sideEffects\": false`\n    protected static [Symbol.toStringTag] = ((proto: Table) => {\n        (proto as any).schema = null;\n        (proto as any).batches = [];\n        (proto as any)._offsets = new Uint32Array([0]);\n        (proto as any)._nullCount = -1;\n        (proto as any)[Symbol.isConcatSpreadable] = true;\n        (proto as any)['isValid'] = wrapChunkedCall1(isChunkedValid);\n        (proto as any)['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\n        (proto as any)['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\n        (proto as any)['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\n        (proto as any)['getByteLength'] = wrapChunkedCall1(byteLengthVisitor.getVisitFn(Type.Struct));\n        return 'Table';\n    })(Table.prototype);\n}\n\n\ntype VectorsMap<T extends TypeMap> = { [P in keyof T]: Vector<T[P]> };\n\n/**\n * Creates a new Table from an object of typed arrays.\n *\n*  @example\n * ```ts\n * const table = makeTable({\n *   a: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays.\n * @returns A new Table.\n */\nexport function makeTable<I extends Record<string | number | symbol, TypedArray>>(input: I): Table<{ [P in keyof I]: TypedArrayDataType<I[P]> }> {\n    type T = { [P in keyof I]: TypedArrayDataType<I[P]> };\n    const vecs = {} as VectorsMap<T>;\n    const inputs = Object.entries(input) as [keyof I, I[keyof I]][];\n    for (const [key, col] of inputs) {\n        vecs[key] = makeVector(col);\n    }\n    return new Table<T>(vecs);\n}\n\n/**\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\n *\n *  @example\n * ```ts\n * const table = tableFromArrays({\n *   a: [1, 2, 3],\n *   b: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays or JavaScript arrays.\n * @returns A new Table.\n */\nexport function tableFromArrays<I extends Record<string | number | symbol, TypedArray | BigIntArray | readonly unknown[]>>(input: I): Table<{ [P in keyof I]: ArrayDataType<I[P]> }> {\n    type T = { [P in keyof I]: ArrayDataType<I[P]> };\n    const vecs = {} as VectorsMap<T>;\n    const inputs = Object.entries(input) as [keyof I, I[keyof I]][];\n    for (const [key, col] of inputs) {\n        vecs[key] = vectorFromArray(col);\n    }\n    return new Table<T>(vecs);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}