{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport { DictionaryBatch } from './dictionary-batch.mjs';\nimport { RecordBatch } from './record-batch.mjs';\nimport { Schema } from './schema.mjs';\nimport { SparseTensor } from './sparse-tensor.mjs';\nimport { Tensor } from './tensor.mjs';\n/**\n * ----------------------------------------------------------------------\n * The root Message type\n * This union enables us to easily send different message types without\n * redundant storage, and in the future we can easily add new message types.\n *\n * Arrow implementations do not need to implement all of the message types,\n * which may include experimental metadata types. For maximum compatibility,\n * it is best to send data using RecordBatch\n */\nexport var MessageHeader;\n(function (MessageHeader) {\n  MessageHeader[MessageHeader[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader[MessageHeader[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader[MessageHeader[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader[MessageHeader[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader[MessageHeader[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader[MessageHeader[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader || (MessageHeader = {}));\nexport function unionToMessageHeader(type, accessor) {\n  switch (MessageHeader[type]) {\n    case 'NONE':\n      return null;\n    case 'Schema':\n      return accessor(new Schema());\n    case 'DictionaryBatch':\n      return accessor(new DictionaryBatch());\n    case 'RecordBatch':\n      return accessor(new RecordBatch());\n    case 'Tensor':\n      return accessor(new Tensor());\n    case 'SparseTensor':\n      return accessor(new SparseTensor());\n    default:\n      return null;\n  }\n}\nexport function unionListToMessageHeader(type, accessor, index) {\n  switch (MessageHeader[type]) {\n    case 'NONE':\n      return null;\n    case 'Schema':\n      return accessor(index, new Schema());\n    case 'DictionaryBatch':\n      return accessor(index, new DictionaryBatch());\n    case 'RecordBatch':\n      return accessor(index, new RecordBatch());\n    case 'Tensor':\n      return accessor(index, new Tensor());\n    case 'SparseTensor':\n      return accessor(index, new SparseTensor());\n    default:\n      return null;\n  }\n}","map":{"version":3,"names":["DictionaryBatch","RecordBatch","Schema","SparseTensor","Tensor","MessageHeader","unionToMessageHeader","type","accessor","unionListToMessageHeader","index"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/template/my_component/frontend/node_modules/apache-arrow/src/fb/message-header.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport { DictionaryBatch } from './dictionary-batch.js';\nimport { RecordBatch } from './record-batch.js';\nimport { Schema } from './schema.js';\nimport { SparseTensor } from './sparse-tensor.js';\nimport { Tensor } from './tensor.js';\n\n\n/**\n * ----------------------------------------------------------------------\n * The root Message type\n * This union enables us to easily send different message types without\n * redundant storage, and in the future we can easily add new message types.\n *\n * Arrow implementations do not need to implement all of the message types,\n * which may include experimental metadata types. For maximum compatibility,\n * it is best to send data using RecordBatch\n */\nexport enum MessageHeader{\n  NONE = 0,\n  Schema = 1,\n  DictionaryBatch = 2,\n  RecordBatch = 3,\n  Tensor = 4,\n  SparseTensor = 5\n}\n\nexport function unionToMessageHeader(\n  type: MessageHeader,\n  accessor: (obj:DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor) => DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null\n): DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null {\n  switch(MessageHeader[type]) {\n    case 'NONE': return null;\n    case 'Schema': return accessor(new Schema())! as Schema;\n    case 'DictionaryBatch': return accessor(new DictionaryBatch())! as DictionaryBatch;\n    case 'RecordBatch': return accessor(new RecordBatch())! as RecordBatch;\n    case 'Tensor': return accessor(new Tensor())! as Tensor;\n    case 'SparseTensor': return accessor(new SparseTensor())! as SparseTensor;\n    default: return null;\n  }\n}\n\nexport function unionListToMessageHeader(\n  type: MessageHeader,\n  accessor: (index: number, obj:DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor) => DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null,\n  index: number\n): DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null {\n  switch(MessageHeader[type]) {\n    case 'NONE': return null;\n    case 'Schema': return accessor(index, new Schema())! as Schema;\n    case 'DictionaryBatch': return accessor(index, new DictionaryBatch())! as DictionaryBatch;\n    case 'RecordBatch': return accessor(index, new RecordBatch())! as RecordBatch;\n    case 'Tensor': return accessor(index, new Tensor())! as Tensor;\n    case 'SparseTensor': return accessor(index, new SparseTensor())! as SparseTensor;\n    default: return null;\n  }\n}\n\n"],"mappings":"AAAA;AAEA,SAASA,eAAe,QAAQ,wBAAwB;AACxD,SAASC,WAAW,QAAQ,oBAAoB;AAChD,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,MAAM,QAAQ,cAAc;AAGrC;;;;;;;;;;AAUA,WAAYC,aAOX;AAPD,WAAYA,aAAa;EACvBA,aAAA,CAAAA,aAAA,sBAAQ;EACRA,aAAA,CAAAA,aAAA,0BAAU;EACVA,aAAA,CAAAA,aAAA,4CAAmB;EACnBA,aAAA,CAAAA,aAAA,oCAAe;EACfA,aAAA,CAAAA,aAAA,0BAAU;EACVA,aAAA,CAAAA,aAAA,sCAAgB;AAClB,CAAC,EAPWA,aAAa,KAAbA,aAAa;AASzB,OAAM,SAAUC,oBAAoBA,CAClCC,IAAmB,EACnBC,QAAqI;EAErI,QAAOH,aAAa,CAACE,IAAI,CAAC;IACxB,KAAK,MAAM;MAAE,OAAO,IAAI;IACxB,KAAK,QAAQ;MAAE,OAAOC,QAAQ,CAAC,IAAIN,MAAM,EAAE,CAAY;IACvD,KAAK,iBAAiB;MAAE,OAAOM,QAAQ,CAAC,IAAIR,eAAe,EAAE,CAAqB;IAClF,KAAK,aAAa;MAAE,OAAOQ,QAAQ,CAAC,IAAIP,WAAW,EAAE,CAAiB;IACtE,KAAK,QAAQ;MAAE,OAAOO,QAAQ,CAAC,IAAIJ,MAAM,EAAE,CAAY;IACvD,KAAK,cAAc;MAAE,OAAOI,QAAQ,CAAC,IAAIL,YAAY,EAAE,CAAkB;IACzE;MAAS,OAAO,IAAI;;AAExB;AAEA,OAAM,SAAUM,wBAAwBA,CACtCF,IAAmB,EACnBC,QAAoJ,EACpJE,KAAa;EAEb,QAAOL,aAAa,CAACE,IAAI,CAAC;IACxB,KAAK,MAAM;MAAE,OAAO,IAAI;IACxB,KAAK,QAAQ;MAAE,OAAOC,QAAQ,CAACE,KAAK,EAAE,IAAIR,MAAM,EAAE,CAAY;IAC9D,KAAK,iBAAiB;MAAE,OAAOM,QAAQ,CAACE,KAAK,EAAE,IAAIV,eAAe,EAAE,CAAqB;IACzF,KAAK,aAAa;MAAE,OAAOQ,QAAQ,CAACE,KAAK,EAAE,IAAIT,WAAW,EAAE,CAAiB;IAC7E,KAAK,QAAQ;MAAE,OAAOO,QAAQ,CAACE,KAAK,EAAE,IAAIN,MAAM,EAAE,CAAY;IAC9D,KAAK,cAAc;MAAE,OAAOI,QAAQ,CAACE,KAAK,EAAE,IAAIP,YAAY,EAAE,CAAkB;IAChF;MAAS,OAAO,IAAI;;AAExB"},"metadata":{},"sourceType":"module","externalDependencies":[]}