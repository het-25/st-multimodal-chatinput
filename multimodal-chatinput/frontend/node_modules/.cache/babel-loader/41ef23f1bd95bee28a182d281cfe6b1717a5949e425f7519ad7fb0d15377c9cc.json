{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { BodyCompression } from './body-compression.mjs';\nimport { Buffer } from './buffer.mjs';\nimport { FieldNode } from './field-node.mjs';\n/**\n * A data header describing the shared memory layout of a \"record\" or \"row\"\n * batch. Some systems call this a \"row batch\" internally and others a \"record\n * batch\".\n */\nexport class RecordBatch {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  static getRootAsRecordBatch(bb, obj) {\n    return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  static getSizePrefixedRootAsRecordBatch(bb, obj) {\n    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n    return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  /**\n   * number of records / rows. The arrays in the batch should all have this\n   * length\n   */\n  length() {\n    const offset = this.bb.__offset(this.bb_pos, 4);\n    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);\n  }\n  /**\n   * Nodes correspond to the pre-ordered flattened logical schema\n   */\n  nodes(index, obj) {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;\n  }\n  nodesLength() {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  /**\n   * Buffers correspond to the pre-ordered flattened buffer tree\n   *\n   * The number of buffers appended to this list depends on the schema. For\n   * example, most primitive arrays will have 2 buffers, 1 for the validity\n   * bitmap and 1 for the values. For struct arrays, there will only be a\n   * single buffer for the validity (nulls) bitmap\n   */\n  buffers(index, obj) {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? (obj || new Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;\n  }\n  buffersLength() {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  /**\n   * Optional compression of the message body\n   */\n  compression(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  static startRecordBatch(builder) {\n    builder.startObject(4);\n  }\n  static addLength(builder, length) {\n    builder.addFieldInt64(0, length, builder.createLong(0, 0));\n  }\n  static addNodes(builder, nodesOffset) {\n    builder.addFieldOffset(1, nodesOffset, 0);\n  }\n  static startNodesVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addBuffers(builder, buffersOffset) {\n    builder.addFieldOffset(2, buffersOffset, 0);\n  }\n  static startBuffersVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addCompression(builder, compressionOffset) {\n    builder.addFieldOffset(3, compressionOffset, 0);\n  }\n  static endRecordBatch(builder) {\n    const offset = builder.endObject();\n    return offset;\n  }\n}","map":{"version":3,"names":["flatbuffers","BodyCompression","Buffer","FieldNode","RecordBatch","constructor","bb","bb_pos","__init","i","getRootAsRecordBatch","obj","readInt32","position","getSizePrefixedRootAsRecordBatch","setPosition","SIZE_PREFIX_LENGTH","length","offset","__offset","readInt64","createLong","nodes","index","__vector","nodesLength","__vector_len","buffers","buffersLength","compression","__indirect","startRecordBatch","builder","startObject","addLength","addFieldInt64","addNodes","nodesOffset","addFieldOffset","startNodesVector","numElems","startVector","addBuffers","buffersOffset","startBuffersVector","addCompression","compressionOffset","endRecordBatch","endObject"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/fb/record-batch.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { BodyCompression } from './body-compression.js';\nimport { Buffer } from './buffer.js';\nimport { FieldNode } from './field-node.js';\n\n\n/**\n * A data header describing the shared memory layout of a \"record\" or \"row\"\n * batch. Some systems call this a \"row batch\" internally and others a \"record\n * batch\".\n */\nexport class RecordBatch {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):RecordBatch {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsRecordBatch(bb:flatbuffers.ByteBuffer, obj?:RecordBatch):RecordBatch {\n  return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsRecordBatch(bb:flatbuffers.ByteBuffer, obj?:RecordBatch):RecordBatch {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\n/**\n * number of records / rows. The arrays in the batch should all have this\n * length\n */\nlength():flatbuffers.Long {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n}\n\n/**\n * Nodes correspond to the pre-ordered flattened logical schema\n */\nnodes(index: number, obj?:FieldNode):FieldNode|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? (obj || new FieldNode()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 16, this.bb!) : null;\n}\n\nnodesLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\n/**\n * Buffers correspond to the pre-ordered flattened buffer tree\n *\n * The number of buffers appended to this list depends on the schema. For\n * example, most primitive arrays will have 2 buffers, 1 for the validity\n * bitmap and 1 for the values. For struct arrays, there will only be a\n * single buffer for the validity (nulls) bitmap\n */\nbuffers(index: number, obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? (obj || new Buffer()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 16, this.bb!) : null;\n}\n\nbuffersLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\n/**\n * Optional compression of the message body\n */\ncompression(obj?:BodyCompression):BodyCompression|null {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? (obj || new BodyCompression()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\nstatic startRecordBatch(builder:flatbuffers.Builder) {\n  builder.startObject(4);\n}\n\nstatic addLength(builder:flatbuffers.Builder, length:flatbuffers.Long) {\n  builder.addFieldInt64(0, length, builder.createLong(0, 0));\n}\n\nstatic addNodes(builder:flatbuffers.Builder, nodesOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, nodesOffset, 0);\n}\n\nstatic startNodesVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(16, numElems, 8);\n}\n\nstatic addBuffers(builder:flatbuffers.Builder, buffersOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(2, buffersOffset, 0);\n}\n\nstatic startBuffersVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(16, numElems, 8);\n}\n\nstatic addCompression(builder:flatbuffers.Builder, compressionOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(3, compressionOffset, 0);\n}\n\nstatic endRecordBatch(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}