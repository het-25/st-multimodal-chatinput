{"ast":null,"code":"/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport hoistNonReactStatics from \"hoist-non-react-statics\";\nimport React from \"react\";\nimport { Streamlit } from \"./streamlit\";\n/**\n * Optional Streamlit React-based component base class.\n *\n * You are not required to extend this base class to create a Streamlit\n * component. If you decide not to extend it, you should implement the\n * `componentDidMount` and `componentDidUpdate` functions in your own class,\n * so that your plugin properly resizes.\n */\nvar StreamlitComponentBase = /** @class */function (_super) {\n  __extends(StreamlitComponentBase, _super);\n  function StreamlitComponentBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  StreamlitComponentBase.prototype.componentDidMount = function () {\n    // After we're rendered for the first time, tell Streamlit that our height\n    // has changed.\n    Streamlit.setFrameHeight();\n  };\n  StreamlitComponentBase.prototype.componentDidUpdate = function () {\n    // After we're updated, tell Streamlit that our height may have changed.\n    Streamlit.setFrameHeight();\n  };\n  return StreamlitComponentBase;\n}(React.PureComponent);\nexport { StreamlitComponentBase };\n/**\n * Wrapper for React-based Streamlit components.\n *\n * Bootstraps the communication interface between Streamlit and the component.\n */\nexport function withStreamlitConnection(WrappedComponent) {\n  var ComponentWrapper = /** @class */function (_super) {\n    __extends(ComponentWrapper, _super);\n    function ComponentWrapper(props) {\n      var _this = _super.call(this, props) || this;\n      _this.componentDidMount = function () {\n        // Set up event listeners, and signal to Streamlit that we're ready.\n        // We won't render the component until we receive the first RENDER_EVENT.\n        Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);\n        Streamlit.setComponentReady();\n      };\n      _this.componentDidUpdate = function () {\n        // If our child threw an error, we display it in render(). In this\n        // case, the child won't be mounted and therefore won't call\n        // `setFrameHeight` on its own. We do it here so that the rendered\n        // error will be visible.\n        if (_this.state.componentError != null) {\n          Streamlit.setFrameHeight();\n        }\n      };\n      _this.componentWillUnmount = function () {\n        Streamlit.events.removeEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);\n      };\n      /**\n       * Streamlit is telling this component to redraw.\n       * We save the render data in State, so that it can be passed to the\n       * component in our own render() function.\n       */\n      _this.onRenderEvent = function (event) {\n        // Update our state with the newest render data\n        _this.setState({\n          renderData: event.detail\n        });\n      };\n      _this.state = {\n        renderData: undefined,\n        componentError: undefined\n      };\n      return _this;\n    }\n    ComponentWrapper.prototype.render = function () {\n      // If our wrapped component threw an error, display it.\n      if (this.state.componentError != null) {\n        return React.createElement(\"div\", null, React.createElement(\"h1\", null, \"Component Error\"), React.createElement(\"span\", null, this.state.componentError.message));\n      }\n      // Don't render until we've gotten our first RENDER_EVENT from Streamlit.\n      if (this.state.renderData == null) {\n        return null;\n      }\n      return React.createElement(WrappedComponent, {\n        width: window.innerWidth,\n        disabled: this.state.renderData.disabled,\n        args: this.state.renderData.args,\n        theme: this.state.renderData.theme\n      });\n    };\n    /**\n     * Error boundary function. This will be called if our wrapped\n     * component throws an error. We store the caught error in our state,\n     * and display it in the next render().\n     */\n    ComponentWrapper.getDerivedStateFromError = function (error) {\n      return {\n        componentError: error\n      };\n    };\n    return ComponentWrapper;\n  }(React.PureComponent);\n  return hoistNonReactStatics(ComponentWrapper, WrappedComponent);\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","hoistNonReactStatics","React","Streamlit","StreamlitComponentBase","_super","apply","arguments","componentDidMount","setFrameHeight","componentDidUpdate","PureComponent","withStreamlitConnection","WrappedComponent","ComponentWrapper","props","_this","events","addEventListener","RENDER_EVENT","onRenderEvent","setComponentReady","state","componentError","componentWillUnmount","removeEventListener","event","setState","renderData","detail","undefined","render","createElement","message","width","window","innerWidth","disabled","args","theme","getDerivedStateFromError","error"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/streamlit-component-lib/dist/StreamlitReact.js"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport hoistNonReactStatics from \"hoist-non-react-statics\";\nimport React from \"react\";\nimport { Streamlit } from \"./streamlit\";\n/**\n * Optional Streamlit React-based component base class.\n *\n * You are not required to extend this base class to create a Streamlit\n * component. If you decide not to extend it, you should implement the\n * `componentDidMount` and `componentDidUpdate` functions in your own class,\n * so that your plugin properly resizes.\n */\nvar StreamlitComponentBase = /** @class */ (function (_super) {\n    __extends(StreamlitComponentBase, _super);\n    function StreamlitComponentBase() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StreamlitComponentBase.prototype.componentDidMount = function () {\n        // After we're rendered for the first time, tell Streamlit that our height\n        // has changed.\n        Streamlit.setFrameHeight();\n    };\n    StreamlitComponentBase.prototype.componentDidUpdate = function () {\n        // After we're updated, tell Streamlit that our height may have changed.\n        Streamlit.setFrameHeight();\n    };\n    return StreamlitComponentBase;\n}(React.PureComponent));\nexport { StreamlitComponentBase };\n/**\n * Wrapper for React-based Streamlit components.\n *\n * Bootstraps the communication interface between Streamlit and the component.\n */\nexport function withStreamlitConnection(WrappedComponent) {\n    var ComponentWrapper = /** @class */ (function (_super) {\n        __extends(ComponentWrapper, _super);\n        function ComponentWrapper(props) {\n            var _this = _super.call(this, props) || this;\n            _this.componentDidMount = function () {\n                // Set up event listeners, and signal to Streamlit that we're ready.\n                // We won't render the component until we receive the first RENDER_EVENT.\n                Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);\n                Streamlit.setComponentReady();\n            };\n            _this.componentDidUpdate = function () {\n                // If our child threw an error, we display it in render(). In this\n                // case, the child won't be mounted and therefore won't call\n                // `setFrameHeight` on its own. We do it here so that the rendered\n                // error will be visible.\n                if (_this.state.componentError != null) {\n                    Streamlit.setFrameHeight();\n                }\n            };\n            _this.componentWillUnmount = function () {\n                Streamlit.events.removeEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);\n            };\n            /**\n             * Streamlit is telling this component to redraw.\n             * We save the render data in State, so that it can be passed to the\n             * component in our own render() function.\n             */\n            _this.onRenderEvent = function (event) {\n                // Update our state with the newest render data\n                _this.setState({ renderData: event.detail });\n            };\n            _this.state = {\n                renderData: undefined,\n                componentError: undefined\n            };\n            return _this;\n        }\n        ComponentWrapper.prototype.render = function () {\n            // If our wrapped component threw an error, display it.\n            if (this.state.componentError != null) {\n                return (React.createElement(\"div\", null,\n                    React.createElement(\"h1\", null, \"Component Error\"),\n                    React.createElement(\"span\", null, this.state.componentError.message)));\n            }\n            // Don't render until we've gotten our first RENDER_EVENT from Streamlit.\n            if (this.state.renderData == null) {\n                return null;\n            }\n            return (React.createElement(WrappedComponent, { width: window.innerWidth, disabled: this.state.renderData.disabled, args: this.state.renderData.args, theme: this.state.renderData.theme }));\n        };\n        /**\n         * Error boundary function. This will be called if our wrapped\n         * component throws an error. We store the caught error in our state,\n         * and display it in the next render().\n         */\n        ComponentWrapper.getDerivedStateFromError = function (error) {\n            return { componentError: error };\n        };\n        return ComponentWrapper;\n    }(React.PureComponent));\n    return hoistNonReactStatics(ComponentWrapper, WrappedComponent);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}