{"ast":null,"code":"import _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { TimeUnit } from './time-unit.mjs';\n/**\n * Timestamp is a 64-bit signed integer representing an elapsed time since a\n * fixed epoch, stored in either of four units: seconds, milliseconds,\n * microseconds or nanoseconds, and is optionally annotated with a timezone.\n *\n * Timestamp values do not include any leap seconds (in other words, all\n * days are considered 86400 seconds long).\n *\n * Timestamps with a non-empty timezone\n * ------------------------------------\n *\n * If a Timestamp column has a non-empty timezone value, its epoch is\n * 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone\n * (the Unix epoch), regardless of the Timestamp's own timezone.\n *\n * Therefore, timestamp values with a non-empty timezone correspond to\n * physical points in time together with some additional information about\n * how the data was obtained and/or how to display it (the timezone).\n *\n *   For example, the timestamp value 0 with the timezone string \"Europe/Paris\"\n *   corresponds to \"January 1st 1970, 00h00\" in the UTC timezone, but the\n *   application may prefer to display it as \"January 1st 1970, 01h00\" in\n *   the Europe/Paris timezone (which is the same physical point in time).\n *\n * One consequence is that timestamp values with a non-empty timezone\n * can be compared and ordered directly, since they all share the same\n * well-known point of reference (the Unix epoch).\n *\n * Timestamps with an unset / empty timezone\n * -----------------------------------------\n *\n * If a Timestamp column has no timezone value, its epoch is\n * 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.\n *\n * Therefore, timestamp values without a timezone cannot be meaningfully\n * interpreted as physical points in time, but only as calendar / clock\n * indications (\"wall clock time\") in an unspecified timezone.\n *\n *   For example, the timestamp value 0 with an empty timezone string\n *   corresponds to \"January 1st 1970, 00h00\" in an unknown timezone: there\n *   is not enough information to interpret it as a well-defined physical\n *   point in time.\n *\n * One consequence is that timestamp values without a timezone cannot\n * be reliably compared or ordered, since they may have different points of\n * reference.  In particular, it is *not* possible to interpret an unset\n * or empty timezone as the same as \"UTC\".\n *\n * Conversion between timezones\n * ----------------------------\n *\n * If a Timestamp column has a non-empty timezone, changing the timezone\n * to a different non-empty value is a metadata-only operation:\n * the timestamp values need not change as their point of reference remains\n * the same (the Unix epoch).\n *\n * However, if a Timestamp column has no timezone value, changing it to a\n * non-empty value requires to think about the desired semantics.\n * One possibility is to assume that the original timestamp values are\n * relative to the epoch of the timezone being set; timestamp values should\n * then adjusted to the Unix epoch (for example, changing the timezone from\n * empty to \"Europe/Paris\" would require converting the timestamp values\n * from \"Europe/Paris\" to \"UTC\", which seems counter-intuitive but is\n * nevertheless correct).\n *\n * Guidelines for encoding data from external libraries\n * ----------------------------------------------------\n *\n * Date & time libraries often have multiple different data types for temporal\n * data. In order to ease interoperability between different implementations the\n * Arrow project has some recommendations for encoding these types into a Timestamp\n * column.\n *\n * An \"instant\" represents a physical point in time that has no relevant timezone\n * (for example, astronomical data). To encode an instant, use a Timestamp with\n * the timezone string set to \"UTC\", and make sure the Timestamp values\n * are relative to the UTC epoch (January 1st 1970, midnight).\n *\n * A \"zoned date-time\" represents a physical point in time annotated with an\n * informative timezone (for example, the timezone in which the data was\n * recorded).  To encode a zoned date-time, use a Timestamp with the timezone\n * string set to the name of the timezone, and make sure the Timestamp values\n * are relative to the UTC epoch (January 1st 1970, midnight).\n *\n *  (There is some ambiguity between an instant and a zoned date-time with the\n *   UTC timezone.  Both of these are stored the same in Arrow.  Typically,\n *   this distinction does not matter.  If it does, then an application should\n *   use custom metadata or an extension type to distinguish between the two cases.)\n *\n * An \"offset date-time\" represents a physical point in time combined with an\n * explicit offset from UTC.  To encode an offset date-time, use a Timestamp\n * with the timezone string set to the numeric timezone offset string\n * (e.g. \"+03:00\"), and make sure the Timestamp values are relative to\n * the UTC epoch (January 1st 1970, midnight).\n *\n * A \"naive date-time\" (also called \"local date-time\" in some libraries)\n * represents a wall clock time combined with a calendar date, but with\n * no indication of how to map this information to a physical point in time.\n * Naive date-times must be handled with care because of this missing\n * information, and also because daylight saving time (DST) may make\n * some values ambiguous or non-existent. A naive date-time may be\n * stored as a struct with Date and Time fields. However, it may also be\n * encoded into a Timestamp column with an empty timezone. The timestamp\n * values should be computed \"as if\" the timezone of the date-time values\n * was UTC; for example, the naive date-time \"January 1st 1970, 00h00\" would\n * be encoded as timestamp value 0.\n */\nexport var Timestamp = /*#__PURE__*/function () {\n  function Timestamp() {\n    _classCallCheck(this, Timestamp);\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  _createClass(Timestamp, [{\n    key: \"__init\",\n    value: function __init(i, bb) {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n  }, {\n    key: \"unit\",\n    value: function unit() {\n      var offset = this.bb.__offset(this.bb_pos, 4);\n      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.SECOND;\n    }\n  }, {\n    key: \"timezone\",\n    value: function timezone(optionalEncoding) {\n      var offset = this.bb.__offset(this.bb_pos, 6);\n      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n  }], [{\n    key: \"getRootAsTimestamp\",\n    value: function getRootAsTimestamp(bb, obj) {\n      return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n  }, {\n    key: \"getSizePrefixedRootAsTimestamp\",\n    value: function getSizePrefixedRootAsTimestamp(bb, obj) {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n  }, {\n    key: \"startTimestamp\",\n    value: function startTimestamp(builder) {\n      builder.startObject(2);\n    }\n  }, {\n    key: \"addUnit\",\n    value: function addUnit(builder, unit) {\n      builder.addFieldInt16(0, unit, TimeUnit.SECOND);\n    }\n  }, {\n    key: \"addTimezone\",\n    value: function addTimezone(builder, timezoneOffset) {\n      builder.addFieldOffset(1, timezoneOffset, 0);\n    }\n  }, {\n    key: \"endTimestamp\",\n    value: function endTimestamp(builder) {\n      var offset = builder.endObject();\n      return offset;\n    }\n  }, {\n    key: \"createTimestamp\",\n    value: function createTimestamp(builder, unit, timezoneOffset) {\n      Timestamp.startTimestamp(builder);\n      Timestamp.addUnit(builder, unit);\n      Timestamp.addTimezone(builder, timezoneOffset);\n      return Timestamp.endTimestamp(builder);\n    }\n  }]);\n  return Timestamp;\n}();","map":{"version":3,"names":["flatbuffers","TimeUnit","Timestamp","_classCallCheck","bb","bb_pos","_createClass","key","value","__init","i","unit","offset","__offset","readInt16","SECOND","timezone","optionalEncoding","__string","getRootAsTimestamp","obj","readInt32","position","getSizePrefixedRootAsTimestamp","setPosition","SIZE_PREFIX_LENGTH","startTimestamp","builder","startObject","addUnit","addFieldInt16","addTimezone","timezoneOffset","addFieldOffset","endTimestamp","endObject","createTimestamp"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/fb/timestamp.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { TimeUnit } from './time-unit.js';\n\n\n/**\n * Timestamp is a 64-bit signed integer representing an elapsed time since a\n * fixed epoch, stored in either of four units: seconds, milliseconds,\n * microseconds or nanoseconds, and is optionally annotated with a timezone.\n *\n * Timestamp values do not include any leap seconds (in other words, all\n * days are considered 86400 seconds long).\n *\n * Timestamps with a non-empty timezone\n * ------------------------------------\n *\n * If a Timestamp column has a non-empty timezone value, its epoch is\n * 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone\n * (the Unix epoch), regardless of the Timestamp's own timezone.\n *\n * Therefore, timestamp values with a non-empty timezone correspond to\n * physical points in time together with some additional information about\n * how the data was obtained and/or how to display it (the timezone).\n *\n *   For example, the timestamp value 0 with the timezone string \"Europe/Paris\"\n *   corresponds to \"January 1st 1970, 00h00\" in the UTC timezone, but the\n *   application may prefer to display it as \"January 1st 1970, 01h00\" in\n *   the Europe/Paris timezone (which is the same physical point in time).\n *\n * One consequence is that timestamp values with a non-empty timezone\n * can be compared and ordered directly, since they all share the same\n * well-known point of reference (the Unix epoch).\n *\n * Timestamps with an unset / empty timezone\n * -----------------------------------------\n *\n * If a Timestamp column has no timezone value, its epoch is\n * 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.\n *\n * Therefore, timestamp values without a timezone cannot be meaningfully\n * interpreted as physical points in time, but only as calendar / clock\n * indications (\"wall clock time\") in an unspecified timezone.\n *\n *   For example, the timestamp value 0 with an empty timezone string\n *   corresponds to \"January 1st 1970, 00h00\" in an unknown timezone: there\n *   is not enough information to interpret it as a well-defined physical\n *   point in time.\n *\n * One consequence is that timestamp values without a timezone cannot\n * be reliably compared or ordered, since they may have different points of\n * reference.  In particular, it is *not* possible to interpret an unset\n * or empty timezone as the same as \"UTC\".\n *\n * Conversion between timezones\n * ----------------------------\n *\n * If a Timestamp column has a non-empty timezone, changing the timezone\n * to a different non-empty value is a metadata-only operation:\n * the timestamp values need not change as their point of reference remains\n * the same (the Unix epoch).\n *\n * However, if a Timestamp column has no timezone value, changing it to a\n * non-empty value requires to think about the desired semantics.\n * One possibility is to assume that the original timestamp values are\n * relative to the epoch of the timezone being set; timestamp values should\n * then adjusted to the Unix epoch (for example, changing the timezone from\n * empty to \"Europe/Paris\" would require converting the timestamp values\n * from \"Europe/Paris\" to \"UTC\", which seems counter-intuitive but is\n * nevertheless correct).\n *\n * Guidelines for encoding data from external libraries\n * ----------------------------------------------------\n *\n * Date & time libraries often have multiple different data types for temporal\n * data. In order to ease interoperability between different implementations the\n * Arrow project has some recommendations for encoding these types into a Timestamp\n * column.\n *\n * An \"instant\" represents a physical point in time that has no relevant timezone\n * (for example, astronomical data). To encode an instant, use a Timestamp with\n * the timezone string set to \"UTC\", and make sure the Timestamp values\n * are relative to the UTC epoch (January 1st 1970, midnight).\n *\n * A \"zoned date-time\" represents a physical point in time annotated with an\n * informative timezone (for example, the timezone in which the data was\n * recorded).  To encode a zoned date-time, use a Timestamp with the timezone\n * string set to the name of the timezone, and make sure the Timestamp values\n * are relative to the UTC epoch (January 1st 1970, midnight).\n *\n *  (There is some ambiguity between an instant and a zoned date-time with the\n *   UTC timezone.  Both of these are stored the same in Arrow.  Typically,\n *   this distinction does not matter.  If it does, then an application should\n *   use custom metadata or an extension type to distinguish between the two cases.)\n *\n * An \"offset date-time\" represents a physical point in time combined with an\n * explicit offset from UTC.  To encode an offset date-time, use a Timestamp\n * with the timezone string set to the numeric timezone offset string\n * (e.g. \"+03:00\"), and make sure the Timestamp values are relative to\n * the UTC epoch (January 1st 1970, midnight).\n *\n * A \"naive date-time\" (also called \"local date-time\" in some libraries)\n * represents a wall clock time combined with a calendar date, but with\n * no indication of how to map this information to a physical point in time.\n * Naive date-times must be handled with care because of this missing\n * information, and also because daylight saving time (DST) may make\n * some values ambiguous or non-existent. A naive date-time may be\n * stored as a struct with Date and Time fields. However, it may also be\n * encoded into a Timestamp column with an empty timezone. The timestamp\n * values should be computed \"as if\" the timezone of the date-time values\n * was UTC; for example, the naive date-time \"January 1st 1970, 00h00\" would\n * be encoded as timestamp value 0.\n */\nexport class Timestamp {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):Timestamp {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsTimestamp(bb:flatbuffers.ByteBuffer, obj?:Timestamp):Timestamp {\n  return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsTimestamp(bb:flatbuffers.ByteBuffer, obj?:Timestamp):Timestamp {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nunit():TimeUnit {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? this.bb!.readInt16(this.bb_pos + offset) : TimeUnit.SECOND;\n}\n\n/**\n * The timezone is an optional string indicating the name of a timezone,\n * one of:\n *\n * * As used in the Olson timezone database (the \"tz database\" or\n *   \"tzdata\"), such as \"America/New_York\".\n * * An absolute timezone offset of the form \"+XX:XX\" or \"-XX:XX\",\n *   such as \"+07:30\".\n *\n * Whether a timezone string is present indicates different semantics about\n * the data (see above).\n */\ntimezone():string|null\ntimezone(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null\ntimezone(optionalEncoding?:any):string|Uint8Array|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n}\n\nstatic startTimestamp(builder:flatbuffers.Builder) {\n  builder.startObject(2);\n}\n\nstatic addUnit(builder:flatbuffers.Builder, unit:TimeUnit) {\n  builder.addFieldInt16(0, unit, TimeUnit.SECOND);\n}\n\nstatic addTimezone(builder:flatbuffers.Builder, timezoneOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, timezoneOffset, 0);\n}\n\nstatic endTimestamp(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  return offset;\n}\n\nstatic createTimestamp(builder:flatbuffers.Builder, unit:TimeUnit, timezoneOffset:flatbuffers.Offset):flatbuffers.Offset {\n  Timestamp.startTimestamp(builder);\n  Timestamp.addUnit(builder, unit);\n  Timestamp.addTimezone(builder, timezoneOffset);\n  return Timestamp.endTimestamp(builder);\n}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}