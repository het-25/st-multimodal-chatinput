{"ast":null,"code":"import _inherits from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Data, makeData } from './data.mjs';\nimport { Table } from './table.mjs';\nimport { Vector } from './vector.mjs';\nimport { Schema, Field } from './schema.mjs';\nimport { DataType, Struct, Null } from './type.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.mjs';\n/** @ignore */\nexport var RecordBatch = /*#__PURE__*/function (_Symbol$iterator) {\n  function RecordBatch() {\n    _classCallCheck(this, RecordBatch);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    switch (args.length) {\n      case 2:\n        {\n          this.schema = args[0];\n          if (!(this.schema instanceof Schema)) {\n            throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n          }\n          var _args$ = args[1];\n          this.data = _args$ === void 0 ? makeData({\n            nullCount: 0,\n            type: new Struct(this.schema.fields),\n            children: this.schema.fields.map(function (f) {\n              return makeData({\n                type: f.type,\n                nullCount: 0\n              });\n            })\n          }) : _args$;\n          if (!(this.data instanceof Data)) {\n            throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n          }\n          var _ensureSameLengthData = ensureSameLengthData(this.schema, this.data.children);\n          var _ensureSameLengthData2 = _slicedToArray(_ensureSameLengthData, 2);\n          this.schema = _ensureSameLengthData2[0];\n          this.data = _ensureSameLengthData2[1];\n          break;\n        }\n      case 1:\n        {\n          var obj = args[0];\n          var _Object$keys$reduce = Object.keys(obj).reduce(function (memo, name, i) {\n              memo.children[i] = obj[name];\n              memo.length = Math.max(memo.length, obj[name].length);\n              memo.fields[i] = Field.new({\n                name: name,\n                type: obj[name].type,\n                nullable: true\n              });\n              return memo;\n            }, {\n              length: 0,\n              fields: new Array(),\n              children: new Array()\n            }),\n            fields = _Object$keys$reduce.fields,\n            children = _Object$keys$reduce.children,\n            length = _Object$keys$reduce.length;\n          var schema = new Schema(fields);\n          var data = makeData({\n            type: new Struct(fields),\n            length: length,\n            children: children,\n            nullCount: 0\n          });\n          var _ensureSameLengthData3 = ensureSameLengthData(schema, data.children, length);\n          var _ensureSameLengthData4 = _slicedToArray(_ensureSameLengthData3, 2);\n          this.schema = _ensureSameLengthData4[0];\n          this.data = _ensureSameLengthData4[1];\n          break;\n        }\n      default:\n        throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n    }\n  }\n  _createClass(RecordBatch, [{\n    key: \"dictionaries\",\n    get: function get() {\n      return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n    }\n    /**\n     * The number of columns in this RecordBatch.\n     */\n  }, {\n    key: \"numCols\",\n    get: function get() {\n      return this.schema.fields.length;\n    }\n    /**\n     * The number of rows in this RecordBatch.\n     */\n  }, {\n    key: \"numRows\",\n    get: function get() {\n      return this.data.length;\n    }\n    /**\n     * The number of null rows in this RecordBatch.\n     */\n  }, {\n    key: \"nullCount\",\n    get: function get() {\n      return this.data.nullCount;\n    }\n    /**\n     * Check whether an element is null.\n     * @param index The index at which to read the validity bitmap.\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid(index) {\n      return this.data.getValid(index);\n    }\n    /**\n     * Get a row by position.\n     * @param index The index of the element to read.\n     */\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return getVisitor.visit(this.data, index);\n    }\n    /**\n     * Set a row by position.\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      return setVisitor.visit(this.data, index, value);\n    }\n    /**\n     * Retrieve the index of the first occurrence of a row in an RecordBatch.\n     * @param element The row to locate in the RecordBatch.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(element, offset) {\n      return indexOfVisitor.visit(this.data, element, offset);\n    }\n    /**\n     * Get the size (in bytes) of a row by index.\n     * @param index The row index for which to compute the byteLength.\n     */\n  }, {\n    key: \"getByteLength\",\n    value: function getByteLength(index) {\n      return byteLengthVisitor.visit(this.data, index);\n    }\n    /**\n     * Iterator for rows in this RecordBatch.\n     */\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return iteratorVisitor.visit(new Vector([this.data]));\n    }\n    /**\n     * Return a JavaScript Array of the RecordBatch rows.\n     * @returns An Array of RecordBatch rows.\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return _toConsumableArray(this);\n    }\n    /**\n     * Combines two or more RecordBatch of the same schema.\n     * @param others Additional RecordBatch to add to the end of this RecordBatch.\n     */\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      for (var _len2 = arguments.length, others = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        others[_key2] = arguments[_key2];\n      }\n      return new Table(this.schema, [this].concat(others));\n    }\n    /**\n     * Return a zero-copy sub-section of this RecordBatch.\n     * @param start The beginning of the specified portion of the RecordBatch.\n     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n     */\n  }, {\n    key: \"slice\",\n    value: function slice(begin, end) {\n      var _Vector$slice$data = _slicedToArray(new Vector([this.data]).slice(begin, end).data, 1),\n        slice = _Vector$slice$data[0];\n      return new RecordBatch(this.schema, slice);\n    }\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     * @param name The name of the child to retrieve.\n     */\n  }, {\n    key: \"getChild\",\n    value: function getChild(name) {\n      var _b;\n      return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(function (f) {\n        return f.name === name;\n      }));\n    }\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     * @param index The index of the child to retrieve.\n     */\n  }, {\n    key: \"getChildAt\",\n    value: function getChildAt(index) {\n      if (index > -1 && index < this.schema.fields.length) {\n        return new Vector([this.data.children[index]]);\n      }\n      return null;\n    }\n    /**\n     * Sets a child Vector by name.\n     * @param name The name of the child to overwrite.\n     * @returns A new RecordBatch with the new child for the specified name.\n     */\n  }, {\n    key: \"setChild\",\n    value: function setChild(name, child) {\n      var _b;\n      return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(function (f) {\n        return f.name === name;\n      }), child);\n    }\n  }, {\n    key: \"setChildAt\",\n    value: function setChildAt(index, child) {\n      var schema = this.schema;\n      var data = this.data;\n      if (index > -1 && index < this.numCols) {\n        if (!child) {\n          child = new Vector([makeData({\n            type: new Null(),\n            length: this.numRows\n          })]);\n        }\n        var fields = schema.fields.slice();\n        var children = data.children.slice();\n        var field = fields[index].clone({\n          type: child.type\n        });\n        var _ref = [field, child.data[0]];\n        fields[index] = _ref[0];\n        children[index] = _ref[1];\n        schema = new Schema(fields, new Map(this.schema.metadata));\n        data = makeData({\n          type: new Struct(fields),\n          children: children\n        });\n      }\n      return new RecordBatch(schema, data);\n    }\n    /**\n     * Construct a new RecordBatch containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new RecordBatch of columns matching the specified names.\n     */\n  }, {\n    key: \"select\",\n    value: function select(columnNames) {\n      var _this = this;\n      var schema = this.schema.select(columnNames);\n      var type = new Struct(schema.fields);\n      var children = [];\n      var _iterator = _createForOfIteratorHelper(columnNames),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var name = _step.value;\n          var index = _this.schema.fields.findIndex(function (f) {\n            return f.name === name;\n          });\n          if (~index) {\n            children[index] = _this.data.children[index];\n          }\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return new RecordBatch(schema, makeData({\n        type: type,\n        length: this.numRows,\n        children: children\n      }));\n    }\n    /**\n     * Construct a new RecordBatch containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new RecordBatch of columns matching at the specified indices.\n     */\n  }, {\n    key: \"selectAt\",\n    value: function selectAt(columnIndices) {\n      var _this2 = this;\n      var schema = this.schema.selectAt(columnIndices);\n      var children = columnIndices.map(function (i) {\n        return _this2.data.children[i];\n      }).filter(Boolean);\n      var subset = makeData({\n        type: new Struct(schema.fields),\n        length: this.numRows,\n        children: children\n      });\n      return new RecordBatch(schema, subset);\n    }\n  }]);\n  return RecordBatch;\n}(Symbol.iterator);\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nRecordBatch[_a] = function (proto) {\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  return 'RecordBatch';\n}(RecordBatch.prototype);\n/** @ignore */\nfunction ensureSameLengthData(schema, chunks) {\n  var maxLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : chunks.reduce(function (max, col) {\n    return Math.max(max, col.length);\n  }, 0);\n  var _b;\n  var fields = _toConsumableArray(schema.fields);\n  var children = _toConsumableArray(chunks);\n  var nullBitmapSize = (maxLength + 63 & ~63) >> 3;\n  var _iterator2 = _createForOfIteratorHelper(schema.fields.entries()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        idx = _step2$value[0],\n        field = _step2$value[1];\n      var chunk = chunks[idx];\n      if (!chunk || chunk.length !== maxLength) {\n        fields[idx] = field.clone({\n          nullable: true\n        });\n        children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : makeData({\n          type: field.type,\n          length: maxLength,\n          nullCount: maxLength,\n          nullBitmap: new Uint8Array(nullBitmapSize)\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return [schema.assign(fields), makeData({\n    type: new Struct(fields),\n    length: maxLength,\n    children: children\n  })];\n}\n/** @ignore */\nfunction collectDictionaries(fields, children) {\n  var dictionaries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  for (var i = -1, n = fields.length; ++i < n;) {\n    var field = fields[i];\n    var type = field.type;\n    var data = children[i];\n    if (DataType.isDictionary(type)) {\n      if (!dictionaries.has(type.id)) {\n        if (data.dictionary) {\n          dictionaries.set(type.id, data.dictionary);\n        }\n      } else if (dictionaries.get(type.id) !== data.dictionary) {\n        throw new Error(\"Cannot create Schema containing two different dictionaries with the same Id\");\n      }\n    }\n    if (type.children && type.children.length > 0) {\n      collectDictionaries(type.children, data.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport var _InternalEmptyPlaceholderRecordBatch = /*#__PURE__*/function (_RecordBatch) {\n  _inherits(_InternalEmptyPlaceholderRecordBatch, _RecordBatch);\n  var _super = _createSuper(_InternalEmptyPlaceholderRecordBatch);\n  function _InternalEmptyPlaceholderRecordBatch(schema) {\n    _classCallCheck(this, _InternalEmptyPlaceholderRecordBatch);\n    var children = schema.fields.map(function (f) {\n      return makeData({\n        type: f.type\n      });\n    });\n    var data = makeData({\n      type: new Struct(schema.fields),\n      nullCount: 0,\n      children: children\n    });\n    return _super.call(this, schema, data);\n  }\n  return _createClass(_InternalEmptyPlaceholderRecordBatch);\n}(RecordBatch);","map":{"version":3,"names":["Data","makeData","Table","Vector","Schema","Field","DataType","Struct","Null","instance","getVisitor","setVisitor","indexOfVisitor","iteratorVisitor","byteLengthVisitor","RecordBatch","_Symbol$iterator","_classCallCheck","_len","arguments","length","args","Array","_key","schema","TypeError","_args$","data","nullCount","type","fields","children","map","f","_ensureSameLengthData","ensureSameLengthData","_ensureSameLengthData2","_slicedToArray","obj","_Object$keys$reduce","Object","keys","reduce","memo","name","i","Math","max","new","nullable","_ensureSameLengthData3","_ensureSameLengthData4","_createClass","key","get","_dictionaries","collectDictionaries","value","isValid","index","getValid","visit","set","indexOf","element","offset","getByteLength","toArray","_toConsumableArray","concat","_len2","others","_key2","slice","begin","end","_Vector$slice$data","getChild","getChildAt","_b","findIndex","setChild","child","setChildAt","numCols","numRows","field","clone","_ref","Map","metadata","select","columnNames","_this","_iterator","_createForOfIteratorHelper","_step","_loop","s","n","done","err","e","selectAt","columnIndices","_this2","filter","Boolean","subset","Symbol","iterator","toStringTag","_a","proto","_nullCount","isConcatSpreadable","prototype","chunks","maxLength","undefined","col","nullBitmapSize","_iterator2","entries","_step2","_step2$value","idx","chunk","_changeLengthAndBackfillNullBitmap","nullBitmap","Uint8Array","assign","dictionaries","isDictionary","has","id","dictionary","Error","_InternalEmptyPlaceholderRecordBatch","_RecordBatch","_inherits","_super","_createSuper","call"],"sources":["/Users/hetpatel/Downloads/Dhandha/testing libraries/component-template/multimodal-chatinput/multimodal-chatinput/frontend/node_modules/apache-arrow/src/recordbatch.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data, makeData } from './data.js';\nimport { Table } from './table.js';\nimport { Vector } from './vector.js';\nimport { Schema, Field } from './schema.js';\nimport { DataType, Struct, Null, TypeMap } from './type.js';\n\nimport { instance as getVisitor } from './visitor/get.js';\nimport { instance as setVisitor } from './visitor/set.js';\nimport { instance as indexOfVisitor } from './visitor/indexof.js';\nimport { instance as iteratorVisitor } from './visitor/iterator.js';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.js';\n\n/** @ignore */\nexport interface RecordBatch<T extends TypeMap = any> {\n    ///\n    // Virtual properties for the TypeScript compiler.\n    // These do not exist at runtime.\n    ///\n    readonly TType: Struct<T>;\n    readonly TArray: Struct<T>['TArray'];\n    readonly TValue: Struct<T>['TValue'];\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable\n     */\n    [Symbol.isConcatSpreadable]: true;\n}\n\n/** @ignore */\nexport class RecordBatch<T extends TypeMap = any> {\n\n    constructor(columns: { [P in keyof T]: Data<T[P]> });\n    constructor(schema: Schema<T>, data?: Data<Struct<T>>);\n    constructor(...args: any[]) {\n        switch (args.length) {\n            case 2: {\n                [this.schema] = args;\n                if (!(this.schema instanceof Schema)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [,\n                    this.data = makeData({\n                        nullCount: 0,\n                        type: new Struct<T>(this.schema.fields),\n                        children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n                    })\n                ] = args;\n                if (!(this.data instanceof Data)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [this.schema, this.data] = ensureSameLengthData<T>(this.schema, this.data.children as Data<T[keyof T]>[]);\n                break;\n            }\n            case 1: {\n                const [obj] = args;\n                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {\n                    memo.children[i] = obj[name];\n                    memo.length = Math.max(memo.length, obj[name].length);\n                    memo.fields[i] = Field.new({ name, type: obj[name].type, nullable: true });\n                    return memo;\n                }, {\n                    length: 0,\n                    fields: new Array<Field<T[keyof T]>>(),\n                    children: new Array<Data<T[keyof T]>>(),\n                });\n\n                const schema = new Schema<T>(fields);\n                const data = makeData({ type: new Struct<T>(fields), length, children, nullCount: 0 });\n                [this.schema, this.data] = ensureSameLengthData<T>(schema, data.children as Data<T[keyof T]>[], length);\n                break;\n            }\n            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n        }\n    }\n\n    protected _dictionaries?: Map<number, Vector>;\n\n    public readonly schema: Schema<T>;\n    public readonly data: Data<Struct<T>>;\n\n    public get dictionaries() {\n        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n    }\n\n    /**\n     * The number of columns in this RecordBatch.\n     */\n    public get numCols() { return this.schema.fields.length; }\n\n    /**\n     * The number of rows in this RecordBatch.\n     */\n    public get numRows() { return this.data.length; }\n\n    /**\n     * The number of null rows in this RecordBatch.\n     */\n    public get nullCount() {\n        return this.data.nullCount;\n    }\n\n    /**\n     * Check whether an element is null.\n     * @param index The index at which to read the validity bitmap.\n     */\n    public isValid(index: number) {\n        return this.data.getValid(index);\n    }\n\n    /**\n     * Get a row by position.\n     * @param index The index of the element to read.\n     */\n    public get(index: number) {\n        return getVisitor.visit(this.data, index);\n    }\n\n    /**\n     * Set a row by position.\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    public set(index: number, value: Struct<T>['TValue']) {\n        return setVisitor.visit(this.data, index, value);\n    }\n\n    /**\n     * Retrieve the index of the first occurrence of a row in an RecordBatch.\n     * @param element The row to locate in the RecordBatch.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    public indexOf(element: Struct<T>['TValue'], offset?: number): number {\n        return indexOfVisitor.visit(this.data, element, offset);\n    }\n\n    /**\n     * Get the size (in bytes) of a row by index.\n     * @param index The row index for which to compute the byteLength.\n     */\n    public getByteLength(index: number): number {\n        return byteLengthVisitor.visit(this.data, index);\n    }\n\n    /**\n     * Iterator for rows in this RecordBatch.\n     */\n    public [Symbol.iterator]() {\n        return iteratorVisitor.visit(new Vector([this.data])) as IterableIterator<Struct<T>['TValue']>;\n    }\n\n    /**\n     * Return a JavaScript Array of the RecordBatch rows.\n     * @returns An Array of RecordBatch rows.\n     */\n    public toArray() {\n        return [...this];\n    }\n\n    /**\n     * Combines two or more RecordBatch of the same schema.\n     * @param others Additional RecordBatch to add to the end of this RecordBatch.\n     */\n    public concat(...others: RecordBatch<T>[]) {\n        return new Table(this.schema, [this, ...others]);\n    }\n\n    /**\n     * Return a zero-copy sub-section of this RecordBatch.\n     * @param start The beginning of the specified portion of the RecordBatch.\n     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n     */\n    public slice(begin?: number, end?: number): RecordBatch<T> {\n        const [slice] = new Vector([this.data]).slice(begin, end).data;\n        return new RecordBatch(this.schema, slice);\n    }\n\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     * @param name The name of the child to retrieve.\n     */\n    public getChild<P extends keyof T>(name: P) {\n        return this.getChildAt<T[P]>(this.schema.fields?.findIndex((f) => f.name === name));\n    }\n\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     * @param index The index of the child to retrieve.\n     */\n    public getChildAt<R extends DataType = any>(index: number): Vector<R> | null {\n        if (index > -1 && index < this.schema.fields.length) {\n            return new Vector([this.data.children[index]]) as Vector<R>;\n        }\n        return null;\n    }\n\n    /**\n     * Sets a child Vector by name.\n     * @param name The name of the child to overwrite.\n     * @returns A new RecordBatch with the new child for the specified name.\n     */\n    public setChild<P extends keyof T, R extends DataType>(name: P, child: Vector<R>) {\n        return this.setChildAt(this.schema.fields?.findIndex((f) => f.name === name), child) as RecordBatch<T & { [K in P]: R }>;\n    }\n\n    /**\n     * Sets a child Vector by index.\n     * @param index The index of the child to overwrite.\n     * @returns A new RecordBatch with the new child at the specified index.\n     */\n    public setChildAt(index: number, child?: null): RecordBatch;\n    public setChildAt<R extends DataType = any>(index: number, child: Vector<R>): RecordBatch;\n    public setChildAt(index: number, child: any) {\n        let schema: Schema = this.schema;\n        let data: Data<Struct> = this.data;\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice() as Field<any>[];\n            const children = data.children.slice() as Data<any>[];\n            const field = fields[index].clone({ type: child.type });\n            [fields[index], children[index]] = [field, child.data[0]];\n            schema = new Schema(fields, new Map(this.schema.metadata));\n            data = makeData({ type: new Struct<T>(fields), children });\n        }\n        return new RecordBatch(schema, data);\n    }\n\n    /**\n     * Construct a new RecordBatch containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new RecordBatch of columns matching the specified names.\n     */\n    public select<K extends keyof T = any>(columnNames: K[]) {\n        const schema = this.schema.select(columnNames);\n        const type = new Struct(schema.fields);\n        const children = [] as Data<T[K]>[];\n        for (const name of columnNames) {\n            const index = this.schema.fields.findIndex((f) => f.name === name);\n            if (~index) {\n                children[index] = this.data.children[index] as Data<T[K]>;\n            }\n        }\n        return new RecordBatch(schema, makeData({ type, length: this.numRows, children }));\n    }\n\n    /**\n     * Construct a new RecordBatch containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new RecordBatch of columns matching at the specified indices.\n     */\n    public selectAt<K extends T = any>(columnIndices: number[]) {\n        const schema = this.schema.selectAt<K>(columnIndices);\n        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n        const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });\n        return new RecordBatch<{ [P in keyof K]: K[P] }>(schema, subset);\n    }\n\n    // Initialize this static property via an IIFE so bundlers don't tree-shake\n    // out this logic, but also so we're still compliant with `\"sideEffects\": false`\n    protected static [Symbol.toStringTag] = ((proto: RecordBatch) => {\n        (proto as any)._nullCount = -1;\n        (proto as any)[Symbol.isConcatSpreadable] = true;\n        return 'RecordBatch';\n    })(RecordBatch.prototype);\n}\n\n\n/** @ignore */\nfunction ensureSameLengthData<T extends TypeMap = any>(\n    schema: Schema<T>,\n    chunks: Data<T[keyof T]>[],\n    maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)\n) {\n    const fields = [...schema.fields];\n    const children = [...chunks] as Data<T[keyof T]>[];\n    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;\n\n    for (const [idx, field] of schema.fields.entries()) {\n        const chunk = chunks[idx];\n        if (!chunk || chunk.length !== maxLength) {\n            fields[idx] = field.clone({ nullable: true });\n            children[idx] = chunk?._changeLengthAndBackfillNullBitmap(maxLength) ?? makeData({\n                type: field.type,\n                length: maxLength,\n                nullCount: maxLength,\n                nullBitmap: new Uint8Array(nullBitmapSize)\n            });\n        }\n    }\n\n    return [\n        schema.assign(fields),\n        makeData({ type: new Struct<T>(fields), length: maxLength, children })\n    ] as [Schema<T>, Data<Struct<T>>];\n}\n\n/** @ignore */\nfunction collectDictionaries(fields: Field[], children: Data[], dictionaries = new Map<number, Vector>()): Map<number, Vector> {\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        const data = children[i];\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                if (data.dictionary) {\n                    dictionaries.set(type.id, data.dictionary);\n                }\n            } else if (dictionaries.get(type.id) !== data.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            collectDictionaries(type.children, data.children, dictionaries);\n        }\n    }\n    return dictionaries;\n}\n\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport class _InternalEmptyPlaceholderRecordBatch<T extends TypeMap = any> extends RecordBatch<T> {\n    constructor(schema: Schema<T>) {\n        const children = schema.fields.map((f) => makeData({ type: f.type }));\n        const data = makeData({ type: new Struct<T>(schema.fields), nullCount: 0, children });\n        super(schema, data);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}